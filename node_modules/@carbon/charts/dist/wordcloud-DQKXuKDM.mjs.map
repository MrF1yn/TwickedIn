{"version":3,"file":"wordcloud-DQKXuKDM.mjs","sources":["../../../node_modules/lodash-es/_arrayAggregator.js","../../../node_modules/lodash-es/_baseAggregator.js","../../../node_modules/lodash-es/_createAggregator.js","../../../node_modules/lodash-es/fromPairs.js","../../../node_modules/lodash-es/groupBy.js","../src/model/model.ts","../src/model/cartesian-charts.ts","../src/model/alluvial.ts","../src/model/boxplot.ts","../src/model/bullet.ts","../src/model/choropleth.ts","../src/model/circle-pack.ts","../src/model/pie.ts","../src/model/gauge.ts","../src/model/heatmap.ts","../src/model/binned-charts.ts","../src/model/meter.ts","../src/model/radar.ts","../src/model/tree.ts","../src/model/treemap.ts","../src/model/wordcloud.ts"],"sourcesContent":["/**\n * A specialized version of `baseAggregator` for arrays.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} setter The function to set `accumulator` values.\n * @param {Function} iteratee The iteratee to transform keys.\n * @param {Object} accumulator The initial aggregated object.\n * @returns {Function} Returns `accumulator`.\n */\nfunction arrayAggregator(array, setter, iteratee, accumulator) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    var value = array[index];\n    setter(accumulator, value, iteratee(value), array);\n  }\n  return accumulator;\n}\n\nexport default arrayAggregator;\n","import baseEach from './_baseEach.js';\n\n/**\n * Aggregates elements of `collection` on `accumulator` with keys transformed\n * by `iteratee` and values set by `setter`.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} setter The function to set `accumulator` values.\n * @param {Function} iteratee The iteratee to transform keys.\n * @param {Object} accumulator The initial aggregated object.\n * @returns {Function} Returns `accumulator`.\n */\nfunction baseAggregator(collection, setter, iteratee, accumulator) {\n  baseEach(collection, function(value, key, collection) {\n    setter(accumulator, value, iteratee(value), collection);\n  });\n  return accumulator;\n}\n\nexport default baseAggregator;\n","import arrayAggregator from './_arrayAggregator.js';\nimport baseAggregator from './_baseAggregator.js';\nimport baseIteratee from './_baseIteratee.js';\nimport isArray from './isArray.js';\n\n/**\n * Creates a function like `_.groupBy`.\n *\n * @private\n * @param {Function} setter The function to set accumulator values.\n * @param {Function} [initializer] The accumulator object initializer.\n * @returns {Function} Returns the new aggregator function.\n */\nfunction createAggregator(setter, initializer) {\n  return function(collection, iteratee) {\n    var func = isArray(collection) ? arrayAggregator : baseAggregator,\n        accumulator = initializer ? initializer() : {};\n\n    return func(collection, setter, baseIteratee(iteratee, 2), accumulator);\n  };\n}\n\nexport default createAggregator;\n","/**\n * The inverse of `_.toPairs`; this method returns an object composed\n * from key-value `pairs`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} pairs The key-value pairs.\n * @returns {Object} Returns the new object.\n * @example\n *\n * _.fromPairs([['a', 1], ['b', 2]]);\n * // => { 'a': 1, 'b': 2 }\n */\nfunction fromPairs(pairs) {\n  var index = -1,\n      length = pairs == null ? 0 : pairs.length,\n      result = {};\n\n  while (++index < length) {\n    var pair = pairs[index];\n    result[pair[0]] = pair[1];\n  }\n  return result;\n}\n\nexport default fromPairs;\n","import baseAssignValue from './_baseAssignValue.js';\nimport createAggregator from './_createAggregator.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an object composed of keys generated from the results of running\n * each element of `collection` thru `iteratee`. The order of grouped values\n * is determined by the order they occur in `collection`. The corresponding\n * value of each key is an array of elements responsible for generating the\n * key. The iteratee is invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n * @returns {Object} Returns the composed aggregate object.\n * @example\n *\n * _.groupBy([6.1, 4.2, 6.3], Math.floor);\n * // => { '4': [4.2], '6': [6.1, 6.3] }\n *\n * // The `_.property` iteratee shorthand.\n * _.groupBy(['one', 'two', 'three'], 'length');\n * // => { '3': ['one', 'two'], '5': ['three'] }\n */\nvar groupBy = createAggregator(function(result, value, key) {\n  if (hasOwnProperty.call(result, key)) {\n    result[key].push(value);\n  } else {\n    baseAssignValue(result, key, [value]);\n  }\n});\n\nexport default groupBy;\n","import { bin as d3Bin, scaleOrdinal, stack, stackOffsetDiverging } from 'd3'\nimport { cloneDeep, fromPairs, groupBy, merge, uniq } from 'lodash-es'\nimport { getProperty, updateLegendAdditionalItems } from '@/tools'\nimport { color as colorConfigs, legend as legendConfigs } from '@/configuration'\nimport { histogram as histogramConfigs } from '@/configuration-non-customizable'\nimport { Events, ScaleTypes, ColorClassNameTypes } from '@/interfaces/enums'\nimport { formatDateTillMilliSeconds } from '@/services/time-series'\nimport type { ChartTabularData } from '@/interfaces/model'\n\nexport type StackKeysParams = {\n\tbins?: any\n\tgroups?: any\n\tpercentage?: any\n\tdivergent?: any\n}\n\nfunction _sanitizeCsvCell(cellContent: string): string {\n\tconst _trimmedCell = cellContent.trim()\n\tif (['=', '+', '-', '@', '\\t', '\\r'].includes(_trimmedCell.charAt(0))) {\n\t\treturn `\\xA0${_trimmedCell}`\n\t}\n\n\t// Only add quotes if cell contains commas, newlines, or quotes\n\tif (/[,\\\"\\n]/.test(_trimmedCell)) {\n\t\treturn `\"${_trimmedCell}\"`\n\t}\n\n\treturn _trimmedCell\n}\n\n/** The charting model layer which includes mainly the chart data and options,\n * as well as some misc. information to be shared among components */\nexport class ChartModel {\n\tprotected services: any\n\n\t// Internal Model state\n\tprotected state: any = {\n\t\toptions: {}\n\t}\n\n\t// Data labels\n\t/**\n\t * A list of all the data groups that have existed within the lifetime of the chart\n\t * @type string[]\n\t */\n\tprotected allDataGroups: string[]\n\n\t// Fill scales & fill related objects\n\tprotected colorScale: any = {}\n\n\tprotected colorClassNames: any = {}\n\n\tconstructor(services: any) {\n\t\tthis.services = services\n\t}\n\n\tformatTable({ headers, cells }) {\n\t\tconst options = this.getOptions()\n\t\tconst {\n\t\t\tcode: localeCode,\n\t\t\tdate: dateFormatter,\n\t\t\tnumber: numberFormatter\n\t\t} = getProperty(options, 'locale')\n\t\tconst tableHeadingFormatter = getProperty(options, 'tabularRepModal', 'tableHeadingFormatter')\n\t\tconst tableCellFormatter = getProperty(options, 'tabularRepModal', 'tableCellFormatter')\n\t\tconst { cartesianScales } = this.services\n\t\tconst domainScaleType = cartesianScales?.getDomainAxisScaleType()\n\t\tlet domainValueFormatter: any\n\n\t\tif (domainScaleType === ScaleTypes.TIME) {\n\t\t\tdomainValueFormatter = (d: any) =>\n\t\t\t\tdateFormatter(d, localeCode, { month: 'short', day: 'numeric', year: 'numeric' })\n\t\t}\n\n\t\tconst result = [\n\t\t\ttypeof tableHeadingFormatter === 'function' ? tableHeadingFormatter(headers) : headers,\n\t\t\t...(typeof tableCellFormatter === 'function'\n\t\t\t\t? tableCellFormatter(cells)\n\t\t\t\t: cells.map((data: (string | number)[]) => {\n\t\t\t\t\t\tif (domainValueFormatter) {\n\t\t\t\t\t\t\tdata[1] = domainValueFormatter(data[1]) as string\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (let i in data) {\n\t\t\t\t\t\t\tlet val = data[i]\n\t\t\t\t\t\t\tif (typeof val === 'number') {\n\t\t\t\t\t\t\t\tdata[i] = numberFormatter(val, localeCode)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn data\n\t\t\t\t\t}))\n\t\t]\n\t\treturn result\n\t}\n\n\tgetAllDataFromDomain(groups?: any) {\n\t\tif (!this.getData()) {\n\t\t\treturn null\n\t\t}\n\t\tconst options = this.getOptions()\n\t\t// Remove datasets that have been disabled\n\t\tlet allData = this.getData()\n\t\tconst dataGroups = this.getDataGroups()\n\t\tconst { groupMapsTo } = getProperty(options, 'data')\n\t\tconst axesOptions = getProperty(options, 'axes')\n\n\t\t// filter out the groups that are irrelevant to the component\n\t\tif (groups) {\n\t\t\tallData = allData.filter((item: any) => groups.includes(item[groupMapsTo]))\n\t\t}\n\n\t\tif (axesOptions) {\n\t\t\tObject.keys(axesOptions).forEach(axis => {\n\t\t\t\tconst mapsTo = axesOptions[axis].mapsTo\n\t\t\t\tconst scaleType = axesOptions[axis].scaleType\n\t\t\t\t// make sure linear/log values are numbers\n\t\t\t\tif (scaleType === ScaleTypes.LINEAR || scaleType === ScaleTypes.LOG) {\n\t\t\t\t\tallData = allData.map((datum: any) => {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t...datum,\n\t\t\t\t\t\t\t[mapsTo]: datum[mapsTo] === null ? datum[mapsTo] : Number(datum[mapsTo])\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\t// Check for custom domain\n\t\t\t\tif (mapsTo && axesOptions[axis].domain) {\n\t\t\t\t\tif (scaleType === ScaleTypes.LABELS) {\n\t\t\t\t\t\tallData = allData.filter((datum: any) =>\n\t\t\t\t\t\t\taxesOptions[axis].domain.includes(datum[mapsTo])\n\t\t\t\t\t\t)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst [start, end] = axesOptions[axis].domain\n\t\t\t\t\t\t// Filter out data outside domain if that datapoint is using that axis (has mapsTo property)\n\t\t\t\t\t\tallData = allData.filter(\n\t\t\t\t\t\t\t(datum: any) => !(mapsTo in datum) || (datum[mapsTo] >= start && datum[mapsTo] <= end)\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\treturn allData.filter((datum: any) => {\n\t\t\treturn dataGroups.find((group: any) => group.name === datum[groupMapsTo])\n\t\t})\n\t}\n\n\t/**\n\t * Charts that have group configs passed into them, only want to retrieve the display data relevant to that chart\n\t * @param groups the included datasets for the particular chart\n\t */\n\tgetDisplayData(groups?: any) {\n\t\tif (!this.get('data')) {\n\t\t\treturn null\n\t\t}\n\n\t\tconst { ACTIVE } = legendConfigs.items.status\n\t\tconst dataGroups = this.getDataGroups(groups)\n\t\tconst { groupMapsTo } = this.getOptions().data\n\t\tconst allDataFromDomain = this.getAllDataFromDomain(groups)\n\n\t\treturn allDataFromDomain.filter((datum: any) => {\n\t\t\treturn dataGroups.find(\n\t\t\t\t(dataGroup: any) => dataGroup.name === datum[groupMapsTo] && dataGroup.status === ACTIVE\n\t\t\t)\n\t\t})\n\t}\n\n\tgetData() {\n\t\treturn this.get('data')\n\t}\n\n\tisDataEmpty() {\n\t\treturn !this.getData().length\n\t}\n\n\t/**\n\t *\n\t * @param newData The new raw data to be set\n\t */\n\tsetData(newData: any) {\n\t\tconst sanitizedData = this.sanitize(cloneDeep(newData))\n\t\tconst dataGroups = this.generateDataGroups(sanitizedData)\n\n\t\tthis.set({\n\t\t\tdata: sanitizedData,\n\t\t\tdataGroups\n\t\t})\n\n\t\treturn sanitizedData\n\t}\n\n\tgetDataGroups(groups?: any) {\n\t\tconst isDataLoading = getProperty(this.getOptions(), 'data', 'loading')\n\n\t\t// No data should be displayed while data is still loading\n\t\tif (isDataLoading) {\n\t\t\treturn []\n\t\t}\n\n\t\t// if its a combo chart, the specific chart will pass the model the groups it needs\n\t\tif (groups) {\n\t\t\treturn this.get('dataGroups').filter((dataGroup: any) => groups.includes(dataGroup.name))\n\t\t}\n\t\treturn this.get('dataGroups')\n\t}\n\n\tgetActiveDataGroups(groups?: any) {\n\t\tconst { ACTIVE } = legendConfigs.items.status\n\n\t\treturn this.getDataGroups(groups).filter((dataGroup: any) => dataGroup.status === ACTIVE)\n\t}\n\n\tgetDataGroupNames(groups?: any) {\n\t\tconst dataGroups = this.getDataGroups(groups)\n\t\treturn dataGroups.map((dataGroup: any) => dataGroup.name)\n\t}\n\n\tgetActiveDataGroupNames(groups?: any) {\n\t\tconst activeDataGroups = this.getActiveDataGroups(groups)\n\t\treturn activeDataGroups.map((dataGroup: any) => dataGroup.name)\n\t}\n\n\tprivate aggregateBinDataByGroup(bin: any) {\n\t\treturn groupBy(bin, 'group')\n\t}\n\n\tgetBinConfigurations() {\n\t\t// Manipulate data and options for Histogram\n\t\tconst data = this.getDisplayData()\n\t\tconst options = this.getOptions()\n\n\t\tconst mainXPos = this.services.cartesianScales.getMainXAxisPosition()\n\t\tconst domainIdentifier = this.services.cartesianScales.getDomainIdentifier()\n\n\t\tconst axisOptions = options.axes[mainXPos]\n\t\tconst { groupMapsTo } = options.data\n\t\tconst { bins: axisBins = histogramConfigs.defaultBins } = axisOptions\n\t\tconst areBinsDefined = Array.isArray(axisBins)\n\n\t\t// Get Histogram bins\n\t\tconst bins = d3Bin()\n\t\t\t.value((d: any) => d[domainIdentifier])\n\t\t\t.thresholds(axisBins)(data)\n\n\t\tif (!areBinsDefined) {\n\t\t\t// If bins are not defined by user\n\t\t\tconst binsWidth = bins[0].x1 - bins[0].x0\n\t\t\t// Set last bin width as the others\n\t\t\tbins[bins.length - 1].x1 = +bins[bins.length - 1].x0 + binsWidth\n\t\t} else {\n\t\t\t// Set last bin end as the last user defined one\n\t\t\tbins[bins.length - 1].x1 = axisBins[axisBins.length - 1]\n\t\t}\n\n\t\tconst binsDomain = areBinsDefined\n\t\t\t? [axisBins[0], axisBins[axisBins.length - 1]]\n\t\t\t: [bins[0].x0, bins[bins.length - 1].x1]\n\n\t\t// Get all groups\n\t\tconst groupsKeys = Array.from(new Set(data.map((d: any) => d[groupMapsTo])))\n\n\t\tconst histogramData = []\n\n\t\t// Group data by bin\n\t\tbins.forEach(bin => {\n\t\t\tconst key = `${bin.x0}-${bin.x1}`\n\t\t\tconst aggregateDataByGroup = this.aggregateBinDataByGroup(bin)\n\n\t\t\tgroupsKeys.forEach((group: string) => {\n\t\t\t\t// For each dataset put a bin with value 0 if not exist\n\t\t\t\t// (Scale X won't change when changing showed datasets)\n\t\t\t\thistogramData.push({\n\t\t\t\t\tgroup,\n\t\t\t\t\tkey,\n\t\t\t\t\tvalue: aggregateDataByGroup[group] || 0,\n\t\t\t\t\tbin: bin.x0\n\t\t\t\t})\n\t\t\t})\n\t\t})\n\n\t\treturn {\n\t\t\tbins,\n\t\t\tbinsDomain\n\t\t}\n\t}\n\n\tgetBinnedStackedData() {\n\t\tconst options = this.getOptions()\n\t\tconst { groupMapsTo } = options.data\n\n\t\tconst dataGroupNames = this.getActiveDataGroupNames()\n\n\t\tconst { bins } = this.getBinConfigurations()\n\t\tconst dataValuesGroupedByKeys = this.getDataValuesGroupedByKeys({\n\t\t\tbins\n\t\t})\n\n\t\treturn stack()\n\t\t\t.keys(dataGroupNames)(dataValuesGroupedByKeys)\n\t\t\t.map((series, i) => {\n\t\t\t\t// Add data group names to each series\n\t\t\t\treturn Object.keys(series)\n\t\t\t\t\t.filter((key: any) => !isNaN(key))\n\t\t\t\t\t.map((key: any) => {\n\t\t\t\t\t\tconst element = series[key]\n\t\t\t\t\t\telement[groupMapsTo] = dataGroupNames[i]\n\n\t\t\t\t\t\treturn element\n\t\t\t\t\t})\n\t\t\t})\n\t}\n\n\tgetGroupedData(groups?: any) {\n\t\tconst displayData = this.getDisplayData(groups)\n\t\tconst groupedData: any = {}\n\t\tconst { groupMapsTo } = this.getOptions().data\n\n\t\tdisplayData.map((datum: any) => {\n\t\t\tconst group = datum[groupMapsTo]\n\t\t\tif (groupedData[group] !== null && groupedData[group] !== undefined) {\n\t\t\t\tgroupedData[group].push(datum)\n\t\t\t} else {\n\t\t\t\tgroupedData[group] = [datum]\n\t\t\t}\n\t\t})\n\n\t\treturn Object.keys(groupedData).map(groupName => ({\n\t\t\tname: groupName,\n\t\t\tdata: groupedData[groupName]\n\t\t}))\n\t}\n\n\tgetStackKeys({ bins = null, groups = null }: StackKeysParams = { bins: null, groups: null }) {\n\t\tconst options = this.getOptions()\n\n\t\tconst displayData = this.getDisplayData(groups)\n\n\t\tlet stackKeys: any\n\t\tif (bins) {\n\t\t\tstackKeys = bins.map((bin: any) => `${bin.x0}:${bin.x1}`)\n\t\t} else {\n\t\t\tstackKeys = uniq(\n\t\t\t\tdisplayData.map((datum: any) => {\n\t\t\t\t\tconst domainIdentifier = this.services.cartesianScales.getDomainIdentifier(datum)\n\n\t\t\t\t\t// Use time value as key for Date object to avoid multiple data in the same second\n\t\t\t\t\tif (datum[domainIdentifier] instanceof Date) {\n\t\t\t\t\t\treturn formatDateTillMilliSeconds(datum[domainIdentifier])\n\t\t\t\t\t}\n\n\t\t\t\t\treturn datum[domainIdentifier] && typeof datum[domainIdentifier].toString === 'function'\n\t\t\t\t\t\t? datum[domainIdentifier].toString()\n\t\t\t\t\t\t: datum[domainIdentifier]\n\t\t\t\t})\n\t\t\t)\n\t\t}\n\n\t\tconst axisPosition = this.services.cartesianScales.domainAxisPosition\n\t\tconst scaleType = options.axes[axisPosition].scaleType\n\n\t\t// Sort keys\n\t\tif (scaleType === ScaleTypes.TIME) {\n\t\t\tstackKeys.sort((a: any, b: any) => {\n\t\t\t\tconst dateA: any = new Date(a)\n\t\t\t\tconst dateB: any = new Date(b)\n\n\t\t\t\treturn dateA - dateB\n\t\t\t})\n\t\t} else if (scaleType === ScaleTypes.LOG || scaleType === ScaleTypes.LINEAR) {\n\t\t\tstackKeys.sort((a: any, b: any) => a - b)\n\t\t}\n\n\t\treturn stackKeys\n\t}\n\n\tgetDataValuesGroupedByKeys({ bins = null, groups = null }: StackKeysParams) {\n\t\tconst options = this.getOptions()\n\t\tconst { groupMapsTo } = options.data\n\t\tconst displayData = this.getDisplayData(groups)\n\n\t\tconst dataGroupNames = this.getDataGroupNames()\n\n\t\tconst stackKeys = this.getStackKeys({ bins, groups })\n\t\tif (bins) {\n\t\t\treturn stackKeys.map((key: any) => {\n\t\t\t\tconst [binStart, binEnd] = key.split(':')\n\n\t\t\t\tconst correspondingValues: any = { x0: binStart, x1: binEnd }\n\t\t\t\tconst correspondingBin = bins.find((bin: any) => bin.x0.toString() === binStart.toString())\n\t\t\t\tdataGroupNames.forEach((dataGroupName: any) => {\n\t\t\t\t\tcorrespondingValues[dataGroupName] = correspondingBin.filter(\n\t\t\t\t\t\t(binItem: any) => binItem[groupMapsTo] === dataGroupName\n\t\t\t\t\t).length\n\t\t\t\t})\n\n\t\t\t\treturn correspondingValues\n\t\t\t}) as any\n\t\t}\n\n\t\treturn stackKeys.map((key: any) => {\n\t\t\tconst correspondingValues: any = { sharedStackKey: key }\n\t\t\tdataGroupNames.forEach((dataGroupName: any) => {\n\t\t\t\tconst correspondingDatum = displayData.find((datum: any) => {\n\t\t\t\t\tconst domainIdentifier = this.services.cartesianScales.getDomainIdentifier(datum)\n\n\t\t\t\t\treturn (\n\t\t\t\t\t\tdatum[groupMapsTo] === dataGroupName &&\n\t\t\t\t\t\tObject.prototype.hasOwnProperty.call(datum, domainIdentifier) &&\n\t\t\t\t\t\t(datum[domainIdentifier] instanceof Date\n\t\t\t\t\t\t\t? formatDateTillMilliSeconds(datum[domainIdentifier]) === key\n\t\t\t\t\t\t\t: datum[domainIdentifier].toString() === key)\n\t\t\t\t\t)\n\t\t\t\t})\n\n\t\t\t\tconst rangeIdentifier =\n\t\t\t\t\tthis.services.cartesianScales.getRangeIdentifier(correspondingValues)\n\t\t\t\tcorrespondingValues[dataGroupName] = correspondingDatum\n\t\t\t\t\t? correspondingDatum[rangeIdentifier]\n\t\t\t\t\t: null\n\t\t\t})\n\n\t\t\treturn correspondingValues\n\t\t}) as any\n\t}\n\n\tgetStackedData({ percentage = false, groups = null, divergent = false }: StackKeysParams) {\n\t\tconst options = this.getOptions()\n\t\tconst { groupMapsTo } = options.data\n\n\t\t// Get only active data groups so non-active data groups are not rendered\n\t\t// on legend item click\n\t\tconst dataGroupNames = this.getActiveDataGroupNames(groups)\n\t\tconst dataValuesGroupedByKeys = this.getDataValuesGroupedByKeys({\n\t\t\tgroups\n\t\t})\n\n\t\tif (percentage) {\n\t\t\tconst maxByKey = fromPairs(dataValuesGroupedByKeys.map((d: any) => [d.sharedStackKey, 0]))\n\n\t\t\tdataValuesGroupedByKeys.forEach((d: any) => {\n\t\t\t\tdataGroupNames.forEach((name: any) => {\n\t\t\t\t\tmaxByKey[d.sharedStackKey] += d[name]\n\t\t\t\t})\n\t\t\t})\n\n\t\t\t// cycle through data values to get percentage\n\t\t\tdataValuesGroupedByKeys.forEach((d: any) => {\n\t\t\t\tdataGroupNames.forEach((name: any) => {\n\t\t\t\t\tconst denominator: number = maxByKey[d.sharedStackKey] as number\n\t\t\t\t\tif (maxByKey[d.sharedStackKey]) {\n\t\t\t\t\t\td[name] = (d[name] / denominator) * 100\n\t\t\t\t\t} else {\n\t\t\t\t\t\td[name] = 0\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t})\n\t\t}\n\n\t\tconst stackToUse = divergent ? stack().offset(stackOffsetDiverging) : stack()\n\n\t\treturn stackToUse\n\t\t\t.keys(dataGroupNames)(dataValuesGroupedByKeys)\n\t\t\t.map((series: any, i: number) => {\n\t\t\t\t// Add data group names to each series\n\t\t\t\treturn Object.keys(series)\n\t\t\t\t\t.filter((key: any) => !isNaN(key))\n\t\t\t\t\t.map((key: any) => {\n\t\t\t\t\t\tconst element = series[key]\n\t\t\t\t\t\telement[groupMapsTo] = dataGroupNames[i]\n\n\t\t\t\t\t\treturn element\n\t\t\t\t\t})\n\t\t\t})\n\t}\n\n\t/**\n\t * @return {Object} The chart's options\n\t */\n\tgetOptions() {\n\t\treturn this.state.options\n\t}\n\n\tset(newState: any, configs?: any) {\n\t\tthis.state = Object.assign({}, this.state, newState)\n\t\tconst newConfig = Object.assign(\n\t\t\t{ skipUpdate: false, animate: true }, // default configs\n\t\t\tconfigs\n\t\t)\n\t\tif (!newConfig.skipUpdate) {\n\t\t\tthis.update(newConfig.animate)\n\t\t}\n\t}\n\n\tget(property?: string) {\n\t\tif (property) {\n\t\t\treturn this.state[property]\n\t\t} else {\n\t\t\treturn this.state\n\t\t}\n\t}\n\n\t/**\n\t *\n\t * @param newOptions New options to be set\n\t */\n\tsetOptions(newOptions: any) {\n\t\tconst options = this.getOptions()\n\t\tupdateLegendAdditionalItems(options, newOptions)\n\n\t\tthis.set({\n\t\t\toptions: merge(options, newOptions)\n\t\t})\n\t}\n\n\t/**\n\t *\n\t * Updates miscellanous information within the model\n\t * such as the color scales, or the legend data labels\n\t */\n\tupdate(animate = true) {\n\t\tif (!this.getDisplayData()) {\n\t\t\treturn\n\t\t}\n\n\t\tthis.updateAllDataGroups()\n\n\t\tthis.setCustomColorScale()\n\t\tthis.setColorClassNames()\n\t\tthis.services.events.dispatchEvent(Events.Model.UPDATE, { animate })\n\t}\n\n\t/*\n\t * Data labels\n\t */\n\ttoggleDataLabel(changedLabel: string) {\n\t\tconst { ACTIVE, DISABLED } = legendConfigs.items.status\n\t\tconst dataGroups = this.getDataGroups()\n\n\t\tconst hasDeactivatedItems = dataGroups.some((group: any) => group.status === DISABLED)\n\t\tconst activeItems = dataGroups.filter((group: any) => group.status === ACTIVE)\n\n\t\t// If there are deactivated items, toggle \"changedLabel\"\n\t\tif (hasDeactivatedItems) {\n\t\t\t// If the only active item is being toggled\n\t\t\t// Activate all items\n\t\t\tif (activeItems.length === 1 && activeItems[0].name === changedLabel) {\n\t\t\t\t// If every item is active, then enable \"changedLabel\" and disable all other items\n\t\t\t\tdataGroups.forEach((_: any, i: number) => {\n\t\t\t\t\tdataGroups[i].status = ACTIVE\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tconst indexToChange = dataGroups.findIndex((group: any) => group.name === changedLabel)\n\t\t\t\tdataGroups[indexToChange].status =\n\t\t\t\t\tdataGroups[indexToChange].status === DISABLED ? ACTIVE : DISABLED\n\t\t\t}\n\t\t} else {\n\t\t\t// If every item is active, then enable \"changedLabel\" and disable all other items\n\t\t\tdataGroups.forEach((group: any, i: number) => {\n\t\t\t\tdataGroups[i].status = group.name === changedLabel ? ACTIVE : DISABLED\n\t\t\t})\n\t\t}\n\n\t\t// Updates selected groups\n\t\tconst updatedActiveItems = dataGroups.filter((group: any) => group.status === ACTIVE)\n\t\tconst options = this.getOptions()\n\n\t\tconst hasUpdatedDeactivatedItems = dataGroups.some((group: any) => group.status === DISABLED)\n\n\t\t// If there are deactivated items, map the item name into selected groups\n\t\tif (hasUpdatedDeactivatedItems) {\n\t\t\toptions.data.selectedGroups = updatedActiveItems.map((activeItem: any) => activeItem.name)\n\t\t} else {\n\t\t\t// If every item is active, clear array\n\t\t\toptions.data.selectedGroups = []\n\t\t}\n\n\t\t// dispatch legend filtering event with the status of all the dataLabels\n\t\tthis.services.events.dispatchEvent(Events.Legend.ITEMS_UPDATE, {\n\t\t\tdataGroups\n\t\t})\n\n\t\t// Update model\n\t\tthis.set({\n\t\t\tdataGroups\n\t\t})\n\t}\n\n\t/**\n\t * Should the data point be filled?\n\t * @param group\n\t * @param key\n\t * @param data\n\t * @param defaultFilled the default for this chart\n\t */\n\tgetIsFilled(group: any, key?: any, data?: any, defaultFilled?: boolean) {\n\t\tconst options = this.getOptions()\n\t\tif (options.getIsFilled) {\n\t\t\treturn options.getIsFilled(group, key, data, defaultFilled)\n\t\t} else {\n\t\t\treturn defaultFilled\n\t\t}\n\t}\n\n\tgetFillColor(group: any, key?: any, data?: any) {\n\t\tconst options = this.getOptions()\n\t\tconst defaultFillColor = getProperty(this.colorScale, group)\n\n\t\tif (options.getFillColor) {\n\t\t\treturn options.getFillColor(group, key, data, defaultFillColor)\n\t\t} else {\n\t\t\treturn defaultFillColor\n\t\t}\n\t}\n\n\tgetStrokeColor(group: any, key?: any, data?: any) {\n\t\tconst options = this.getOptions()\n\t\tconst defaultStrokeColor = getProperty(this.colorScale, group)\n\n\t\tif (options.getStrokeColor) {\n\t\t\treturn options.getStrokeColor(group, key, data, defaultStrokeColor)\n\t\t} else {\n\t\t\treturn defaultStrokeColor\n\t\t}\n\t}\n\n\tisUserProvidedColorScaleValid() {\n\t\tconst userProvidedScale = getProperty(this.getOptions(), 'color', 'scale')\n\t\tconst dataGroups = this.getDataGroups()\n\n\t\tif (userProvidedScale == null || Object.keys(userProvidedScale).length == 0) {\n\t\t\treturn false\n\t\t}\n\n\t\treturn dataGroups.some((dataGroup: any) =>\n\t\t\tObject.keys(userProvidedScale).includes(dataGroup.name)\n\t\t)\n\t}\n\n\tgetColorClassName(configs: {\n\t\tclassNameTypes?: ColorClassNameTypes[] // heatmaps do not pass this value\n\t\tdataGroupName?: string | number\n\t\toriginalClassName?: string\n\t\tvalue?: number // required for heatmap override\n\t}) {\n\t\tconst colorPairingTag = this.colorClassNames(configs.dataGroupName)\n\t\tlet className = configs.originalClassName\n\t\tconfigs.classNameTypes.forEach(\n\t\t\ttype =>\n\t\t\t\t(className = configs.originalClassName\n\t\t\t\t\t? `${className} ${type}-${colorPairingTag}`\n\t\t\t\t\t: `${type}-${colorPairingTag}`)\n\t\t)\n\n\t\treturn className || ''\n\t}\n\n\t/**\n\t * For charts that might hold an associated status for their dataset\n\t */\n\tgetStatus(): any {\n\t\treturn null\n\t}\n\n\tgetAllDataGroupsNames() {\n\t\treturn this.allDataGroups\n\t}\n\n\t/**\n\t * Converts data provided in the older format to tabular\n\t *\n\t */\n\tprotected transformToTabularData(data: any) {\n\t\tconsole.warn(\n\t\t\t\"We've updated the charting data format to be tabular by default. The current format you're using is deprecated and will be removed in v1.0, read more here https://charts.carbondesignsystem.com/?path=/story/docs-tutorials--tabular-data-format\"\n\t\t)\n\t\tconst tabularData: ChartTabularData = []\n\t\tconst { datasets, labels } = data\n\n\t\t// Loop through all datasets\n\t\tdatasets.forEach((dataset: any) => {\n\t\t\t// Update each data point to the new format\n\t\t\tdataset.data.forEach((datum: any, i: number) => {\n\t\t\t\tlet group\n\n\t\t\t\tconst datasetLabel = getProperty(dataset, 'label')\n\t\t\t\tif (datasetLabel === null) {\n\t\t\t\t\tconst correspondingLabel = getProperty(labels, i)\n\t\t\t\t\tif (correspondingLabel) {\n\t\t\t\t\t\tgroup = correspondingLabel\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgroup = 'Ungrouped'\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tgroup = datasetLabel\n\t\t\t\t}\n\n\t\t\t\tconst updatedDatum: any = {\n\t\t\t\t\tgroup,\n\t\t\t\t\tkey: labels[i]\n\t\t\t\t}\n\n\t\t\t\tif (isNaN(datum)) {\n\t\t\t\t\tupdatedDatum['value'] = datum.value\n\t\t\t\t\tupdatedDatum['date'] = datum.date\n\t\t\t\t} else {\n\t\t\t\t\tupdatedDatum['value'] = datum\n\t\t\t\t}\n\n\t\t\t\ttabularData.push(updatedDatum)\n\t\t\t})\n\t\t})\n\n\t\treturn tabularData\n\t}\n\n\tgetTabularDataArray(): ChartTabularData {\n\t\t//apply tableFormatter\n\t\treturn []\n\t}\n\n\texportToCSV() {\n\t\tconst data = this.getTabularDataArray().map(row =>\n\t\t\trow.map((column: any) => {\n\t\t\t\tconst columnValue = column === '&ndash;' ? '–' : column\n\n\t\t\t\t// Split by separators and quotes, then sanitize each part individually\n\t\t\t\tconst sanitizedParts = columnValue.split(/[,;'\"`]/).map(part => _sanitizeCsvCell(part))\n\t\t\t\treturn `\"${sanitizedParts.join('')}\"`\n\t\t\t})\n\t\t)\n\n\t\tconst csvString = data.map(row => row.join(',')).join('\\n')\n\n\t\tconst options = this.getOptions()\n\n\t\tlet fileName = 'myChart'\n\t\tconst customFilename = getProperty(options, 'fileDownload', 'fileName')\n\n\t\tif (typeof customFilename === 'function') {\n\t\t\tfileName = customFilename('csv')\n\t\t} else if (typeof customFilename === 'string') {\n\t\t\tfileName = customFilename\n\t\t}\n\n\t\tthis.services.files.downloadCSV(csvString, `${fileName}.csv`)\n\t}\n\n\tprotected getTabularData(data: any) {\n\t\t// if data is not an array\n\t\tif (!Array.isArray(data)) {\n\t\t\treturn this.transformToTabularData(data)\n\t\t}\n\n\t\treturn data\n\t}\n\n\tprotected sanitize(data: any) {\n\t\tdata = this.getTabularData(data)\n\n\t\treturn data\n\t}\n\n\t/*\n\t * Data groups\n\t */\n\tprotected updateAllDataGroups() {\n\t\t// allDataGroups is used to generate a color scale that applies\n\t\t// to all the groups. Now when the data updates, you might remove a group,\n\t\t// and then bring it back in a newer data update, therefore\n\t\t// the order of the groups in allDataGroups matters so that you'd never\n\t\t// have an incorrect color assigned to a group.\n\n\t\t// Also, a new group should only be added to allDataGroups if\n\t\t// it doesn't currently exist\n\n\t\tif (!this.allDataGroups) {\n\t\t\tthis.allDataGroups = this.getDataGroupNames()\n\t\t} else {\n\t\t\t// Loop through current data groups\n\t\t\tthis.getDataGroupNames().forEach((dataGroupName: any) => {\n\t\t\t\t// If group name hasn't been stored yet, store it\n\t\t\t\tif (this.allDataGroups.indexOf(dataGroupName) === -1) {\n\t\t\t\t\tthis.allDataGroups.push(dataGroupName)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tprotected generateDataGroups(data: any) {\n\t\tconst { groupMapsTo } = this.getOptions().data\n\t\tconst { ACTIVE, DISABLED } = legendConfigs.items.status\n\t\tconst options = this.getOptions()\n\n\t\tconst uniqueDataGroups = uniq(data.map((datum: any) => datum[groupMapsTo]))\n\n\t\t// check if selectedGroups can be applied to chart with current data groups\n\t\tif (options.data.selectedGroups.length) {\n\t\t\tconst hasAllSelectedGroups = options.data.selectedGroups.every((groupName: any) =>\n\t\t\t\tuniqueDataGroups.includes(groupName)\n\t\t\t)\n\t\t\tif (!hasAllSelectedGroups) {\n\t\t\t\toptions.data.selectedGroups = []\n\t\t\t}\n\t\t}\n\n\t\t// Get group status based on items in selected groups\n\t\tconst getStatus = (groupName: any) =>\n\t\t\t!options.data.selectedGroups.length || options.data.selectedGroups.includes(groupName)\n\t\t\t\t? ACTIVE\n\t\t\t\t: DISABLED\n\n\t\treturn uniqueDataGroups.map(groupName => ({\n\t\t\tname: groupName,\n\t\t\tstatus: getStatus(groupName)\n\t\t}))\n\t}\n\n\t/*\n\t * Fill scales\n\t */\n\tprotected setCustomColorScale() {\n\t\tif (!this.isUserProvidedColorScaleValid()) {\n\t\t\treturn\n\t\t}\n\n\t\tconst options = this.getOptions()\n\t\tconst userProvidedScale = getProperty(options, 'color', 'scale')\n\n\t\tObject.keys(userProvidedScale).forEach(dataGroup => {\n\t\t\tif (!this.allDataGroups.includes(dataGroup)) {\n\t\t\t\tconsole.warn(`\"${dataGroup}\" does not exist in data groups.`)\n\t\t\t}\n\t\t})\n\n\t\t/**\n\t\t * Go through allDataGroups. If a data group has a color value provided\n\t\t * by the user, add that to the color range\n\t\t */\n\t\tconst providedDataGroups = this.allDataGroups.filter(dataGroup => userProvidedScale[dataGroup])\n\n\t\tprovidedDataGroups.forEach(\n\t\t\tdataGroup => (this.colorScale[dataGroup] = userProvidedScale[dataGroup])\n\t\t)\n\t}\n\n\t/*\n\t * Color palette\n\t */\n\tprotected setColorClassNames() {\n\t\tconst colorPairingOptions = getProperty(this.getOptions(), 'color', 'pairing')\n\n\t\t// Check if user has defined numberOfVariants (differ from given data)\n\t\tlet numberOfVariants = getProperty(colorPairingOptions, 'numberOfVariants')\n\t\tif (!numberOfVariants || numberOfVariants < this.allDataGroups.length) {\n\t\t\tnumberOfVariants = this.allDataGroups.length\n\t\t}\n\n\t\tlet pairingOption = getProperty(colorPairingOptions, 'option')\n\t\tconst colorPairingCounts = colorConfigs.pairingOptions\n\n\t\t// If number of dataGroups is greater than 5, user 14-color palette\n\t\tconst numberOfColors = numberOfVariants > 5 ? 14 : numberOfVariants\n\n\t\t// Use default palette if user choice is not in range\n\t\tconst key = `${numberOfColors}-color` as keyof typeof colorPairingCounts\n\t\tpairingOption = pairingOption <= colorPairingCounts[key] ? pairingOption : 1\n\n\t\t// Create color classes for graph, tooltip and stroke use\n\t\tconst colorPairing = this.allDataGroups.map(\n\t\t\t(_, index) => `${numberOfColors}-${pairingOption}-${(index % 14) + 1}`\n\t\t)\n\n\t\t// Create default color classnames\n\t\tthis.colorClassNames = scaleOrdinal().range(colorPairing).domain(this.allDataGroups)\n\t}\n}\n","import { cloneDeep, uniq } from 'lodash-es'\nimport { getProperty } from '@/tools'\nimport { ChartModel } from './model'\nimport { ScaleTypes, AxisPositions, AxisFlavor } from '@/interfaces/enums'\n\n/**\n * This supports adding X and Y Cartesian[2D] zoom data to a ChartModel\n * */\nexport class ChartModelCartesian extends ChartModel {\n\taxisFlavor = AxisFlavor.DEFAULT // can't be protected as it's used by two-dimensional-axes.ts\n\n\tconstructor(services: any) {\n\t\tsuper(services)\n\t}\n\n\t// get the scales information\n\t// needed for getTabularArray()\n\tprotected assignRangeAndDomains() {\n\t\tconst { cartesianScales } = this.services\n\t\tconst options = this.getOptions()\n\t\tconst isDualAxes = cartesianScales.isDualAxes()\n\n\t\tconst scales = {\n\t\t\tprimaryDomain: cartesianScales.domainAxisPosition,\n\t\t\tprimaryRange: cartesianScales.rangeAxisPosition,\n\t\t\tsecondaryDomain: null as any,\n\t\t\tsecondaryRange: null as any\n\t\t}\n\t\tif (isDualAxes) {\n\t\t\tscales.secondaryDomain = cartesianScales.secondaryDomainAxisPosition\n\t\t\tscales.secondaryRange = cartesianScales.secondaryRangeAxisPosition\n\t\t}\n\n\t\tObject.keys(scales).forEach(\n\t\t\t(scale: 'primaryDomain' | 'primaryRange' | 'secondaryDomain' | 'secondaryRange') => {\n\t\t\t\tconst position = scales[scale]\n\t\t\t\tif (cartesianScales.scales[position]) {\n\t\t\t\t\tscales[scale] = {\n\t\t\t\t\t\tposition: position,\n\t\t\t\t\t\tlabel: cartesianScales.getScaleLabel(position),\n\t\t\t\t\t\tidentifier: getProperty(options, 'axes', position, 'mapsTo')\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tscales[scale] = null\n\t\t\t\t}\n\t\t\t}\n\t\t)\n\n\t\treturn scales\n\t}\n\n\tgetTabularDataArray() {\n\t\tconst displayData = this.getDisplayData()\n\t\tconst options = this.getOptions()\n\t\tconst { groupMapsTo } = options.data\n\t\tconst { primaryDomain, primaryRange, secondaryDomain, secondaryRange } =\n\t\t\tthis.assignRangeAndDomains()\n\t\tconst { number: numberFormatter, code: localeCode } = getProperty(this.getOptions(), 'locale')\n\n\t\tconst headers = [\n\t\t\t'Group',\n\t\t\tprimaryDomain.label,\n\t\t\tprimaryRange.label,\n\t\t\t...(secondaryDomain ? [secondaryDomain.label] : []),\n\t\t\t...(secondaryRange ? [secondaryRange.label] : [])\n\t\t]\n\t\tconst cells = displayData.map((datum: any) => [\n\t\t\tdatum[groupMapsTo],\n\t\t\tdatum[primaryDomain.identifier] === null ? '&ndash;' : datum[primaryDomain.identifier],\n\t\t\tdatum[primaryRange.identifier] === null || isNaN(datum[primaryRange.identifier])\n\t\t\t\t? '&ndash;'\n\t\t\t\t: numberFormatter(datum[primaryRange.identifier], localeCode),\n\t\t\t...(secondaryDomain\n\t\t\t\t? [\n\t\t\t\t\t\tdatum[secondaryDomain.identifier] === null\n\t\t\t\t\t\t\t? '&ndash;'\n\t\t\t\t\t\t\t: datum[secondaryDomain.identifier]\n\t\t\t\t\t]\n\t\t\t\t: []),\n\t\t\t...(secondaryRange\n\t\t\t\t? [\n\t\t\t\t\t\tdatum[secondaryRange.identifier] === null || isNaN(datum[secondaryRange.identifier])\n\t\t\t\t\t\t\t? '&ndash;'\n\t\t\t\t\t\t\t: datum[secondaryRange.identifier]\n\t\t\t\t\t]\n\t\t\t\t: [])\n\t\t])\n\n\t\treturn super.formatTable({ headers, cells })\n\t}\n\n\tsetData(newData: any) {\n\t\tlet data: any\n\t\tif (newData) {\n\t\t\tdata = super.setData(newData)\n\t\t\tif (getProperty(this.getOptions(), 'zoomBar', AxisPositions.TOP, 'enabled')) {\n\t\t\t\t// get pre-defined zoom bar data\n\t\t\t\tconst definedZoomBarData = getProperty(\n\t\t\t\t\tthis.getOptions(),\n\t\t\t\t\t'zoomBar',\n\t\t\t\t\tAxisPositions.TOP,\n\t\t\t\t\t'data'\n\t\t\t\t)\n\t\t\t\t// if we have zoom bar data we need to update it as well\n\t\t\t\t// with pre-defined zoom bar data\n\t\t\t\tthis.setZoomBarData(definedZoomBarData)\n\t\t\t}\n\t\t}\n\n\t\treturn data\n\t}\n\n\t/**\n\t * @param zoomBarData any special zoom bar data to use instead of the model data\n\t */\n\tsetZoomBarData(newZoomBarData?: any) {\n\t\tconst sanitizedData = newZoomBarData\n\t\t\t? this.sanitize(cloneDeep(newZoomBarData))\n\t\t\t: this.getDisplayData() // if we're not passed explicit zoom data use the model\n\n\t\tlet zoomBarNormalizedValues = sanitizedData\n\n\t\tconst { cartesianScales } = this.services\n\t\tif (sanitizedData && cartesianScales.domainAxisPosition && cartesianScales.rangeAxisPosition) {\n\t\t\tconst domainIdentifier = cartesianScales.getDomainIdentifier()\n\t\t\tconst rangeIdentifier = cartesianScales.getRangeIdentifier()\n\t\t\t// get all dates (Number) in displayData\n\t\t\tlet allDates = sanitizedData.map((datum: any) => datum[domainIdentifier].getTime())\n\t\t\tallDates = uniq(allDates).sort()\n\n\t\t\t// Go through all date values\n\t\t\t// And get corresponding data from each dataset\n\t\t\tzoomBarNormalizedValues = allDates.map((date: Date) => {\n\t\t\t\tlet sum = 0\n\t\t\t\tconst datum: any = {}\n\n\t\t\t\tsanitizedData.forEach((data: any) => {\n\t\t\t\t\tif (data[domainIdentifier].getTime() === date) {\n\t\t\t\t\t\tsum += data[rangeIdentifier]\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\tdatum[domainIdentifier] = new Date(date)\n\t\t\t\tdatum[rangeIdentifier] = sum\n\n\t\t\t\treturn datum\n\t\t\t})\n\t\t}\n\n\t\tthis.set({ zoomBarData: zoomBarNormalizedValues })\n\t}\n\n\tgetZoomBarData() {\n\t\treturn this.get('zoomBarData')\n\t}\n\n\tprotected sanitizeDateValues(data: any) {\n\t\tconst options = this.getOptions()\n\n\t\tif (!options.axes) {\n\t\t\treturn data\n\t\t}\n\n\t\tconst keysToCheck: any[] = []\n\t\tObject.keys(AxisPositions).forEach((axisPositionKey: keyof typeof AxisPositions) => {\n\t\t\tconst axisPosition = AxisPositions[axisPositionKey]\n\t\t\tconst axisOptions = options.axes[axisPosition]\n\n\t\t\tif (axisOptions && axisOptions.scaleType === ScaleTypes.TIME) {\n\t\t\t\tconst axisMapsTo = axisOptions.mapsTo\n\n\t\t\t\tif (axisMapsTo !== null || axisMapsTo !== undefined) {\n\t\t\t\t\tkeysToCheck.push(axisMapsTo)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\tif (keysToCheck.length > 0) {\n\t\t\t// Check all datapoints and sanitize dates\n\t\t\tdata.forEach((datum: any) => {\n\t\t\t\tkeysToCheck.forEach((key: any) => {\n\t\t\t\t\tif (getProperty(datum, key, 'getTime') === null) {\n\t\t\t\t\t\tdatum[key] = new Date(datum[key])\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t})\n\t\t}\n\n\t\treturn data\n\t}\n\n\tprotected sanitize(data: any) {\n\t\tdata = super.sanitize(data)\n\t\tdata = this.sanitizeDateValues(data)\n\n\t\treturn data\n\t}\n}\n","// Internal Imports\nimport { ChartModelCartesian } from './cartesian-charts'\nimport { getProperty } from '@/tools'\n/**\n * Alluvial chart model layer\n */\nexport class AlluvialChartModel extends ChartModelCartesian {\n\tconstructor(services: any) {\n\t\tsuper(services)\n\t}\n\n\tgetTabularDataArray() {\n\t\tconst displayData = this.getDisplayData()\n\t\tconst { number: numberFormatter, code: localeCode } = getProperty(this.getOptions(), 'locale')\n\n\t\t// Sort array by source to get a close depiction of the alluvial chart\n\t\tdisplayData.sort((a: any, b: any) => a['source'].localeCompare(b['source']))\n\t\tconst headers = ['Source', 'Target', 'Value']\n\t\tconst cells = [\n\t\t\t...displayData.map((datum: any) => [\n\t\t\t\tdatum['source'],\n\t\t\t\tdatum['target'],\n\t\t\t\tdatum['value'] === null ? '&ndash;' : numberFormatter(datum['value'], localeCode)\n\t\t\t])\n\t\t]\n\n\t\treturn super.formatTable({ headers, cells })\n\t}\n}\n","import { ascending, min, max, quantile, scaleOrdinal } from 'd3'\nimport { getProperty } from '@/tools'\nimport { color as colorConfigs } from '@/configuration'\nimport { ChartModelCartesian } from './cartesian-charts'\n\n/** The charting model layer which includes mainly the chart data and options,\n * as well as some misc. information to be shared among components */\nexport class BoxplotChartModel extends ChartModelCartesian {\n\tconstructor(services: any) {\n\t\tsuper(services)\n\t}\n\n\tgetBoxQuartiles(d: any) {\n\t\treturn {\n\t\t\tq_25: quantile(d, 0.25),\n\t\t\tq_50: quantile(d, 0.5),\n\t\t\tq_75: quantile(d, 0.75)\n\t\t}\n\t}\n\n\tgetBoxplotData() {\n\t\tconst options = this.getOptions()\n\t\tconst { groupMapsTo } = options.data\n\n\t\tconst groupedData = this.getGroupedData()\n\n\t\t// Prepare the data for the box plots\n\t\tconst boxplotData = []\n\t\tfor (const { name: group, data } of groupedData) {\n\t\t\tconst rangeIdentifier = this.services.cartesianScales.getRangeIdentifier()\n\t\t\tconst values = data.map((d: any) => d[rangeIdentifier]).sort(ascending)\n\n\t\t\tconst record = {\n\t\t\t\t[groupMapsTo]: group,\n\t\t\t\tcounts: values,\n\t\t\t\tquartiles: this.getBoxQuartiles(values),\n\t\t\t\toutliers: null as any,\n\t\t\t\twhiskers: null as any\n\t\t\t}\n\n\t\t\tconst q1 = record.quartiles.q_25\n\t\t\tconst q3 = record.quartiles.q_75\n\n\t\t\tconst iqr = (q3 - q1) * 1.5\n\t\t\tconst irq1 = q1 - iqr\n\t\t\tconst irq3 = q3 + iqr\n\n\t\t\tconst outliers = []\n\t\t\tconst normalValues = []\n\n\t\t\tfor (const value of values) {\n\t\t\t\tif (value < irq1) {\n\t\t\t\t\toutliers.push(value)\n\t\t\t\t} else if (value > irq3) {\n\t\t\t\t\toutliers.push(value)\n\t\t\t\t} else {\n\t\t\t\t\tnormalValues.push(value)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trecord.outliers = outliers\n\n\t\t\tconst minNormalValue = min(normalValues)\n\t\t\tconst maxNormalValue = max(normalValues)\n\t\t\trecord.whiskers = {\n\t\t\t\tmin: minNormalValue\n\t\t\t\t\t? minNormalValue\n\t\t\t\t\t: min([record.quartiles.q_25, record.quartiles.q_50, record.quartiles.q_75]),\n\t\t\t\tmax: maxNormalValue\n\t\t\t\t\t? maxNormalValue\n\t\t\t\t\t: max([record.quartiles.q_25, record.quartiles.q_50, record.quartiles.q_75])\n\t\t\t}\n\n\t\t\tboxplotData.push(record)\n\t\t}\n\n\t\treturn boxplotData\n\t}\n\n\tgetTabularDataArray() {\n\t\tconst options = this.getOptions()\n\t\tconst { groupMapsTo } = options.data\n\t\tconst boxplotData = this.getBoxplotData()\n\t\tconst { number: numberFormatter, code: localeCode } = getProperty(options, 'locale')\n\n\t\tconst headers = ['Group', 'Minimum', 'Q1', 'Median', 'Q3', 'Maximum', 'IQR', 'Outlier(s)']\n\t\tconst cells = [\n\t\t\t...boxplotData.map(datum => {\n\t\t\t\tlet outliers = getProperty(datum, 'outliers')\n\t\t\t\tif (outliers === null || outliers.length === 0) {\n\t\t\t\t\toutliers = ['&ndash;']\n\t\t\t\t}\n\t\t\t\treturn [\n\t\t\t\t\tdatum[groupMapsTo],\n\t\t\t\t\tgetProperty(datum, 'whiskers', 'min') !== null\n\t\t\t\t\t\t? numberFormatter(getProperty(datum, 'whiskers', 'min'), localeCode)\n\t\t\t\t\t\t: '&ndash;',\n\t\t\t\t\tgetProperty(datum, 'quartiles', 'q_25') !== null\n\t\t\t\t\t\t? numberFormatter(getProperty(datum, 'quartiles', 'q_25'), localeCode)\n\t\t\t\t\t\t: '&ndash;',\n\t\t\t\t\tgetProperty(datum, 'quartiles', 'q_50') !== null\n\t\t\t\t\t\t? numberFormatter(getProperty(datum, 'quartiles', 'q_50'), localeCode)\n\t\t\t\t\t\t: '&ndash;',\n\t\t\t\t\tgetProperty(datum, 'quartiles', 'q_75') !== null\n\t\t\t\t\t\t? numberFormatter(getProperty(datum, 'quartiles', 'q_75'), localeCode)\n\t\t\t\t\t\t: '&ndash;',\n\t\t\t\t\tgetProperty(datum, 'whiskers', 'max') !== null\n\t\t\t\t\t\t? numberFormatter(getProperty(datum, 'whiskers', 'max'), localeCode)\n\t\t\t\t\t\t: '&ndash;',\n\t\t\t\t\tgetProperty(datum, 'quartiles', 'q_75') !== null &&\n\t\t\t\t\tgetProperty(datum, 'quartiles', 'q_25') !== null\n\t\t\t\t\t\t? (numberFormatter(\n\t\t\t\t\t\t\t\tgetProperty(datum, 'quartiles', 'q_75') - getProperty(datum, 'quartiles', 'q_25')\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tlocaleCode)\n\t\t\t\t\t\t: '&ndash;',\n\t\t\t\t\toutliers.map((d: any) => numberFormatter(d, localeCode)).join(',')\n\t\t\t\t]\n\t\t\t})\n\t\t]\n\n\t\treturn super.formatTable({ headers, cells })\n\t}\n\n\tprotected setColorClassNames() {\n\t\t// monochrome\n\t\tconst numberOfColors = 1\n\n\t\tconst colorPairingOptions = getProperty(this.getOptions(), 'color', 'pairing')\n\t\tlet pairingOption = getProperty(colorPairingOptions, 'option')\n\t\tconst colorPairingCounts = colorConfigs.pairingOptions\n\n\t\t// Use default palette if user choice is not in range\n\t\tpairingOption =\n\t\t\tpairingOption <= colorPairingCounts[`${numberOfColors}-color`] ? pairingOption : 1\n\n\t\t// Create color classes for graph, tooltip and stroke use\n\t\tconst colorPairing = this.allDataGroups.map(() => `${numberOfColors}-${pairingOption}-1`)\n\n\t\t// Create default color classnames\n\t\tthis.colorClassNames = scaleOrdinal().range(colorPairing).domain(this.allDataGroups)\n\t}\n}\n","import { getProperty } from '@/tools'\nimport { ChartModelCartesian } from './cartesian-charts'\n\n/**\n * Bullet chart model layer\n */\nexport class BulletChartModel extends ChartModelCartesian {\n\tconstructor(services: any) {\n\t\tsuper(services)\n\t}\n\n\t/**\n\t * Determines the index of the performance area titles to use\n\t * @param datum\n\t * @returns number\n\t */\n\tgetMatchingRangeIndexForDatapoint(datum: any) {\n\t\tlet matchingRangeIndex\n\t\tfor (let i = datum.ranges.length - 1; i > 0; i--) {\n\t\t\tconst range = datum.ranges[i]\n\t\t\tif (datum.value >= range) {\n\t\t\t\tmatchingRangeIndex = i\n\n\t\t\t\treturn matchingRangeIndex\n\t\t\t}\n\t\t}\n\n\t\treturn 0\n\t}\n\n\tgetTabularDataArray() {\n\t\tconst displayData = this.getDisplayData()\n\t\tconst options = this.getOptions()\n\t\tconst { groupMapsTo } = options.data\n\t\tconst rangeIdentifier = this.services.cartesianScales.getRangeIdentifier()\n\t\tconst { number: numberFormatter, code: localeCode } = getProperty(options, 'locale')\n\n\t\tconst performanceAreaTitles = getProperty(options, 'bullet', 'performanceAreaTitles')\n\t\tconst headers = ['Title', 'Group', 'Value', 'Target', 'Percentage', 'Performance']\n\t\tconst cells = [\n\t\t\t...displayData.map((datum: any) => [\n\t\t\t\tdatum['title'],\n\t\t\t\tdatum[groupMapsTo],\n\t\t\t\tdatum['value'] === null ? '&ndash;' : numberFormatter(datum['value'], localeCode),\n\t\t\t\tgetProperty(datum, 'marker') === null\n\t\t\t\t\t? '&ndash;'\n\t\t\t\t\t: numberFormatter(datum['marker'], localeCode),\n\t\t\t\tgetProperty(datum, 'marker') === null\n\t\t\t\t\t? '&ndash;'\n\t\t\t\t\t: `${numberFormatter(Math.floor((datum[rangeIdentifier] / datum.marker) * 100), localeCode)}%`,\n\t\t\t\tperformanceAreaTitles[this.getMatchingRangeIndexForDatapoint(datum)]\n\t\t\t])\n\t\t]\n\n\t\treturn super.formatTable({ headers, cells })\n\t}\n}\n","// External Imports\nimport { isEmpty } from 'lodash-es'\n\n// Internal Imports\nimport { ChartModel } from './model'\nimport { getProperty } from '@/tools'\nimport { getColorScale } from '@/services/color-scale-utils'\n\n/**\n * Base thematic maps chart model layer\n */\nexport class ChoroplethModel extends ChartModel {\n\tprivate _colorScale: any = undefined\n\n\t// Holds a mapping of geometry objects to data objects\n\t// Allows us to access data faster\n\tprivate _matrix = {}\n\n\tconstructor(services: any) {\n\t\tsuper(services)\n\t}\n\n\t/**\n\t * @override\n\t * @param value\n\t * @returns string\n\t */\n\tgetFillColor(value: number) {\n\t\treturn this._colorScale(value)\n\t}\n\n\t/**\n\t * Helper function that will generate a dictionary\n\t */\n\tgetCombinedData() {\n\t\tif (isEmpty(this._matrix)) {\n\t\t\tconst options = this.getOptions()\n\t\t\tconst data = this.getDisplayData()\n\t\t\tif (!isEmpty(data) && !isEmpty(options.geoData.objects.countries)) {\n\t\t\t\t/**\n\t\t\t\t * @todo\n\t\t\t\t * We can either use name or id by default to generate this dictionary\n\t\t\t\t * Curently id & name are standard in geoJSON. Unfortunately, topojson does not have any standard\n\t\t\t\t * so feature objects can have any key. We suggest that they include name or id at the very least\n\t\t\t\t *\n\t\t\t\t * May need to provide users with the option to pass in keys to create dictionary with\n\t\t\t\t */\n\t\t\t\toptions.geoData.objects.countries.geometries.forEach(country => {\n\t\t\t\t\tthis._matrix[country.properties.NAME] = country\n\t\t\t\t})\n\n\t\t\t\tdata.forEach(value => {\n\t\t\t\t\tif (this._matrix[value.name]) {\n\t\t\t\t\t\tthis._matrix[value.name]['value'] = value.value || null\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.warn(`Data point ${value} is missing geographical data.`)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\treturn this._matrix\n\t}\n\n\t/**\n\t * Generate tabular data from display data\n\t * @returns Array<Object>\n\t */\n\tgetTabularDataArray() {\n\t\tconst displayData = this.getDisplayData()\n\t\tconst { number: numberFormatter, code: localeCode } = getProperty(this.getOptions(), 'locale')\n\n\t\tconst headers = ['Country ID', 'Country Name', 'Value']\n\t\tconst cells = [\n\t\t\t...displayData.map(datum => [\n\t\t\t\tdatum['id'] === null ? '&ndash;' : datum['id'],\n\t\t\t\tdatum['name'],\n\t\t\t\tdatum['value'] === null ? '&ndash;' : numberFormatter(datum['value'], localeCode)\n\t\t\t])\n\t\t]\n\n\t\treturn super.formatTable({ headers, cells })\n\t}\n\n\t// Uses quantize scale to return class names\n\tgetColorClassName(configs: { value?: number; originalClassName?: string }) {\n\t\treturn `${configs.originalClassName} ${this._colorScale(configs.value as number)}`\n\t}\n\n\tprotected setColorClassNames() {\n\t\tconst colorOptions = getProperty(this.getOptions(), 'color')\n\t\tthis._colorScale = getColorScale(this.getDisplayData(), colorOptions)\n\t}\n}\n","import { merge } from 'lodash-es'\nimport { getProperty, updateLegendAdditionalItems } from '@/tools'\nimport { ChartModel } from './model'\nimport { LegendItemType } from '@/interfaces/enums'\n\n/** The charting model layer which includes mainly the chart data and options,\n * as well as some misc. information to be shared among components */\nexport class CirclePackChartModel extends ChartModel {\n\tparentNode = false\n\n\tconstructor(services: any) {\n\t\tsuper(services)\n\t\tthis.set({ depth: 2 }, { skipUpdate: true })\n\t}\n\n\tsetData(newData: any) {\n\t\tsuper.setData(newData)\n\t\tthis.setDataGroups()\n\t\tif (newData.length === 1) {\n\t\t\tthis.parentNode = true\n\t\t}\n\t\tthis.setZoom()\n\t}\n\n\tsetOptions(newOptions: any) {\n\t\tconst options = this.getOptions()\n\t\tconst zoomOptions = merge({}, newOptions, this.getZoomOptions(newOptions))\n\t\tupdateLegendAdditionalItems(options, zoomOptions)\n\n\t\tconst depth = this.getHierarchyLevel()\n\t\tconst userProvidedDepth = getProperty(options, 'circlePack', 'hierarchyLevel')\n\n\t\tthis.set({\n\t\t\toptions: merge(options, zoomOptions),\n\t\t\tdepth: userProvidedDepth && userProvidedDepth < 4 ? userProvidedDepth : depth\n\t\t})\n\t}\n\n\tgetZoomOptions(options?: any) {\n\t\tif (!this.getDisplayData()) {\n\t\t\treturn {}\n\t\t}\n\t\t// uses the user provided options and data to determine if there is zoom in this CP chart\n\t\tconst displayData = this.getDisplayData()\n\t\tconst zoomOptions = options ? options : this.getOptions()\n\t\tconst data =\n\t\t\tdisplayData.length === 1 && getProperty(displayData, 0, 'children')\n\t\t\t\t? getProperty(displayData, 0, 'children')\n\t\t\t\t: displayData\n\n\t\tlet depth = this.getHierarchyLevel()\n\t\t// check the data depth\n\t\tdata.some((datum: any) => {\n\t\t\tif (datum.children) {\n\t\t\t\tif (datum.children.some((item: any) => item.children)) {\n\t\t\t\t\tdepth = 3\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\tif (getProperty(zoomOptions, 'canvasZoom', 'enabled') === true && depth > 2) {\n\t\t\treturn {\n\t\t\t\tlegend: {\n\t\t\t\t\tadditionalItems: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttype: LegendItemType.ZOOM,\n\t\t\t\t\t\t\tname: 'Click to zoom'\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null\n\t}\n\n\tsetZoom(options?: any) {\n\t\tthis.setOptions(this.getZoomOptions(options))\n\t}\n\n\t// update the hierarchy level\n\tupdateHierarchyLevel(depth: number) {\n\t\tthis.set({ depth: depth })\n\t}\n\n\tgetHierarchyLevel() {\n\t\treturn this.get('depth')\n\t}\n\n\thasParentNode() {\n\t\treturn this.parentNode\n\t}\n\n\t// set the datagroup name on the items that are it's children\n\tsetDataGroups() {\n\t\tconst data = this.getData()\n\t\tconst options = this.getOptions()\n\t\tconst { groupMapsTo } = options.data\n\n\t\tconst newData = data.map((depthOne: any) => {\n\t\t\tconst groupName = depthOne[groupMapsTo]\n\t\t\treturn this.setChildrenDataGroup(depthOne, groupName)\n\t\t})\n\n\t\tthis.set(\n\t\t\t{\n\t\t\t\tdata: newData\n\t\t\t},\n\t\t\t{ skipUpdate: true }\n\t\t)\n\t}\n\n\t// sets name recursively down the node tree\n\tprotected setChildrenDataGroup(node: any, name: any) {\n\t\tif (node.children) {\n\t\t\treturn {\n\t\t\t\t...node,\n\t\t\t\tdataGroupName: name,\n\t\t\t\tchildren: node.children.map((child: any) => {\n\t\t\t\t\treturn this.setChildrenDataGroup(child, name)\n\t\t\t\t})\n\t\t\t}\n\t\t} else {\n\t\t\treturn { ...node, dataGroupName: name }\n\t\t}\n\t}\n\n\tgetTabularDataArray() {\n\t\tconst displayData = this.getDisplayData()\n\t\tconst { number: numberFormatter, code: localeCode } = getProperty(this.getOptions(), 'locale')\n\n\t\tconst headers = ['Child', 'Parent', 'Value']\n\t\tconst cells = []\n\n\t\tdisplayData.forEach((datum: any) => {\n\t\t\tlet value = datum.value ? datum.value : 0\n\t\t\tif (datum.children) {\n\t\t\t\t// Call recursive function\n\t\t\t\tvalue += this.getChildrenDatums(datum.children, datum.name, cells, 0)\n\t\t\t}\n\t\t\tcells.push(['&ndash;', datum.name, numberFormatter(value, localeCode)])\n\t\t})\n\n\t\treturn super.formatTable({ headers, cells })\n\t}\n\n\t/**\n\t * Recursively determine the relationship between all the nested elements in the child\n\t * @param children: Object\n\t * @param parent: String\n\t * @param result: Array<Object>\n\t * @param totalSum: number\n\t * @returns: number\n\t */\n\tprivate getChildrenDatums(children: any, parent: any, result: string[][] = [], totalSum = 0) {\n\t\tconst grandParent = parent\n\t\tconst { number: numberFormatter, code: localeCode } = getProperty(this.getOptions(), 'locale')\n\n\t\tchildren.forEach((child: any) => {\n\t\t\tconst parentWithinIteration = child.name\n\t\t\tlet sum = 0\n\n\t\t\tif (child.children) {\n\t\t\t\tif (child.children.length > 0) {\n\t\t\t\t\tif (typeof child.value === 'number') {\n\t\t\t\t\t\ttotalSum += child.value\n\t\t\t\t\t}\n\n\t\t\t\t\tsum += this.getChildrenDatums(child.children, parentWithinIteration, result, sum)\n\t\t\t\t\tresult.push([parentWithinIteration, grandParent, numberFormatter(sum, localeCode)])\n\t\t\t\t\ttotalSum += sum\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlet value = 0\n\t\t\t\tif (typeof child.value === 'number') {\n\t\t\t\t\tvalue = child.value\n\t\t\t\t\ttotalSum += child.value\n\t\t\t\t}\n\t\t\t\tresult.push([child.name, grandParent, numberFormatter(value, localeCode)])\n\t\t\t}\n\t\t})\n\n\t\treturn totalSum\n\t}\n}\n","import { ChartModel } from './model'\nimport { getProperty } from '@/tools'\n\n/** The charting model layer which includes mainly the chart data and options,\n * as well as some misc. information to be shared among components */\nexport class PieChartModel extends ChartModel {\n\tconstructor(services: any) {\n\t\tsuper(services)\n\t}\n\n\tgetTabularData(data: any) {\n\t\tconst tabularData = super.getTabularData(data)\n\n\t\t// if the data was changed to tabular format\n\t\t// update the group to the key so the slices render with the correct tooltips and colors\n\t\tif (data !== tabularData) {\n\t\t\t// If a label was set for the overall dataset, reassign it to key value\n\t\t\ttabularData.forEach((d: any) => {\n\t\t\t\tif (d.key && d.key !== d.group) {\n\t\t\t\t\td.group = d.key\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\treturn tabularData\n\t}\n\n\tgetTabularDataArray() {\n\t\tconst displayData = this.getDisplayData()\n\t\tconst options = this.getOptions()\n\t\tconst { groupMapsTo } = options.data\n\t\tconst { valueMapsTo } = options.pie\n\t\tconst { number: numberFormatter, code: localeCode } = getProperty(options, 'locale')\n\n\t\tconst headers = ['Group', 'Value']\n\t\tconst cells = [\n\t\t\t...displayData.map((datum: any) => [\n\t\t\t\tdatum[groupMapsTo],\n\t\t\t\tdatum[valueMapsTo] === null ? '&ndash;' : numberFormatter(datum[valueMapsTo], localeCode)\n\t\t\t])\n\t\t]\n\n\t\treturn super.formatTable({ headers, cells })\n\t}\n\n\tsanitize(data: any) {\n\t\tconst tabularData = this.getTabularData(data)\n\n\t\t// Sort data based on value\n\t\treturn tabularData.sort((a, b) => b.value - a.value)\n\t}\n}\n","import { ChartModel } from './model'\nimport { getProperty } from '@/tools'\n\n/**\n * The gauge chart model layer\n */\nexport class GaugeChartModel extends ChartModel {\n\tconstructor(services: any) {\n\t\tsuper(services)\n\t}\n\n\tgetDataGroups() {\n\t\treturn super.getDataGroups().filter((item: any) => item.name !== 'delta')\n\t}\n\n\tgetTabularDataArray() {\n\t\tconst displayData = this.getDisplayData()\n\t\tconst options = this.getOptions()\n\t\tconst { groupMapsTo } = options.data\n\t\tconst { number: numberFormatter, code: localeCode } = getProperty(this.getOptions(), 'locale')\n\n\t\tconst headers = ['Group', 'Value']\n\t\tconst cells = [\n\t\t\t...displayData.map((datum: any) => [\n\t\t\t\tdatum[groupMapsTo],\n\t\t\t\tdatum['value'] === null ? '&ndash;' : numberFormatter(datum['value'], localeCode)\n\t\t\t])\n\t\t]\n\n\t\treturn super.formatTable({ headers, cells })\n\t}\n}\n","import { extent, scaleQuantize, scaleLinear } from 'd3'\nimport { cloneDeep, isEmpty } from 'lodash-es'\nimport { getProperty } from '@/tools'\nimport { AxisFlavor, ScaleTypes } from '@/interfaces/enums'\nimport { getColorScale } from '@/services'\nimport { ChartModelCartesian } from './cartesian-charts'\n\n/** The gauge chart model layer */\nexport class HeatmapModel extends ChartModelCartesian {\n\taxisFlavor = AxisFlavor.HOVERABLE\n\tprivate _colorScale: any = undefined\n\n\t// List of unique ranges and domains\n\tprivate _domains: any[] = []\n\tprivate _ranges: any[] = []\n\n\tprivate _matrix: any = {}\n\n\tconstructor(services: any) {\n\t\tsuper(services)\n\n\t\t// Check which scale types are being used\n\t\tconst axis = getProperty(this.getOptions(), 'axes')\n\n\t\t// Need to check options since scale service hasn't been instantiated\n\t\tif (\n\t\t\t(!!getProperty(axis, 'left', 'scaleType') &&\n\t\t\t\tgetProperty(axis, 'left', 'scaleType') !== ScaleTypes.LABELS) ||\n\t\t\t(!!getProperty(axis, 'right', 'scaleType') &&\n\t\t\t\tgetProperty(axis, 'right', 'scaleType') !== ScaleTypes.LABELS) ||\n\t\t\t(!!getProperty(axis, 'top', 'scaleType') &&\n\t\t\t\tgetProperty(axis, 'top', 'scaleType') !== ScaleTypes.LABELS) ||\n\t\t\t(!!getProperty(axis, 'bottom', 'scaleType') &&\n\t\t\t\tgetProperty(axis, 'bottom', 'scaleType') !== ScaleTypes.LABELS)\n\t\t) {\n\t\t\tthrow Error('Heatmap only supports label scaletypes.')\n\t\t}\n\t}\n\n\t/**\n\t * Get min and maximum value of the display data\n\t * @returns Array consisting of smallest and largest values in  data\n\t */\n\tgetValueDomain() {\n\t\tconst limits = extent(this.getDisplayData(), (d: any) => d.value)\n\t\tconst domain = scaleLinear()\n\t\t\t.domain(limits as [number, number])\n\t\t\t.nice()\n\t\t\t.domain()\n\n\t\t// Ensuring limits start at 0 to make scale look more `nicer`\n\t\tif (domain[0] > 0) {\n\t\t\tdomain[0] = 0\n\t\t} else if (domain[0] === 0 && domain[1] === 0) {\n\t\t\t// Range cannot be between 0 and 0 (itself)\n\t\t\treturn [0, 1]\n\t\t}\n\n\t\t// Ensure the median of the range is 0 if domain extends into both negative & positive\n\t\tif (domain[0] < 0 && domain[1] > 0) {\n\t\t\tif (Math.abs(domain[0]) > domain[1]) {\n\t\t\t\tdomain[1] = Math.abs(domain[0])\n\t\t\t} else {\n\t\t\t\tdomain[0] = -domain[1]\n\t\t\t}\n\t\t}\n\n\t\treturn domain\n\t}\n\n\t/**\n\t * @override\n\t * @param value\n\t * @returns string\n\t */\n\tgetFillColor(value: number) {\n\t\treturn this._colorScale(value)\n\t}\n\n\t/**\n\t * Generate a list of all unique domains\n\t * @returns String[]\n\t */\n\tgetUniqueDomain(): string[] {\n\t\tif (isEmpty(this._domains)) {\n\t\t\tconst displayData = this.getDisplayData()\n\t\t\tconst { cartesianScales } = this.services\n\n\t\t\tconst domainIdentifier = cartesianScales.getDomainIdentifier()\n\t\t\tconst mainXAxisPosition = cartesianScales.getMainXAxisPosition()\n\t\t\tconst customDomain = cartesianScales.getCustomDomainValuesByposition(mainXAxisPosition)\n\n\t\t\t// Use user defined domain if specified\n\t\t\tif (customDomain) {\n\t\t\t\treturn customDomain\n\t\t\t}\n\n\t\t\t// Get unique axis values & create a matrix\n\t\t\tthis._domains = Array.from(\n\t\t\t\tnew Set(\n\t\t\t\t\tdisplayData.map((d: any) => {\n\t\t\t\t\t\treturn d[domainIdentifier]\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\n\t\treturn this._domains\n\t}\n\n\t/**\n\t * Generates a list of all unique ranges\n\t * @returns String[]\n\t */\n\tgetUniqueRanges(): string[] {\n\t\tif (isEmpty(this._ranges)) {\n\t\t\tconst displayData = this.getDisplayData()\n\t\t\tconst { cartesianScales } = this.services\n\n\t\t\tconst rangeIdentifier = cartesianScales.getRangeIdentifier()\n\t\t\tconst mainYAxisPosition = cartesianScales.getMainYAxisPosition()\n\t\t\tconst customDomain = cartesianScales.getCustomDomainValuesByposition(mainYAxisPosition)\n\n\t\t\t// Use user defined domain if specified\n\t\t\tif (customDomain) {\n\t\t\t\treturn customDomain\n\t\t\t}\n\n\t\t\t// Get unique axis values & create a matrix\n\t\t\tthis._ranges = Array.from(\n\t\t\t\tnew Set(\n\t\t\t\t\tdisplayData.map((d: any) => {\n\t\t\t\t\t\treturn d[rangeIdentifier]\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\n\t\treturn this._ranges\n\t}\n\n\t/**\n\t * Generates a matrix (If doesn't exist) and returns it\n\t * @returns Object\n\t */\n\tgetMatrix() {\n\t\tif (isEmpty(this._matrix)) {\n\t\t\tconst uniqueDomain = this.getUniqueDomain()\n\t\t\tconst uniqueRange = this.getUniqueRanges()\n\n\t\t\tconst domainIdentifier = this.services.cartesianScales.getDomainIdentifier()\n\t\t\tconst rangeIdentifier = this.services.cartesianScales.getRangeIdentifier()\n\n\t\t\t// Create a column\n\t\t\tconst range: any = {}\n\t\t\tuniqueRange.forEach((ran: any) => {\n\t\t\t\t// Initialize matrix to empty state\n\t\t\t\trange[ran] = {\n\t\t\t\t\tvalue: null,\n\t\t\t\t\tindex: -1\n\t\t\t\t}\n\t\t\t})\n\n\t\t\t// Complete the matrix by cloning the column to all domains\n\t\t\tuniqueDomain.forEach((dom: any) => {\n\t\t\t\tthis._matrix[dom] = cloneDeep(range)\n\t\t\t})\n\n\t\t\t// Fill in user passed data\n\t\t\tthis.getDisplayData().forEach((d: any, i: number) => {\n\t\t\t\tthis._matrix[d[domainIdentifier]][d[rangeIdentifier]] = {\n\t\t\t\t\tvalue: d['value'],\n\t\t\t\t\tindex: i\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\treturn this._matrix\n\t}\n\n\t/**\n\t *\n\t * @param newData The new raw data to be set\n\t */\n\tsetData(newData: any) {\n\t\tconst sanitizedData = this.sanitize(cloneDeep(newData))\n\t\tconst dataGroups = this.generateDataGroups(sanitizedData)\n\n\t\tthis.set({\n\t\t\tdata: sanitizedData,\n\t\t\tdataGroups\n\t\t})\n\n\t\t// Set attributes to empty\n\t\tthis._domains = []\n\t\tthis._ranges = []\n\t\tthis._matrix = {}\n\n\t\treturn sanitizedData\n\t}\n\n\t/**\n\t * Converts Object matrix into a single array\n\t * @returns object[]\n\t */\n\tgetMatrixAsArray(): object[] {\n\t\tif (isEmpty(this._matrix)) {\n\t\t\tthis.getMatrix()\n\t\t}\n\n\t\tconst uniqueDomain = this.getUniqueDomain()\n\t\tconst uniqueRange = this.getUniqueRanges()\n\n\t\tconst domainIdentifier = this.services.cartesianScales.getDomainIdentifier()\n\t\tconst rangeIdentifier = this.services.cartesianScales.getRangeIdentifier()\n\n\t\tconst arr: any[] = []\n\t\tuniqueDomain.forEach(domain => {\n\t\t\tuniqueRange.forEach(range => {\n\t\t\t\tconst element: any = {\n\t\t\t\t\tvalue: this._matrix[domain][range].value,\n\t\t\t\t\tindex: this._matrix[domain][range].index\n\t\t\t\t}\n\t\t\t\telement[domainIdentifier] = domain\n\t\t\t\telement[rangeIdentifier] = range\n\t\t\t\tarr.push(element)\n\t\t\t})\n\t\t})\n\n\t\treturn arr\n\t}\n\n\t/**\n\t * Generate tabular data from display data\n\t * @returns Array<Object>\n\t */\n\tgetTabularDataArray() {\n\t\tconst displayData = this.getDisplayData()\n\t\tconst { primaryDomain, primaryRange } = this.assignRangeAndDomains()\n\t\tconst { number: numberFormatter, code: localeCode } = getProperty(this.getOptions(), 'locale')\n\t\tlet domainValueFormatter: any\n\n\t\tconst headers = [primaryDomain.label, primaryRange.label, 'Value']\n\t\tconst cells = [\n\t\t\t...displayData.map((datum: any) => [\n\t\t\t\tdatum[primaryDomain.identifier] === null\n\t\t\t\t\t? '&ndash;'\n\t\t\t\t\t: domainValueFormatter\n\t\t\t\t\t\t? domainValueFormatter(datum[primaryDomain.identifier])\n\t\t\t\t\t\t: datum[primaryDomain.identifier],\n\n\t\t\t\tdatum[primaryRange.identifier] === null ? '&ndash;' : datum[primaryRange.identifier],\n\t\t\t\tdatum['value'] === null ? '&ndash;' : numberFormatter(datum['value'], localeCode)\n\t\t\t])\n\t\t]\n\n\t\treturn super.formatTable({ headers, cells })\n\t}\n\n\t// Uses quantize scale to return class names\n\tgetColorClassName(configs: { value?: number; originalClassName?: string }) {\n\t\treturn `${configs.originalClassName} ${this._colorScale(configs.value as number)}`\n\t}\n\n\tprotected setColorClassNames() {\n\t\tconst options = this.getOptions()\n\n\t\tconst customColors = getProperty(options, 'color', 'gradient', 'colors')\n\t\tconst customColorsEnabled = !isEmpty(customColors)\n\n\t\tlet colorPairingOption = getProperty(options, 'color', 'pairing', 'option')\n\n\t\t// If domain consists of negative and positive values, use diverging palettes\n\t\tconst domain = this.getValueDomain()\n\t\tconst colorScheme = domain[0] < 0 && domain[1] > 0 ? 'diverge' : 'mono'\n\n\t\t// Use default color pairing options if not in defined range\n\t\tif (colorPairingOption < 1 && colorPairingOption > 4 && colorScheme === 'mono') {\n\t\t\tcolorPairingOption = 1\n\t\t} else if (colorPairingOption < 1 && colorPairingOption > 2 && colorScheme === 'diverge') {\n\t\t\tcolorPairingOption = 1\n\t\t}\n\n\t\t// Uses css classes for fill\n\t\tconst colorPairing = customColorsEnabled ? customColors : []\n\n\t\tif (!customColorsEnabled) {\n\t\t\t// Add class names to list and the amount based on the color scheme\n\t\t\t// Carbon charts has 11 colors for a single monochromatic palette & 17 for a divergent palette\n\t\t\tconst colorGroupingLength = colorScheme === 'diverge' ? 17 : 11\n\t\t\tfor (let i = 1; i < colorGroupingLength + 1; i++) {\n\t\t\t\tcolorPairing.push(`fill-${colorScheme}-${colorPairingOption}-${i}`)\n\t\t\t}\n\t\t}\n\n\t\t// Save scale type\n\t\tthis._colorScale = scaleQuantize()\n\t\t\t.domain(domain as [number, number])\n\t\t\t.range(colorPairing)\n\t\tconst colorOptions = getProperty(this.getOptions(), 'color')\n\t\tthis._colorScale = getColorScale(this.getDisplayData(), colorOptions)\n\t}\n}\n","// Internal Imports\nimport { ChartModelCartesian } from './cartesian-charts'\nimport { getProperty } from '@/tools'\nimport { get } from 'lodash-es'\n\n/**\n * this is intended for binned type of charts\n * */\nexport class ChartModelBinned extends ChartModelCartesian {\n\tgetTabularDataArray() {\n\t\tconst options = this.getOptions()\n\t\tconst { groupMapsTo } = options.data\n\t\tconst { number: numberFormatter, code: localeCode } = getProperty(this.getOptions(), 'locale')\n\t\tconst binnedStackedData = this.getBinnedStackedData()\n\n\t\tconst headers = [\n\t\t\tget(options, 'bins.rangeLabel') || 'Range',\n\t\t\t...binnedStackedData.map(datum => get(datum, `0.${groupMapsTo}`))\n\t\t]\n\t\tconst cells = [\n\t\t\t...get(binnedStackedData, 0).map((d, i) => [\n\t\t\t\t`${numberFormatter(Number(get(d, 'data.x0')), localeCode)} – ${numberFormatter(\n\t\t\t\t\tNumber(get(d, 'data.x1')),\n\t\t\t\t\tlocaleCode\n\t\t\t\t)}`,\n\t\t\t\t...binnedStackedData.map(datum =>\n\t\t\t\t\tnumberFormatter(get(datum[i], `data.${get(datum[i], groupMapsTo)}`), localeCode)\n\t\t\t\t)\n\t\t\t])\n\t\t]\n\n\t\treturn super.formatTable({ headers, cells })\n\t}\n}\n","import { getProperty } from '@/tools'\nimport { ChartModel } from './model'\nimport { ChartTabularData } from '@/interfaces/model'\n\n/** The meter chart model layer which extends some of the data setting options.\n * Meter only uses 1 dataset\n *  */\n\nexport class MeterChartModel extends ChartModel {\n\tconstructor(services: any) {\n\t\tsuper(services)\n\t}\n\n\tgetMaximumDomain(data: any) {\n\t\tconst max = data.reduce((accumulator: number, datum: any) => accumulator + datum.value, 0)\n\t\treturn max\n\t}\n\n\t/**\n\t * Use a provided color for the bar or default to carbon color if no status provided.\n\t * Defaults to carbon color otherwise.\n\t * @param group dataset group label\n\t */\n\tgetFillColor(group: string) {\n\t\tconst options = this.getOptions()\n\t\tconst userProvidedScale = getProperty(options, 'color', 'scale')\n\t\tconst status = this.getStatus()\n\t\t// user provided a fill color or there isn't a status we can use the colorScale\n\t\tif (userProvidedScale || !status) {\n\t\t\treturn super.getFillColor(group)\n\t\t} else {\n\t\t\treturn null\n\t\t}\n\t}\n\n\t/**\n\t * Get the associated status for the data by checking the ranges\n\t */\n\tgetStatus() {\n\t\tconst options = this.getOptions()\n\t\tconst dataValues = getProperty(this.getDisplayData())\n\n\t\tconst totalValue =\n\t\t\tdataValues?.reduce((previous: any, current: any) => {\n\t\t\t\treturn previous + current.value\n\t\t\t}, 0) ?? 0\n\n\t\t// use max value if the percentage is bigger than 100%\n\t\tconst boundedValue = getProperty(options, 'meter', 'proportional')\n\t\t\t? totalValue\n\t\t\t: totalValue > 100\n\t\t\t\t? 100\n\t\t\t\t: totalValue\n\n\t\t// user needs to supply ranges\n\t\tconst allRanges = getProperty(options, 'meter', 'status', 'ranges')\n\n\t\tif (allRanges) {\n\t\t\tconst result = allRanges.filter(\n\t\t\t\t(step: any) => step.range[0] <= boundedValue && boundedValue <= step.range[1]\n\t\t\t)\n\t\t\tif (result.length > 0) {\n\t\t\t\treturn result[0].status\n\t\t\t}\n\t\t}\n\n\t\treturn null\n\t}\n\n\tgetTabularDataArray() {\n\t\tconst displayData = this.getDisplayData()\n\t\tconst options = this.getOptions()\n\t\tconst { groupMapsTo } = options.data\n\t\tconst status = this.getStatus()\n\t\tconst proportional = getProperty(options, 'meter', 'proportional')\n\t\tconst { number: numberFormatter, code: localeCode } = getProperty(this.getOptions(), 'locale')\n\n\t\tlet headers = []\n\t\tlet cells: ChartTabularData = []\n\t\tlet domainMax: number\n\t\t// Display the appropriate columns and fields depending on the type of meter\n\t\tif (proportional === null) {\n\t\t\tdomainMax = 100\n\t\t\tconst datum = displayData[0]\n\t\t\theaders = ['Group', 'Value', ...(status ? ['Status'] : [])]\n\t\t\tcells = [\n\t\t\t\t[\n\t\t\t\t\tdatum[groupMapsTo],\n\t\t\t\t\tdatum['value'] === null ? '&ndash;' : numberFormatter(datum['value'], localeCode),\n\t\t\t\t\t...(status ? [status] : [])\n\t\t\t\t]\n\t\t\t]\n\t\t} else {\n\t\t\tconst total = getProperty(proportional, 'total')\n\t\t\tdomainMax = total ? total : this.getMaximumDomain(displayData)\n\t\t\theaders = ['Group', 'Value', 'Percentage of total']\n\t\t\tcells = [\n\t\t\t\t...displayData.map((datum: any) => {\n\t\t\t\t\tlet value\n\t\t\t\t\tdatum['value'] !== null && datum['value'] !== undefined\n\t\t\t\t\t\t? (value = Number(datum['value']))\n\t\t\t\t\t\t: (value = 0)\n\t\t\t\t\tlet percentValue = Number(((datum['value'] / domainMax) * 100).toFixed(2))\n\t\t\t\t\treturn [\n\t\t\t\t\t\tdatum[groupMapsTo],\n\t\t\t\t\t\tdatum['value'] === null ? '&ndash;' : numberFormatter(value, localeCode),\n\t\t\t\t\t\tnumberFormatter(percentValue, localeCode) + ' %'\n\t\t\t\t\t]\n\t\t\t\t})\n\t\t\t]\n\t\t}\n\n\t\treturn super.formatTable({ headers, cells })\n\t}\n}\n","import { getProperty } from '@/tools'\nimport { ChartModelCartesian } from './cartesian-charts'\n\n/** The charting model layer which includes mainly the chart data and options,\n * as well as some misc. information to be shared among components */\nexport class RadarChartModel extends ChartModelCartesian {\n\tconstructor(services: any) {\n\t\tsuper(services)\n\t}\n\n\tgetTabularDataArray() {\n\t\tconst options = this.getOptions()\n\t\tconst groupedData = this.getGroupedData()\n\t\tconst { angle, value } = getProperty(options, 'radar', 'axes')\n\t\tconst { number: numberFormatter, code: localeCode } = getProperty(options, 'locale')\n\n\t\tconst additionalHeaders = getProperty(groupedData, '0', 'data').map((d: any) => d[angle])\n\t\tconst headers = ['Group', ...additionalHeaders]\n\t\tconst cells = [\n\t\t\t...groupedData.map(datum => {\n\t\t\t\treturn [\n\t\t\t\t\tdatum['name'],\n\t\t\t\t\t...additionalHeaders.map((_: any, i: number) =>\n\t\t\t\t\t\tgetProperty(datum, 'data', i, value) !== null\n\t\t\t\t\t\t\t? numberFormatter(getProperty(datum, 'data', i, value), localeCode)\n\t\t\t\t\t\t\t: '&ndash;'\n\t\t\t\t\t)\n\t\t\t\t]\n\t\t\t})\n\t\t]\n\n\t\treturn super.formatTable({ headers, cells })\n\t}\n}\n","import { ChartModel } from './model'\n\n/**\n * The tree chart model layer\n */\nexport class TreeChartModel extends ChartModel {\n\tconstructor(services: any) {\n\t\tsuper(services)\n\t}\n\n\tgetTabularDataArray() {\n\t\tconst displayData = this.getDisplayData()\n\n\t\tconst headers = ['Child', 'Parent']\n\t\tconst cells = []\n\t\tdisplayData.forEach((datum: any) => {\n\t\t\t// Call recurisve function\n\t\t\tthis.getChildrenDatums(datum, cells)\n\t\t\tcells.push([datum.name, '&ndash;'])\n\t\t})\n\n\t\treturn super.formatTable({ headers, cells })\n\t}\n\n\t/**\n\t * Determine the child parent relationship in nested data\n\t * @param datum: Object\n\t * @param result: Array<Object>\n\t */\n\tprivate getChildrenDatums(datum: any, result: any[] = []) {\n\t\t// Check to see if datum has children before iterating through it\n\t\tif (datum.children) {\n\t\t\tif (datum.children.length > 0) {\n\t\t\t\tdatum.children.forEach((child: any) => {\n\t\t\t\t\tthis.getChildrenDatums(child, result)\n\t\t\t\t\tresult.push([child.name, datum.name])\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n}\n","import { getProperty } from '@/tools'\nimport { ChartModel } from './model'\n\n/**\n * The treemap chart model layer\n */\nexport class TreemapChartModel extends ChartModel {\n\tconstructor(services: any) {\n\t\tsuper(services)\n\t}\n\n\tgetTabularDataArray() {\n\t\tconst displayData = this.getDisplayData()\n\t\tconst { number: numberFormatter, code: localeCode } = getProperty(this.getOptions(), 'locale')\n\n\t\tconst headers = ['Child', 'Group', 'Value']\n\t\tconst cells = []\n\t\tdisplayData.forEach((datum: any) => {\n\t\t\tif (Array.isArray(datum.children)) {\n\t\t\t\tdatum.children.forEach((child: any) => {\n\t\t\t\t\tcells.push([\n\t\t\t\t\t\tchild.name,\n\t\t\t\t\t\tdatum.name,\n\t\t\t\t\t\tchild.value === null ? '&ndash;' : numberFormatter(child.value, localeCode)\n\t\t\t\t\t])\n\t\t\t\t})\n\t\t\t} else if (getProperty(datum.name) !== null && getProperty(datum.value)) {\n\t\t\t\tcells.push(['–', datum.name, numberFormatter(datum.value, localeCode)])\n\t\t\t}\n\t\t})\n\n\t\treturn super.formatTable({ headers, cells })\n\t}\n}\n","import { getProperty } from '@/tools'\nimport { ChartModel } from './model'\n\n/** The charting model layer which includes mainly the chart data and options,\n * as well as some misc. information to be shared among components */\nexport class WordCloudModel extends ChartModel {\n\tconstructor(services: any) {\n\t\tsuper(services)\n\t}\n\n\tgetTabularDataArray() {\n\t\tconst displayData = this.getDisplayData()\n\t\tconst options = this.getOptions()\n\t\tconst { fontSizeMapsTo, wordMapsTo } = options.wordCloud\n\t\tconst { groupMapsTo } = options.data\n\t\tconst { code: localeCode, number: numberFormatter } = getProperty(options, 'locale')\n\n\t\tconst headers = [options.tooltip.wordLabel, 'Group', options.tooltip.valueLabel]\n\t\tconst cells = [\n\t\t\t...displayData.map((datum: any) => [\n\t\t\t\tdatum[wordMapsTo],\n\t\t\t\tdatum[groupMapsTo],\n\t\t\t\tnumberFormatter(datum[fontSizeMapsTo], localeCode)\n\t\t\t])\n\t\t]\n\n\t\treturn super.formatTable({ headers, cells })\n\t}\n}\n"],"names":["arrayAggregator","array","setter","iteratee","accumulator","index","length","value","baseAggregator","collection","baseEach","key","createAggregator","initializer","func","isArray","baseIteratee","fromPairs","pairs","result","pair","objectProto","hasOwnProperty","groupBy","baseAssignValue","_sanitizeCsvCell","cellContent","_trimmedCell","ChartModel","services","headers","cells","options","localeCode","dateFormatter","numberFormatter","getProperty","tableHeadingFormatter","tableCellFormatter","cartesianScales","domainScaleType","domainValueFormatter","ScaleTypes","d","data","i","val","groups","allData","dataGroups","groupMapsTo","axesOptions","item","axis","mapsTo","scaleType","datum","start","end","group","ACTIVE","legendConfigs","dataGroup","newData","sanitizedData","cloneDeep","bin","mainXPos","domainIdentifier","axisOptions","axisBins","histogramConfigs","areBinsDefined","bins","d3Bin","binsWidth","binsDomain","groupsKeys","histogramData","aggregateDataByGroup","dataGroupNames","dataValuesGroupedByKeys","stack","series","element","displayData","groupedData","groupName","stackKeys","uniq","formatDateTillMilliSeconds","axisPosition","a","b","dateA","dateB","binStart","binEnd","correspondingValues","correspondingBin","dataGroupName","binItem","correspondingDatum","rangeIdentifier","percentage","divergent","maxByKey","name","denominator","stackOffsetDiverging","newState","configs","newConfig","property","newOptions","updateLegendAdditionalItems","merge","animate","Events","changedLabel","DISABLED","hasDeactivatedItems","activeItems","_","indexToChange","updatedActiveItems","activeItem","defaultFilled","defaultFillColor","defaultStrokeColor","userProvidedScale","colorPairingTag","className","type","tabularData","datasets","labels","dataset","datasetLabel","correspondingLabel","updatedDatum","csvString","row","column","part","fileName","customFilename","uniqueDataGroups","getStatus","colorPairingOptions","numberOfVariants","pairingOption","colorPairingCounts","colorConfigs","numberOfColors","colorPairing","scaleOrdinal","ChartModelCartesian","AxisFlavor","isDualAxes","scales","scale","position","primaryDomain","primaryRange","secondaryDomain","secondaryRange","AxisPositions","definedZoomBarData","newZoomBarData","zoomBarNormalizedValues","allDates","date","sum","keysToCheck","axisPositionKey","axisMapsTo","AlluvialChartModel","BoxplotChartModel","quantile","boxplotData","values","ascending","record","q1","q3","iqr","irq1","irq3","outliers","normalValues","minNormalValue","min","maxNormalValue","max","BulletChartModel","matchingRangeIndex","range","performanceAreaTitles","ChoroplethModel","isEmpty","country","colorOptions","getColorScale","CirclePackChartModel","zoomOptions","depth","userProvidedDepth","LegendItemType","depthOne","node","child","children","parent","totalSum","grandParent","parentWithinIteration","PieChartModel","valueMapsTo","GaugeChartModel","HeatmapModel","limits","extent","domain","scaleLinear","mainXAxisPosition","customDomain","mainYAxisPosition","uniqueDomain","uniqueRange","ran","dom","arr","customColors","customColorsEnabled","colorPairingOption","colorScheme","colorGroupingLength","scaleQuantize","ChartModelBinned","binnedStackedData","get","MeterChartModel","status","dataValues","totalValue","previous","current","boundedValue","allRanges","step","proportional","domainMax","total","percentValue","RadarChartModel","angle","additionalHeaders","TreeChartModel","TreemapChartModel","WordCloudModel","fontSizeMapsTo","wordMapsTo"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4]}