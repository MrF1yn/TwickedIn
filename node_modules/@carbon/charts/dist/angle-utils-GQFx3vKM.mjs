import { select as d } from "d3";
import { j as fe, l as O, r as de, m as T, n as _ } from "./color-scale-utils-CiW9fERh.mjs";
import { _ as P, T as E, o as b } from "./enums-DwsxZqjR.mjs";
var me = /\s/;
function ge(t) {
  for (var e = t.length; e-- && me.test(t.charAt(e)); )
    ;
  return e;
}
var pe = /^\s+/;
function ye(t) {
  return t && t.slice(0, ge(t) + 1).replace(pe, "");
}
var q = NaN, we = /^[-+]0x[0-9a-f]+$/i, Se = /^0b[01]+$/i, Ee = /^0o[0-7]+$/i, be = parseInt;
function j(t) {
  if (typeof t == "number")
    return t;
  if (fe(t))
    return q;
  if (O(t)) {
    var e = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = O(e) ? e + "" : e;
  }
  if (typeof t != "string")
    return t === 0 ? t : +t;
  t = ye(t);
  var n = Se.test(t);
  return n || Ee.test(t) ? be(t.slice(2), n ? 2 : 8) : we.test(t) ? q : +t;
}
var M = function() {
  return de.Date.now();
}, xe = "Expected a function", Re = Math.max, Ce = Math.min;
function Te(t, e, n) {
  var r, i, s, a, c, o, u = 0, f = !1, m = !1, h = !0;
  if (typeof t != "function")
    throw new TypeError(xe);
  e = j(e) || 0, O(n) && (f = !!n.leading, m = "maxWait" in n, s = m ? Re(j(n.maxWait) || 0, e) : s, h = "trailing" in n ? !!n.trailing : h);
  function w(l) {
    var S = r, C = i;
    return r = i = void 0, u = l, a = t.apply(C, S), a;
  }
  function R(l) {
    return u = l, c = setTimeout(L, e), f ? w(l) : a;
  }
  function I(l) {
    var S = l - o, C = l - u, U = e - S;
    return m ? Ce(U, s - C) : U;
  }
  function z(l) {
    var S = l - o, C = l - u;
    return o === void 0 || S >= e || S < 0 || m && C >= s;
  }
  function L() {
    var l = M();
    if (z(l))
      return G(l);
    c = setTimeout(L, I(l));
  }
  function G(l) {
    return c = void 0, h && r ? w(l) : (r = i = void 0, a);
  }
  function ue() {
    c !== void 0 && clearTimeout(c), u = 0, r = o = i = c = void 0;
  }
  function he() {
    return c === void 0 ? a : G(M());
  }
  function $() {
    var l = M(), S = z(l);
    if (r = arguments, i = this, o = l, S) {
      if (c === void 0)
        return R(o);
      if (m)
        return clearTimeout(c), c = setTimeout(L, e), w(o);
    }
    return c === void 0 && (c = setTimeout(L, e)), a;
  }
  return $.cancel = ue, $.flush = he, $;
}
function Ie(t, e) {
  if (t.match(/^[a-z]+:\/\//i))
    return t;
  if (t.match(/^\/\//))
    return window.location.protocol + t;
  if (t.match(/^[a-z]+:/i))
    return t;
  const n = document.implementation.createHTMLDocument(), r = n.createElement("base"), i = n.createElement("a");
  return n.head.appendChild(r), n.body.appendChild(i), e && (r.href = e), i.href = t, i.href;
}
const Le = /* @__PURE__ */ (() => {
  let t = 0;
  const e = () => (
    // eslint-disable-next-line no-bitwise
    `0000${(Math.random() * 36 ** 4 << 0).toString(36)}`.slice(-4)
  );
  return () => (t += 1, `u${e()}${t}`);
})();
function y(t) {
  const e = [];
  for (let n = 0, r = t.length; n < r; n++)
    e.push(t[n]);
  return e;
}
function v(t, e) {
  const r = (t.ownerDocument.defaultView || window).getComputedStyle(t).getPropertyValue(e);
  return r ? parseFloat(r.replace("px", "")) : 0;
}
function De(t) {
  const e = v(t, "border-left-width"), n = v(t, "border-right-width");
  return t.clientWidth + e + n;
}
function ve(t) {
  const e = v(t, "border-top-width"), n = v(t, "border-bottom-width");
  return t.clientHeight + e + n;
}
function ee(t, e = {}) {
  const n = e.width || De(t), r = e.height || ve(t);
  return { width: n, height: r };
}
function Ae() {
  let t, e;
  try {
    e = process;
  } catch {
  }
  const n = e && e.env ? e.env.devicePixelRatio : null;
  return n && (t = parseInt(n, 10), Number.isNaN(t) && (t = 1)), t || window.devicePixelRatio || 1;
}
const p = 16384;
function Fe(t) {
  (t.width > p || t.height > p) && (t.width > p && t.height > p ? t.width > t.height ? (t.height *= p / t.width, t.width = p) : (t.width *= p / t.height, t.height = p) : t.width > p ? (t.height *= p / t.width, t.width = p) : (t.width *= p / t.height, t.height = p));
}
function A(t) {
  return new Promise((e, n) => {
    const r = new Image();
    r.decode = () => e(r), r.onload = () => e(r), r.onerror = n, r.crossOrigin = "anonymous", r.decoding = "async", r.src = t;
  });
}
async function $e(t) {
  return Promise.resolve().then(() => new XMLSerializer().serializeToString(t)).then(encodeURIComponent).then((e) => `data:image/svg+xml;charset=utf-8,${e}`);
}
async function Pe(t, e, n) {
  const r = "http://www.w3.org/2000/svg", i = document.createElementNS(r, "svg"), s = document.createElementNS(r, "foreignObject");
  return i.setAttribute("width", `${e}`), i.setAttribute("height", `${n}`), i.setAttribute("viewBox", `0 0 ${e} ${n}`), s.setAttribute("width", "100%"), s.setAttribute("height", "100%"), s.setAttribute("x", "0"), s.setAttribute("y", "0"), s.setAttribute("externalResourcesRequired", "true"), i.appendChild(s), s.appendChild(t), $e(i);
}
const g = (t, e) => {
  if (t instanceof e)
    return !0;
  const n = Object.getPrototypeOf(t);
  return n === null ? !1 : n.constructor.name === e.name || g(n, e);
};
function Me(t) {
  const e = t.getPropertyValue("content");
  return `${t.cssText} content: '${e.replace(/'|"/g, "")}';`;
}
function He(t) {
  return y(t).map((e) => {
    const n = t.getPropertyValue(e), r = t.getPropertyPriority(e);
    return `${e}: ${n}${r ? " !important" : ""};`;
  }).join(" ");
}
function Oe(t, e, n) {
  const r = `.${t}:${e}`, i = n.cssText ? Me(n) : He(n);
  return document.createTextNode(`${r}{${i}}`);
}
function N(t, e, n) {
  const r = window.getComputedStyle(t, n), i = r.getPropertyValue("content");
  if (i === "" || i === "none")
    return;
  const s = Le();
  try {
    e.className = `${e.className} ${s}`;
  } catch {
    return;
  }
  const a = document.createElement("style");
  a.appendChild(Oe(s, n, r)), e.appendChild(a);
}
function Be(t, e) {
  N(t, e, ":before"), N(t, e, ":after");
}
const X = "application/font-woff", J = "image/jpeg", ke = {
  woff: X,
  woff2: X,
  ttf: "application/font-truetype",
  eot: "application/vnd.ms-fontobject",
  png: "image/png",
  jpg: J,
  jpeg: J,
  gif: "image/gif",
  tiff: "image/tiff",
  svg: "image/svg+xml",
  webp: "image/webp"
};
function Ve(t) {
  const e = /\.([^./]*?)$/g.exec(t);
  return e ? e[1] : "";
}
function V(t) {
  const e = Ve(t).toLowerCase();
  return ke[e] || "";
}
function We(t) {
  return t.split(/,/)[1];
}
function B(t) {
  return t.search(/^(data:)/) !== -1;
}
function te(t, e) {
  return `data:${e};base64,${t}`;
}
async function ne(t, e, n) {
  const r = await fetch(t, e);
  if (r.status === 404)
    throw new Error(`Resource "${r.url}" not found`);
  const i = await r.blob();
  return new Promise((s, a) => {
    const c = new FileReader();
    c.onerror = a, c.onloadend = () => {
      try {
        s(n({ res: r, result: c.result }));
      } catch (o) {
        a(o);
      }
    }, c.readAsDataURL(i);
  });
}
const H = {};
function ze(t, e, n) {
  let r = t.replace(/\?.*/, "");
  return n && (r = t), /ttf|otf|eot|woff2?/i.test(r) && (r = r.replace(/.*\//, "")), e ? `[${e}]${r}` : r;
}
async function W(t, e, n) {
  const r = ze(t, e, n.includeQueryParams);
  if (H[r] != null)
    return H[r];
  n.cacheBust && (t += (/\?/.test(t) ? "&" : "?") + (/* @__PURE__ */ new Date()).getTime());
  let i;
  try {
    const s = await ne(t, n.fetchRequestInit, ({ res: a, result: c }) => (e || (e = a.headers.get("Content-Type") || ""), We(c)));
    i = te(s, e);
  } catch (s) {
    i = n.imagePlaceholder || "";
    let a = `Failed to fetch resource: ${t}`;
    s && (a = typeof s == "string" ? s : s.message), a && console.warn(a);
  }
  return H[r] = i, i;
}
async function Ge(t) {
  const e = t.toDataURL();
  return e === "data:," ? t.cloneNode(!1) : A(e);
}
async function Ue(t, e) {
  if (t.currentSrc) {
    const s = document.createElement("canvas"), a = s.getContext("2d");
    s.width = t.clientWidth, s.height = t.clientHeight, a == null || a.drawImage(t, 0, 0, s.width, s.height);
    const c = s.toDataURL();
    return A(c);
  }
  const n = t.poster, r = V(n), i = await W(n, r, e);
  return A(i);
}
async function _e(t) {
  var e;
  try {
    if (!((e = t == null ? void 0 : t.contentDocument) === null || e === void 0) && e.body)
      return await F(t.contentDocument.body, {}, !0);
  } catch {
  }
  return t.cloneNode(!1);
}
async function qe(t, e) {
  return g(t, HTMLCanvasElement) ? Ge(t) : g(t, HTMLVideoElement) ? Ue(t, e) : g(t, HTMLIFrameElement) ? _e(t) : t.cloneNode(!1);
}
const je = (t) => t.tagName != null && t.tagName.toUpperCase() === "SLOT";
async function Ne(t, e, n) {
  var r, i;
  let s = [];
  return je(t) && t.assignedNodes ? s = y(t.assignedNodes()) : g(t, HTMLIFrameElement) && (!((r = t.contentDocument) === null || r === void 0) && r.body) ? s = y(t.contentDocument.body.childNodes) : s = y(((i = t.shadowRoot) !== null && i !== void 0 ? i : t).childNodes), s.length === 0 || g(t, HTMLVideoElement) || await s.reduce((a, c) => a.then(() => F(c, n)).then((o) => {
    o && e.appendChild(o);
  }), Promise.resolve()), e;
}
function Xe(t, e) {
  const n = e.style;
  if (!n)
    return;
  const r = window.getComputedStyle(t);
  r.cssText ? (n.cssText = r.cssText, n.transformOrigin = r.transformOrigin) : y(r).forEach((i) => {
    let s = r.getPropertyValue(i);
    i === "font-size" && s.endsWith("px") && (s = `${Math.floor(parseFloat(s.substring(0, s.length - 2))) - 0.1}px`), g(t, HTMLIFrameElement) && i === "display" && s === "inline" && (s = "block"), i === "d" && e.getAttribute("d") && (s = `path(${e.getAttribute("d")})`), n.setProperty(i, s, r.getPropertyPriority(i));
  });
}
function Je(t, e) {
  g(t, HTMLTextAreaElement) && (e.innerHTML = t.value), g(t, HTMLInputElement) && e.setAttribute("value", t.value);
}
function Qe(t, e) {
  if (g(t, HTMLSelectElement)) {
    const n = e, r = Array.from(n.children).find((i) => t.value === i.getAttribute("value"));
    r && r.setAttribute("selected", "");
  }
}
function Ye(t, e) {
  return g(e, Element) && (Xe(t, e), Be(t, e), Je(t, e), Qe(t, e)), e;
}
async function Ze(t, e) {
  const n = t.querySelectorAll ? t.querySelectorAll("use") : [];
  if (n.length === 0)
    return t;
  const r = {};
  for (let s = 0; s < n.length; s++) {
    const c = n[s].getAttribute("xlink:href");
    if (c) {
      const o = t.querySelector(c), u = document.querySelector(c);
      !o && u && !r[c] && (r[c] = await F(u, e, !0));
    }
  }
  const i = Object.values(r);
  if (i.length) {
    const s = "http://www.w3.org/1999/xhtml", a = document.createElementNS(s, "svg");
    a.setAttribute("xmlns", s), a.style.position = "absolute", a.style.width = "0", a.style.height = "0", a.style.overflow = "hidden", a.style.display = "none";
    const c = document.createElementNS(s, "defs");
    a.appendChild(c);
    for (let o = 0; o < i.length; o++)
      c.appendChild(i[o]);
    t.appendChild(a);
  }
  return t;
}
async function F(t, e, n) {
  return !n && e.filter && !e.filter(t) ? null : Promise.resolve(t).then((r) => qe(r, e)).then((r) => Ne(t, r, e)).then((r) => Ye(t, r)).then((r) => Ze(r, e));
}
const re = /url\((['"]?)([^'"]+?)\1\)/g, Ke = /url\([^)]+\)\s*format\((["']?)([^"']+)\1\)/g, et = /src:\s*(?:url\([^)]+\)\s*format\([^)]+\)[,;]\s*)+/g;
function tt(t) {
  const e = t.replace(/([.*+?^${}()|\[\]\/\\])/g, "\\$1");
  return new RegExp(`(url\\(['"]?)(${e})(['"]?\\))`, "g");
}
function nt(t) {
  const e = [];
  return t.replace(re, (n, r, i) => (e.push(i), n)), e.filter((n) => !B(n));
}
async function rt(t, e, n, r, i) {
  try {
    const s = n ? Ie(e, n) : e, a = V(e);
    let c;
    if (i) {
      const o = await i(s);
      c = te(o, a);
    } else
      c = await W(s, a, r);
    return t.replace(tt(e), `$1${c}$3`);
  } catch {
  }
  return t;
}
function it(t, { preferredFontFormat: e }) {
  return e ? t.replace(et, (n) => {
    for (; ; ) {
      const [r, , i] = Ke.exec(n) || [];
      if (!i)
        return "";
      if (i === e)
        return `src: ${r};`;
    }
  }) : t;
}
function ie(t) {
  return t.search(re) !== -1;
}
async function se(t, e, n) {
  if (!ie(t))
    return t;
  const r = it(t, n);
  return nt(r).reduce((s, a) => s.then((c) => rt(c, a, e, n)), Promise.resolve(r));
}
async function D(t, e, n) {
  var r;
  const i = (r = e.style) === null || r === void 0 ? void 0 : r.getPropertyValue(t);
  if (i) {
    const s = await se(i, null, n);
    return e.style.setProperty(t, s, e.style.getPropertyPriority(t)), !0;
  }
  return !1;
}
async function st(t, e) {
  await D("background", t, e) || await D("background-image", t, e), await D("mask", t, e) || await D("mask-image", t, e);
}
async function at(t, e) {
  const n = g(t, HTMLImageElement);
  if (!(n && !B(t.src)) && !(g(t, SVGImageElement) && !B(t.href.baseVal)))
    return;
  const r = n ? t.src : t.href.baseVal, i = await W(r, V(r), e);
  await new Promise((s, a) => {
    t.onload = s, t.onerror = a;
    const c = t;
    c.decode && (c.decode = s), c.loading === "lazy" && (c.loading = "eager"), n ? (t.srcset = "", t.src = i) : t.href.baseVal = i;
  });
}
async function ct(t, e) {
  const r = y(t.childNodes).map((i) => ae(i, e));
  await Promise.all(r).then(() => t);
}
async function ae(t, e) {
  g(t, Element) && (await st(t, e), await at(t, e), await ct(t, e));
}
function ot(t, e) {
  const { style: n } = t;
  e.backgroundColor && (n.backgroundColor = e.backgroundColor), e.width && (n.width = `${e.width}px`), e.height && (n.height = `${e.height}px`);
  const r = e.style;
  return r != null && Object.keys(r).forEach((i) => {
    n[i] = r[i];
  }), t;
}
const Q = {};
async function Y(t) {
  let e = Q[t];
  if (e != null)
    return e;
  const r = await (await fetch(t)).text();
  return e = { url: t, cssText: r }, Q[t] = e, e;
}
async function Z(t, e) {
  let n = t.cssText;
  const r = /url\(["']?([^"')]+)["']?\)/g, s = (n.match(/url\([^)]+\)/g) || []).map(async (a) => {
    let c = a.replace(r, "$1");
    return c.startsWith("https://") || (c = new URL(c, t.url).href), ne(c, e.fetchRequestInit, ({ result: o }) => (n = n.replace(a, `url(${o})`), [a, o]));
  });
  return Promise.all(s).then(() => n);
}
function K(t) {
  if (t == null)
    return [];
  const e = [], n = /(\/\*[\s\S]*?\*\/)/gi;
  let r = t.replace(n, "");
  const i = new RegExp("((@.*?keyframes [\\s\\S]*?){([\\s\\S]*?}\\s*?)})", "gi");
  for (; ; ) {
    const o = i.exec(r);
    if (o === null)
      break;
    e.push(o[0]);
  }
  r = r.replace(i, "");
  const s = /@import[\s\S]*?url\([^)]*\)[\s\S]*?;/gi, a = "((\\s*?(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*?@media[\\s\\S]*?){([\\s\\S]*?)}\\s*?})|(([\\s\\S]*?){([\\s\\S]*?)})", c = new RegExp(a, "gi");
  for (; ; ) {
    let o = s.exec(r);
    if (o === null) {
      if (o = c.exec(r), o === null)
        break;
      s.lastIndex = c.lastIndex;
    } else
      c.lastIndex = s.lastIndex;
    e.push(o[0]);
  }
  return e;
}
async function lt(t, e) {
  const n = [], r = [];
  return t.forEach((i) => {
    if ("cssRules" in i)
      try {
        y(i.cssRules || []).forEach((s, a) => {
          if (s.type === CSSRule.IMPORT_RULE) {
            let c = a + 1;
            const o = s.href, u = Y(o).then((f) => Z(f, e)).then((f) => K(f).forEach((m) => {
              try {
                i.insertRule(m, m.startsWith("@import") ? c += 1 : i.cssRules.length);
              } catch (h) {
                console.error("Error inserting rule from remote css", {
                  rule: m,
                  error: h
                });
              }
            })).catch((f) => {
              console.error("Error loading remote css", f.toString());
            });
            r.push(u);
          }
        });
      } catch (s) {
        const a = t.find((c) => c.href == null) || document.styleSheets[0];
        i.href != null && r.push(Y(i.href).then((c) => Z(c, e)).then((c) => K(c).forEach((o) => {
          a.insertRule(o, i.cssRules.length);
        })).catch((c) => {
          console.error("Error loading remote stylesheet", c);
        })), console.error("Error inlining remote css file", s);
      }
  }), Promise.all(r).then(() => (t.forEach((i) => {
    if ("cssRules" in i)
      try {
        y(i.cssRules || []).forEach((s) => {
          n.push(s);
        });
      } catch (s) {
        console.error(`Error while reading CSS rules from ${i.href}`, s);
      }
  }), n));
}
function ut(t) {
  return t.filter((e) => e.type === CSSRule.FONT_FACE_RULE).filter((e) => ie(e.style.getPropertyValue("src")));
}
async function ht(t, e) {
  if (t.ownerDocument == null)
    throw new Error("Provided element is not within a Document");
  const n = y(t.ownerDocument.styleSheets), r = await lt(n, e);
  return ut(r);
}
async function ft(t, e) {
  const n = await ht(t, e);
  return (await Promise.all(n.map((i) => {
    const s = i.parentStyleSheet ? i.parentStyleSheet.href : null;
    return se(i.cssText, s, e);
  }))).join(`
`);
}
async function dt(t, e) {
  const n = e.fontEmbedCSS != null ? e.fontEmbedCSS : e.skipFonts ? null : await ft(t, e);
  if (n) {
    const r = document.createElement("style"), i = document.createTextNode(n);
    r.appendChild(i), t.firstChild ? t.insertBefore(r, t.firstChild) : t.appendChild(r);
  }
}
async function mt(t, e = {}) {
  const { width: n, height: r } = ee(t, e), i = await F(t, e, !0);
  return await dt(i, e), await ae(i, e), ot(i, e), await Pe(i, n, r);
}
async function ce(t, e = {}) {
  const { width: n, height: r } = ee(t, e), i = await mt(t, e), s = await A(i), a = document.createElement("canvas"), c = a.getContext("2d"), o = e.pixelRatio || Ae(), u = e.canvasWidth || n, f = e.canvasHeight || r;
  return a.width = u * o, a.height = f * o, e.skipAutoScale || Fe(a), a.style.width = `${u}`, a.style.height = `${f}`, e.backgroundColor && (c.fillStyle = e.backgroundColor, c.fillRect(0, 0, a.width, a.height)), c.drawImage(s, 0, 0, a.width, a.height), a;
}
async function gt(t, e = {}) {
  return (await ce(t, e)).toDataURL();
}
async function pt(t, e = {}) {
  return (await ce(t, e)).toDataURL("image/jpeg", e.quality || 1);
}
class oe {
  constructor(e, n) {
    this.model = e, this.services = n, this.init();
  }
  init() {
  }
  update() {
  }
  // Used to pass down information to the components
  setModel(e) {
    this.model = e;
  }
  // Used to pass down services to the components
  setServices(e) {
    this.services = e;
  }
}
const yt = "DONT_STYLE_ME_css_styles_verifier";
class k extends oe {
  // initialized in initializeID() called by init()
  constructor(e, n) {
    super(e, n);
  }
  static getHTMLElementSize(e) {
    return {
      width: e.clientWidth,
      height: e.clientHeight
    };
  }
  static getSVGElementSize(e, n = {
    useAttrs: !1,
    useClientDimensions: !1,
    useBBox: !1,
    useBoundingRect: !1
  }) {
    e.attr || (e = d(e));
    const r = {
      width: 0,
      height: 0
    }, i = (h) => {
      h && Object.keys(r).forEach((w) => {
        if (h[w]) {
          const R = h[w], I = parseFloat(R);
          R && I > r[w] && ("" + R).indexOf("%") === -1 && (r[w] = I);
        }
      });
    }, s = {
      width: e.attr("width"),
      height: e.attr("height")
    }, a = e.node();
    let c, o, u, f;
    try {
      typeof a.getBBox == "function" && (c = a.getBBox(), o = {
        width: c.width,
        height: c.height
      });
    } catch (h) {
      console.error(h);
    }
    try {
      typeof (a == null ? void 0 : a.getBoundingClientRect) == "function" && (u = a.getBoundingClientRect(), f = {
        width: u.width,
        height: u.height
      });
    } catch (h) {
      console.error(h);
    }
    let m;
    if (a instanceof SVGSVGElement && (m = {
      width: a.clientWidth,
      height: a.clientHeight
    }), n) {
      if (n.useAttrs && (i(s), r.width > 0 && r.height > 0))
        return r;
      if (n.useClientDimensions && (i(m), r.width > 0 && r.height > 0))
        return m;
      if (n.useBBox && (i(o), r.width > 0 && r.height > 0))
        return o;
      if (n.useBoundingRect && (i(f), r.width > 0 && r.height > 0))
        return f;
    }
    try {
      const h = {
        width: T(e.node(), "width", "baseVal", "value"),
        height: T(e.node(), "height", "baseVal", "value")
      };
      i(h);
    } catch {
      i(m), i(o), i(s);
    }
    return r;
  }
  static appendOrSelect(e, n) {
    const r = e.select(`${n}`);
    if (r.empty()) {
      let i = n.split("#"), s, a;
      return i.length === 2 ? (s = i[0], i = i[1].split("."), a = i[0]) : (i = n.split("."), s = i[0]), e.append(s).attr("id", a).attr("class", i.slice(1).join(" "));
    }
    return r;
  }
  init() {
    this.initializeID(), this.styleHolderElement(), this.addMainContainer(), this.model.getOptions().resizable && this.addResizeListener(), this.addHolderListeners(), this.handleFullscreenChange();
  }
  getChartID() {
    return this.chartID;
  }
  getElementOffset(e, n = !1) {
    const r = { left: 0, top: 0 }, i = e.getBoundingClientRect(), s = n ? { left: 0, top: 0 } : this.getHolder().getBoundingClientRect();
    try {
      r.left = i.left - s.left, r.top = i.top - s.top;
    } catch (a) {
      console.error(a);
    }
    return r;
  }
  generateElementIDString(e) {
    return `chart-${this.chartID}-${e}`;
  }
  initializeID() {
    this.chartID = Math.floor((1 + Math.random()) * 281474976710656).toString(16);
  }
  addMainContainer() {
    const e = this.model.getOptions(), n = T(e, "style", "prefix"), r = d(this.getHolder()).append("div").classed(`${_}--${n}--chart-wrapper`, !0).attr("id", `chart-${this.getChartID()}`).style("height", "100%").style("width", "100%");
    r.append("g").attr("class", yt), this.mainContainer = r.node();
  }
  update() {
    this.styleHolderElement();
  }
  styleHolderElement() {
    const e = this.getHolder(), { width: n, height: r, theme: i } = this.model.getOptions();
    n !== this.width && (e.style.width = n, this.width = n), r !== this.height && (e.style.height = r, this.height = r), d(this.getHolder()).classed(`${_}--chart-holder`, !0).attr("data-carbon-theme", i);
  }
  getHolder() {
    return this.model.get("holder");
  }
  exportToJPG() {
    const e = this, n = this.model.getOptions(), r = this.getHolder(), i = d(r);
    i.classed("filled", !0), pt(this.getMainContainer(), {
      quality: 1,
      // Remove toolbar
      filter: (s) => !(s.classList && s.classList.contains("cds--cc--toolbar"))
    }).then(function(s) {
      var o;
      let a = "myChart";
      const c = T(n, "fileDownload", "fileName");
      typeof c == "function" ? a = c("jpg") : typeof c == "string" && (a = c), (o = e.services.files) == null || o.downloadImage(s, `${a}.jpg`), i.classed("filled", !1);
    });
  }
  exportToPNG() {
    const e = this, n = this.model.getOptions(), r = this.getHolder(), i = d(r);
    i.classed("filled", !0), gt(this.getMainContainer(), {
      quality: 1,
      // Remove toolbar
      filter: (s) => !(s.classList && s.classList.contains("cds--cc--toolbar"))
    }).then(function(s) {
      var o;
      let a = "myChart";
      const c = T(n, "fileDownload", "fileName");
      typeof c == "function" ? a = c("png") : typeof c == "string" && (a = c), (o = e.services.files) == null || o.downloadImage(s, `${a}.png`), i.classed("filled", !1);
    }).catch(function(s) {
      console.error("oops, something went wrong!", s);
    });
  }
  isFullScreenMode() {
    return d(this.getHolder()).classed("fullscreen");
  }
  toggleFullscreen() {
    const e = this.getHolder();
    d(e).classed("fullscreen") && (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) ? document.exitFullscreen ? document.exitFullscreen() : document.webkitExitFullscreen ? document.webkitExitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.msExitFullscreen && document.msExitFullscreen() : e.requestFullscreen ? e.requestFullscreen() : e.webkitRequestFullscreen ? e.webkitRequestFullscreen() : e.mozRequestFullScreen ? e.mozRequestFullScreen() : e.msRequestFullscreen && e.msRequestFullscreen();
  }
  handleFullscreenChange() {
    document.addEventListener("fullscreenchange", () => {
      const e = d(this.getHolder()), n = e.classed("fullscreen");
      e.classed("fullscreen", !n);
    });
  }
  setSVGMaxHeight() {
    if (!this.model.getOptions().height) {
      const { height: e } = k.getSVGElementSize(
        d(this.mainContainer),
        {
          useBBox: !0
        }
      ), n = d(this.mainContainer).attr("class"), r = d(this.mainContainer).selectAll(`.${n} > svg`);
      let i = 0;
      r.nodes().forEach(function(s) {
        i += Number(
          k.getSVGElementSize(d(s), {
            useBBox: !0
          }).height
        );
      }), i <= e ? d(this.mainContainer).attr("height", i) : d(this.mainContainer).attr("height", "100%");
    }
  }
  getMainContainer() {
    return this.mainContainer;
  }
  addHolderListeners() {
    const e = this.getHolder();
    e && d(e).on("mouseover", () => {
      var n;
      (n = this.services.events) == null || n.dispatchEvent(P.Chart.MOUSEOVER);
    }).on("mouseout", () => {
      var n;
      (n = this.services.events) == null || n.dispatchEvent(P.Chart.MOUSEOUT);
    });
  }
  addResizeListener() {
    const e = this.getHolder();
    if (!e)
      return;
    let n = e.clientWidth, r = e.clientHeight;
    const i = Te(() => {
      var a;
      e && (Math.abs(n - e.clientWidth) > 1 || Math.abs(r - e.clientHeight) > 1) && (n = e.clientWidth, r = e.clientHeight, (a = this.services.events) == null || a.dispatchEvent(P.Chart.RESIZE));
    }, 12.5);
    new ResizeObserver(i).observe(e);
  }
}
class le extends oe {
  static appendOrUpdateLinearGradient(e) {
    let n = e.svg.select(`defs linearGradient#${e.id}`);
    n.empty() && (n = e.svg.append("defs").append("linearGradient").attr("id", e.id).attr("x1", e.x1).attr("x2", e.x2).attr("y1", e.y1).attr("y2", e.y2)), n.selectAll("stop").remove(), n.selectAll("stop").data(e.stops).enter().append("stop").attr("offset", (r) => r.offset).style("stop-color", (r) => r.color).style("stop-opacity", (r) => r.opacity);
  }
  static getOffsetRatio(e) {
    return (Math.abs(e[1]) * 100 / Math.abs(e[0] - e[1])).toFixed(2) + "%";
  }
  static getStops(e, n) {
    const r = e[0] < 0 && e[1] > 0;
    let i = [
      {
        offset: "0%",
        color: n,
        opacity: "0.6"
      },
      {
        offset: "80%",
        color: n,
        opacity: "0"
      }
    ];
    return r && (i = [
      {
        offset: "0%",
        color: n,
        opacity: "0.6"
      },
      {
        offset: le.getOffsetRatio(e),
        color: n,
        opacity: "0"
      },
      {
        offset: "100%",
        color: n,
        opacity: "0.6"
      }
    ]), i;
  }
}
function Rt(t) {
  const e = wt(St(t), 360);
  return x(e, [0, 10]) || x(e, [350, 0]) ? {
    textAnchor: E.START,
    dominantBaseline: b.MIDDLE
  } : x(e, [10, 80]) ? {
    textAnchor: E.START,
    dominantBaseline: b.HANGING
  } : x(e, [80, 100]) ? {
    textAnchor: E.MIDDLE,
    dominantBaseline: b.HANGING
  } : x(e, [100, 170]) ? {
    textAnchor: E.END,
    dominantBaseline: b.HANGING
  } : x(e, [170, 190]) ? {
    textAnchor: E.END,
    dominantBaseline: b.MIDDLE
  } : x(e, [190, 260]) ? {
    textAnchor: E.END,
    dominantBaseline: b.BASELINE
  } : x(e, [260, 280]) ? {
    textAnchor: E.MIDDLE,
    dominantBaseline: b.BASELINE
  } : {
    textAnchor: E.START,
    dominantBaseline: b.BASELINE
  };
}
function wt(t, e) {
  return (t % e + e) % e;
}
function x(t, [e, n]) {
  return t >= e && t <= n;
}
function St(t) {
  return t * (180 / Math.PI);
}
function Ct(t) {
  return t * (Math.PI / 180);
}
function Tt(t, e, n = { x: 0, y: 0 }) {
  const r = e * Math.cos(t) + n.x, i = e * Math.sin(t) + n.y;
  return { x: isNaN(r) ? 0 : r, y: isNaN(i) ? 0 : i };
}
function It(t, e) {
  return e * Math.sin(t - Math.PI / 2);
}
export {
  k as D,
  le as G,
  oe as S,
  It as a,
  St as b,
  Te as c,
  Ct as d,
  Tt as p,
  Rt as r,
  j as t
};
//# sourceMappingURL=angle-utils-GQFx3vKM.mjs.map
