import { B as Y, m as l, C as a, D as r, t as J, x as V } from "./color-scale-utils-CiW9fERh.mjs";
import { T as yt, F as Dt, G as Lt, H as Ft, I as Pt, J as Mt, K as kt, n as Bt, L as It, y as Ht, c as Gt, E as Vt, M as Ut, f as Nt, b as Zt, g as _t, a as zt, d as Wt, N as jt, u as $t, i as Kt, s as Jt, O as Xt, P as qt, Q as Qt, R as Yt, S as eo, U as so, V as to, Y as oo, W as no, X as io, Z as ro } from "./color-scale-utils-CiW9fERh.mjs";
import { i as ho } from "./index-zSuueE1Q.mjs";
import { C as Re, c as Te, A as be, B as Oe, a as Se, d as fe, e as Ae, P as xe, G as ye, H as De, b as Le, M as Fe, R as Pe, T as Me, f as ke, W as Be } from "./wordcloud-DQKXuKDM.mjs";
import { _ as j, r as i, q as h, L as Z, y as A, t as U, e as $, S as Ie, u as K, F as p, l as R } from "./enums-DwsxZqjR.mjs";
import { A as mo, a as lo, b as po, c as Co, d as uo, f as vo, B as go, g as wo, C as Eo, h as Ro, i as To, j as bo, k as Oo, m as So, n as fo, D as Ao, o as xo, G as yo, p as Do, s as Lo, v as Fo, M as Po, w as Mo, P as ko, x as Bo, R as Io, z as Ho, H as Go, T as Vo, I as Uo, J as No, K as Zo, N as _o, O as zo, Q as Wo, U as jo, V as $o, W as Ko, Z as Jo, X as Xo, Y as qo } from "./enums-DwsxZqjR.mjs";
import { a9 as He, L as ee, l as Ge, r as _, T as z, a6 as g, a7 as L, u as se, p as W, C as Ve, a as Ue, q as Ne, o as Ze, c as _e, k as te, v as ze, b as d, G as w, R as B, P as k, w as oe, X as M, _ as C, y as We, Z as I, z as je, D as $e, m as ne, E as Ke, F as Je, a0 as ie, a2 as re, S as N, Y as ae, K as he, a1 as ce, V as Xe, I as qe, J as Qe, N as Ye, B as es, O as ss, $ as ts, Q as os, M as ns, U as is, W as rs, a3 as as, a4 as hs, a5 as cs } from "./choropleth-DdBUe80H.mjs";
import { A as Yo, x as en, a8 as sn, n as tn, H as on, d as nn, e as rn, f as an, g as hn, h as cn, i as mn, j as ln, s as pn, t as dn } from "./choropleth-DdBUe80H.mjs";
import { c as ms, C as ls, E as ps, F as ds, T as Cs, b as us, a as vs, Z as gs, f as ws } from "./zoom-DyHfBf_y.mjs";
import { D as Es, G as Rs } from "./angle-utils-GQFx3vKM.mjs";
import { S as un, d as vn, a as gn, p as wn, b as En, r as Rn } from "./angle-utils-GQFx3vKM.mjs";
function Ts(t, s, e) {
  var n = t.length;
  return e = e === void 0 ? n : e, !s && e >= n ? t : ms(t, s, e);
}
var bs = "\\ud800-\\udfff", Os = "\\u0300-\\u036f", Ss = "\\ufe20-\\ufe2f", fs = "\\u20d0-\\u20ff", As = Os + Ss + fs, xs = "\\ufe0e\\ufe0f", ys = "\\u200d", Ds = RegExp("[" + ys + bs + As + xs + "]");
function me(t) {
  return Ds.test(t);
}
function Ls(t) {
  return t.split("");
}
var le = "\\ud800-\\udfff", Fs = "\\u0300-\\u036f", Ps = "\\ufe20-\\ufe2f", Ms = "\\u20d0-\\u20ff", ks = Fs + Ps + Ms, Bs = "\\ufe0e\\ufe0f", Is = "[" + le + "]", X = "[" + ks + "]", q = "\\ud83c[\\udffb-\\udfff]", Hs = "(?:" + X + "|" + q + ")", pe = "[^" + le + "]", de = "(?:\\ud83c[\\udde6-\\uddff]){2}", Ce = "[\\ud800-\\udbff][\\udc00-\\udfff]", Gs = "\\u200d", ue = Hs + "?", ve = "[" + Bs + "]?", Vs = "(?:" + Gs + "(?:" + [pe, de, Ce].join("|") + ")" + ve + ue + ")*", Us = ve + ue + Vs, Ns = "(?:" + [pe + X + "?", X, de, Ce, Is].join("|") + ")", Zs = RegExp(q + "(?=" + q + ")|" + Ns + Us, "g");
function _s(t) {
  return t.match(Zs) || [];
}
function zs(t) {
  return me(t) ? _s(t) : Ls(t);
}
function Ws(t) {
  return function(s) {
    s = Y(s);
    var e = me(s) ? zs(s) : void 0, n = e ? e[0] : s.charAt(0), o = e ? Ts(e, 1).join("") : s.slice(1);
    return n[t]() + o;
  };
}
var js = Ws("toUpperCase");
function $s(t) {
  return js(Y(t).toLowerCase());
}
var Ks = He(function(t, s, e) {
  return s = s.toLowerCase(), t + (e ? $s(s) : s);
});
class T {
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  constructor(s, e) {
    this.components = [], this.services = {
      canvasZoom: ls,
      domUtils: Es,
      events: ps,
      files: ds,
      gradientUtils: Rs,
      transitions: Cs
    }, this.model = new Re(this.services);
  }
  // Contains the code that uses properties that are overridable by the super-class
  init(s, e) {
    this.model.set({ holder: s }, { skipUpdate: !0 }), Object.keys(this.services).forEach((n) => {
      const o = this.services[n];
      this.services[n] = new o(this.model, this.services);
    }), this.services.events.addEventListener(j.Model.UPDATE, (n) => {
      const o = !!l(n, "detail", "animate");
      this.update(o);
    }), this.model.setData(e.data), this.services.events.addEventListener(j.Chart.RESIZE, () => {
      this.update(!1);
    }), this.components = this.getComponents(), this.update();
  }
  getComponents() {
    return console.error("getComponents() method is not implemented"), [];
  }
  update(s = !0) {
    if (!this.components)
      return;
    Object.keys(this.services).forEach((o) => {
      this.services[o].update();
    }), this.components.forEach((o) => o.render(s));
    const e = this.services.transitions.getPendingTransitions(), n = Object.keys(e).map((o) => e[o].end().catch((m) => m));
    Promise.all(n).then(
      () => this.services.events.dispatchEvent(j.Chart.RENDER_FINISHED)
    );
  }
  destroy() {
    this.components.forEach((s) => s.destroy()), this.services.domUtils.getHolder().remove(), this.model.set({ destroyed: !0 }, { skipUpdate: !0 });
  }
  getChartComponents(s, e) {
    const n = this.model.getOptions(), o = l(n, "toolbar", "enabled"), c = {
      id: "legend",
      components: [new ee(this.model, this.services)],
      growth: i.PREFERRED
    }, m = l(n, "canvasZoom", "enabled");
    m && m === !0 && s.push(new Ge(this.model, this.services));
    const b = !!this.model.getOptions().title, O = {
      id: "title",
      components: [new _(this.model, this.services)],
      growth: i.STRETCH
    }, x = {
      id: "toolbar",
      components: [new z(this.model, this.services)],
      growth: i.PREFERRED
    }, F = {
      id: "header",
      components: [
        new g(
          this.model,
          this.services,
          [
            // always add title to keep layout correct
            O,
            ...o ? [x] : []
          ],
          {
            direction: h.ROW,
            alignItems: Z.CENTER
          }
        )
      ],
      growth: i.PREFERRED
    }, y = {
      id: "graph-frame",
      components: s,
      growth: i.STRETCH,
      renderType: l(e, "graphFrameRenderType") || A.SVG
    }, D = l(e, "excludeLegend") !== !0 && n.legend.enabled !== !1;
    let S = h.COLUMN;
    if (D) {
      const f = l(n, "legend", "position");
      f === "left" ? (S = h.ROW, n.legend.orientation || (n.legend.orientation = U.VERTICAL)) : f === "right" ? (S = h.ROW_REVERSE, n.legend.orientation || (n.legend.orientation = U.VERTICAL)) : f === "bottom" && (S = h.COLUMN_REVERSE);
    }
    const P = {
      id: "spacer",
      components: [new L(this.model, this.services)],
      growth: i.PREFERRED
    }, v = {
      id: "full-frame",
      components: [
        new g(
          this.model,
          this.services,
          [
            ...D ? [c] : [],
            ...D ? [P] : [],
            y
          ],
          {
            direction: S
          }
        )
      ],
      growth: i.STRETCH
    }, E = [];
    if (b || o) {
      E.push(F);
      const f = {
        id: "spacer",
        components: [
          new L(this.model, this.services, o ? { size: 15 } : void 0)
        ],
        growth: i.PREFERRED
      };
      E.push(f);
    }
    return E.push(v), [
      new se(this.model, this.services),
      new W(this.model, this.services),
      new g(this.model, this.services, E, {
        direction: h.COLUMN
      })
    ];
  }
}
class u extends T {
  constructor(s, e) {
    super(s, e), this.services = Object.assign(this.services, {
      cartesianScales: us,
      curves: vs,
      zoom: gs
    }), this.model = new Te(this.services);
  }
  getAxisChartComponents(s, e) {
    const n = this.model.getOptions(), o = l(n, "zoomBar", $.TOP, "enabled"), c = l(n, "toolbar", "enabled");
    this.services.cartesianScales.determineAxisDuality(), this.services.cartesianScales.findDomainAndRangeAxes(), this.services.cartesianScales.determineOrientation();
    const m = this.services.cartesianScales.getMainXAxisPosition(), b = l(n, "axes", m, "scaleType"), O = o && m === $.BOTTOM && b === Ie.TIME, x = this.services.zoom.isZoomBarLocked($.TOP), F = !!this.model.getOptions().title, y = {
      id: "title",
      components: [new _(this.model, this.services)],
      growth: i.STRETCH
    }, D = {
      id: "toolbar",
      components: [new z(this.model, this.services)],
      growth: i.PREFERRED
    }, S = {
      id: "header",
      components: [
        new g(
          this.model,
          this.services,
          [
            // always add title to keep layout correct
            y,
            ...c ? [D] : []
          ],
          {
            direction: h.ROW,
            alignItems: Z.CENTER
          }
        )
      ],
      growth: i.PREFERRED
    }, P = {
      id: "legend",
      components: [new ee(this.model, this.services)],
      growth: i.PREFERRED
    };
    O && !x && s.push(
      new Ve(this.model, this.services),
      new Ue(this.model, this.services)
    ), s.push(new Ne(this.model, this.services)), s.push(new Ze(this.model, this.services));
    const v = {
      id: "graph-frame",
      components: s,
      growth: i.STRETCH,
      renderType: A.SVG
    }, E = l(e, "legend", "enabled") !== !1 && this.model.getOptions().legend.enabled !== !1;
    let f = h.COLUMN;
    if (E) {
      const G = l(this.model.getOptions(), "legend", "position");
      G === K.LEFT ? (f = h.ROW, this.model.getOptions().legend.orientation || (this.model.getOptions().legend.orientation = U.VERTICAL)) : G === K.RIGHT ? (f = h.ROW_REVERSE, this.model.getOptions().legend.orientation || (this.model.getOptions().legend.orientation = U.VERTICAL)) : G === K.BOTTOM && (f = h.COLUMN_REVERSE);
    }
    const ge = {
      id: "spacer",
      components: [new L(this.model, this.services)],
      growth: i.PREFERRED
    }, we = {
      id: "full-frame",
      components: [
        new g(
          this.model,
          this.services,
          [
            ...E ? [P] : [],
            ...E ? [ge] : [],
            v
          ],
          {
            direction: f
          }
        )
      ],
      growth: i.STRETCH
    }, Ee = {
      id: "zoom-bar",
      components: [new _e(this.model, this.services)],
      growth: i.PREFERRED,
      renderType: A.SVG
    }, H = [];
    if (F || c) {
      H.push(S);
      const G = {
        id: "spacer",
        components: [
          new L(this.model, this.services, c ? { size: 15 } : void 0)
        ],
        growth: i.PREFERRED
      };
      H.push(G);
    }
    return O && H.push(Ee), H.push(we), [
      new te(this.model, this.services),
      new W(this.model, this.services),
      new g(this.model, this.services, H, {
        direction: h.COLUMN
      })
    ];
  }
}
class tt extends T {
  constructor(s, e) {
    super(s, e), this.model = new be(this.services), this.model.setOptions(a(r.alluvialChart, e.options)), this.init(s, e);
  }
  getComponents() {
    const s = [new ze(this.model, this.services)];
    return this.getChartComponents(s, {
      excludeLegend: !0
    });
  }
}
class ot extends u {
  constructor(s, e) {
    super(s, e), this.model.setOptions(
      a(J(r.areaChart), e.options)
    ), this.init(s, e);
  }
  getComponents() {
    const s = [
      new d(this.model, this.services),
      new w(this.model, this.services),
      new B(this.model, this.services),
      new k(this.model, this.services),
      new oe(this.model, this.services),
      new M(this.model, this.services, {
        fadeInOnChartHolderMouseover: !0,
        handleThresholds: !0
      }),
      new C(this.model, this.services, {
        skeleton: p.GRID
      })
    ];
    return this.getAxisChartComponents(s);
  }
}
class nt extends u {
  constructor(s, e) {
    super(s, e), this.model = new Oe(this.services), this.model.setOptions(a(r.boxplotChart, e.options)), this.init(s, e);
  }
  getComponents() {
    const s = [
      new d(this.model, this.services),
      new w(this.model, this.services),
      new We(this.model, this.services),
      new I(this.model, this.services),
      new C(this.model, this.services, {
        skeleton: p.VERT_OR_HORIZ
      })
    ];
    return this.getAxisChartComponents(s, {
      legend: {
        enabled: !1
      }
    });
  }
}
class it extends u {
  constructor(s, e) {
    super(s, e), this.model.setOptions(a(r.bubbleChart, e.options)), this.init(s, e);
  }
  getComponents() {
    const s = [
      new d(this.model, this.services),
      new w(this.model, this.services),
      new B(this.model, this.services),
      new je(this.model, this.services),
      new C(this.model, this.services, {
        skeleton: p.GRID
      })
    ];
    return this.getAxisChartComponents(s);
  }
}
class rt extends u {
  constructor(s, e) {
    super(s, e), this.model = new Se(this.services), this.model.setOptions(a(r.bulletChart, e.options)), this.init(s, e);
  }
  getComponents() {
    const s = [
      new d(this.model, this.services),
      new w(this.model, this.services),
      new $e(this.model, this.services),
      new C(this.model, this.services, {
        skeleton: p.GRID
      })
    ];
    return this.getAxisChartComponents(s);
  }
}
class at extends T {
  constructor(s, e) {
    super(s, e), this.model = new fe(this.services), this.model.setOptions(
      a(r.choroplethChart, e.options)
    ), this.init(s, e);
  }
  // Custom getChartComponents - Implements getChartComponents
  // Removes zoombar support and additional `features` that are not supported in heatmap
  getChartComponents(s, e) {
    const n = this.model.getOptions(), o = l(n, "toolbar", "enabled"), c = !!this.model.getOptions().title, m = {
      id: "title",
      components: [new _(this.model, this.services)],
      growth: i.STRETCH
    }, b = {
      id: "toolbar",
      components: [new z(this.model, this.services)],
      growth: i.PREFERRED
    }, O = {
      id: "header",
      components: [
        new g(
          this.model,
          this.services,
          [
            // always add title to keep layout correct
            m,
            ...o ? [b] : []
          ],
          {
            direction: h.ROW,
            alignItems: Z.CENTER
          }
        )
      ],
      growth: i.PREFERRED
    }, x = {
      id: "legend",
      components: [
        new ne(this.model, this.services, {
          chartType: "choropleth"
        })
      ],
      growth: i.PREFERRED,
      renderType: A.SVG
    }, F = {
      id: "graph-frame",
      components: s,
      growth: i.STRETCH,
      renderType: A.SVG
    }, y = l(e, "legend", "enabled") !== !1 && this.model.getOptions().legend.enabled !== !1 && this.model.getData().length > 0, D = h.COLUMN_REVERSE, S = {
      id: "spacer",
      components: [new L(this.model, this.services, { size: 15 })],
      growth: i.PREFERRED
    }, P = {
      id: "full-frame",
      components: [
        new g(
          this.model,
          this.services,
          [
            ...y ? [x] : [],
            ...y ? [S] : [],
            F
          ],
          {
            direction: D
          }
        )
      ],
      growth: i.STRETCH
    }, v = [];
    if (c || o) {
      v.push(O);
      const E = {
        id: "spacer",
        components: [
          new L(this.model, this.services, o ? { size: 15 } : void 0)
        ],
        growth: i.PREFERRED
      };
      v.push(E);
    }
    return v.push(P), [
      new se(this.model, this.services),
      new W(this.model, this.services),
      new g(this.model, this.services, v, {
        direction: h.COLUMN
      })
    ];
  }
  getComponents() {
    const s = [new Ke(this.model, this.services)];
    return this.getChartComponents(s);
  }
}
class ht extends T {
  constructor(s, e) {
    super(s, e), this.model = new Ae(this.services), this.model.setOptions(a(r.circlePackChart, e.options)), this.init(s, e);
  }
  getComponents() {
    const s = [new Je(this.model, this.services)];
    return this.getChartComponents(s);
  }
}
const Q = {
  [R.LINE]: [k, M],
  [R.SCATTER]: [M],
  [R.AREA]: [oe, k, M],
  [R.STACKED_AREA]: [ie, k, re, N],
  [R.SIMPLE_BAR]: [ae],
  [R.GROUPED_BAR]: [he, I],
  [R.STACKED_BAR]: [ce, N]
};
class ct extends u {
  constructor(s, e) {
    super(s, e);
    const n = a(r.comboChart, e.options);
    e.options.comboChartTypes || (console.error("No comboChartTypes defined for the Combo Chart!"), n.comboChartTypes = [{ type: R.LINE, correspondingDatasets: [] }]), this.model.setOptions(n), this.init(s, e);
  }
  getGraphComponents() {
    const { comboChartTypes: s } = this.model.getOptions();
    let e = 0;
    const n = s.map((o) => {
      const c = o.type;
      let m;
      if (typeof o.type == "string") {
        if (!Object.keys(Q).includes(o.type))
          return console.error(
            `Invalid chart type "${o.type}" specified for combo chart. Please refer to the ComboChart tutorial for more guidance.`
          ), null;
        let b = !1;
        const O = `${Ks(o.type)}Chart`;
        return m = V({}, r[O], this.model.getOptions(), o.options), o.type === R.STACKED_AREA && (b = !0), Q[o.type].map(
          (x) => new x(this.model, this.services, {
            groups: o.correspondingDatasets,
            id: e++,
            options: m,
            stacked: b
          })
        );
      } else
        return m = V({}, this.model.getOptions(), o.options), new c(this.model, this.services, {
          groups: o.correspondingDatasets,
          id: e++,
          options: m
        });
    }).filter((o) => o !== null);
    return ws(n);
  }
  getComponents() {
    const { comboChartTypes: s } = this.model.getOptions(), e = s.some(
      (c) => c.type === R.STACKED_BAR || c.type === R.STACKED_AREA
    ), n = [
      new d(this.model, this.services),
      new w(this.model, this.services),
      new C(this.model, this.services, {
        skeleton: p.GRID
      }),
      ...e ? [] : [new B(this.model, this.services)],
      ...this.getGraphComponents()
    ];
    return this.getAxisChartComponents(n);
  }
}
class Js extends T {
  // TODO - Optimize the use of "extending"
  constructor(s, e, n = !1) {
    super(s, e), this.model = new xe(this.services), !n && (this.model.setOptions(a(r.pieChart, e.options)), this.init(s, e));
  }
  getComponents() {
    const s = [
      new Xe(this.model, this.services),
      new C(this.model, this.services, {
        skeleton: p.PIE
      })
    ];
    return this.getChartComponents(s);
  }
}
class mt extends Js {
  constructor(s, e) {
    super(s, e, !0), this.model.setOptions(a(r.donutChart, e.options)), this.init(s, e);
  }
  getComponents() {
    const s = [
      new qe(this.model, this.services),
      new C(this.model, this.services, {
        skeleton: p.DONUT
      })
    ];
    return this.getChartComponents(s);
  }
}
class lt extends T {
  constructor(s, e) {
    super(s, e), this.model = new ye(this.services), this.model.setOptions(a(r.gaugeChart, e.options)), this.init(s, e);
  }
  getComponents() {
    const s = [new Qe(this.model, this.services)];
    return this.getChartComponents(s);
  }
}
class pt extends u {
  constructor(s, e) {
    super(s, e), this.model.setOptions(a(r.groupedBarChart, e.options)), this.init(s, e);
  }
  getComponents() {
    const s = [
      new d(this.model, this.services),
      new w(this.model, this.services),
      new he(this.model, this.services),
      new I(this.model, this.services),
      new C(this.model, this.services, {
        skeleton: p.VERT_OR_HORIZ
      })
    ];
    return this.getAxisChartComponents(s);
  }
}
class dt extends u {
  constructor(s, e) {
    super(s, e), this.model = new De(this.services), this.model.setOptions(
      a(r.heatmapChart, e.options)
    ), this.init(s, e);
  }
  // Custom getChartComponents - Implements getChartComponents
  // Removes zoombar support and additional `features` that are not supported in heatmap
  getAxisChartComponents(s, e) {
    const n = this.model.getOptions(), o = l(n, "toolbar", "enabled");
    this.services.cartesianScales.determineAxisDuality(), this.services.cartesianScales.findDomainAndRangeAxes(), this.services.cartesianScales.determineOrientation();
    const c = !!this.model.getOptions().title, m = {
      id: "title",
      components: [new _(this.model, this.services)],
      growth: i.STRETCH
    }, b = {
      id: "toolbar",
      components: [new z(this.model, this.services)],
      growth: i.PREFERRED
    }, O = {
      id: "header",
      components: [
        new g(
          this.model,
          this.services,
          [
            // always add title to keep layout correct
            m,
            ...o ? [b] : []
          ],
          {
            direction: h.ROW,
            alignItems: Z.CENTER
          }
        )
      ],
      growth: i.PREFERRED
    }, x = {
      id: "legend",
      components: [
        new ne(this.model, this.services, {
          chartType: "heatmap"
        })
      ],
      growth: i.PREFERRED,
      renderType: A.SVG
    }, F = {
      id: "graph-frame",
      components: s,
      growth: i.STRETCH,
      renderType: A.SVG
    }, y = l(e, "legend", "enabled") !== !1 && this.model.getOptions().legend.enabled !== !1 && this.model.getData().length > 0, D = h.COLUMN_REVERSE, S = {
      id: "spacer",
      components: [new L(this.model, this.services, { size: 15 })],
      growth: i.PREFERRED
    }, P = {
      id: "full-frame",
      components: [
        new g(
          this.model,
          this.services,
          [
            ...y ? [x] : [],
            ...y ? [S] : [],
            F
          ],
          {
            direction: D
          }
        )
      ],
      growth: i.STRETCH
    }, v = [];
    if (c || o) {
      v.push(O);
      const E = {
        id: "spacer",
        components: [
          new L(this.model, this.services, o ? { size: 15 } : void 0)
        ],
        growth: i.PREFERRED
      };
      v.push(E);
    }
    return v.push(P), [
      new te(this.model, this.services),
      new W(this.model, this.services),
      new g(this.model, this.services, v, {
        direction: h.COLUMN
      })
    ];
  }
  getComponents() {
    const s = [
      new d(this.model, this.services),
      new Ye(this.model, this.services)
    ];
    return this.getAxisChartComponents(s);
  }
}
class Ct extends u {
  constructor(s, e) {
    super(s, e), this.model = new Le(this.services), this.model.setOptions(a(r.histogramChart, e.options)), this.init(s, e), this.update();
  }
  getComponents() {
    const s = [
      new d(this.model, this.services),
      new w(this.model, this.services),
      new es(this.model, this.services),
      new ss(this.model, this.services)
    ];
    return this.getAxisChartComponents(s);
  }
}
class ut extends u {
  constructor(s, e) {
    super(s, e), this.model.setOptions(a(r.lineChart, e.options)), this.init(s, e);
  }
  getComponents() {
    const s = [
      new d(this.model, this.services),
      new w(this.model, this.services),
      new B(this.model, this.services),
      new k(this.model, this.services),
      new M(this.model, this.services, { handleThresholds: !0 }),
      new ts(this.model, this.services),
      new I(this.model, this.services)
    ];
    return this.getAxisChartComponents(s);
  }
}
class vt extends u {
  constructor(s, e) {
    super(s, e), this.model.setOptions(a(r.lollipopChart, e.options)), this.init(s, e);
  }
  getComponents() {
    const s = [
      new d(this.model, this.services),
      new w(this.model, this.services),
      new B(this.model, this.services),
      new os(this.model, this.services),
      new M(this.model, this.services),
      new C(this.model, this.services, {
        skeleton: p.GRID
      })
    ];
    return this.getAxisChartComponents(s);
  }
}
class gt extends T {
  constructor(s, e) {
    var o;
    super(s, e), this.model = new Fe(this.services);
    const n = (o = e.options.meter) != null && o.proportional ? V(J(r.proportionalMeterChart), e.options) : V(J(r.meterChart), e.options);
    this.model.setOptions(n), this.init(s, e);
  }
  getComponents() {
    const e = [
      ...l(this.model.getOptions(), "meter", "showLabels") ? [
        // Meter has a unique dataset title within the graph
        {
          id: "meter-title",
          components: [new ns(this.model, this.services)],
          growth: i.STRETCH,
          renderType: A.SVG
        },
        // Create the title spacer
        {
          id: "spacer",
          components: [
            new L(this.model, this.services, {
              size: 8
            })
          ],
          growth: i.STRETCH
        }
      ] : [],
      // Specify what to render inside the graph only
      {
        id: "meter-graph",
        components: [new is(this.model, this.services)],
        growth: i.STRETCH,
        renderType: A.SVG
      }
    ], n = [
      new g(this.model, this.services, e, {
        direction: h.COLUMN
      })
    ];
    return this.getChartComponents(n, {
      graphFrameRenderType: A.HTML
    });
  }
}
class wt extends T {
  constructor(s, e) {
    super(s, e), this.model = new Pe(this.services), this.model.setOptions(a(r.radarChart, e.options)), this.init(s, e);
  }
  getComponents() {
    const s = [new rs(this.model, this.services)];
    return this.getChartComponents(s);
  }
}
class Et extends u {
  constructor(s, e) {
    super(s, e), this.model.setOptions(a(r.scatterChart, e.options)), this.init(s, e);
  }
  getComponents() {
    const s = [
      new d(this.model, this.services),
      new w(this.model, this.services),
      new B(this.model, this.services),
      new M(this.model, this.services),
      new C(this.model, this.services, {
        skeleton: p.GRID
      })
    ];
    return this.getAxisChartComponents(s);
  }
}
class Rt extends T {
  constructor(s, e) {
    super(s, e), this.model = new Me(this.services), this.model.setOptions(a(r.treeChart, e.options)), this.init(s, e);
  }
  getComponents() {
    const s = [new as(this.model, this.services)];
    return this.getChartComponents(s, {
      excludeLegend: !0
    });
  }
}
class Tt extends T {
  constructor(s, e) {
    super(s, e), this.model = new ke(this.services), this.model.setOptions(a(r.treemapChart, e.options)), this.init(s, e);
  }
  getComponents() {
    const s = [new hs(this.model, this.services)];
    return this.getChartComponents(s);
  }
}
class bt extends u {
  constructor(s, e) {
    super(s, e), this.model.setOptions(a(r.simpleBarChart, e.options)), this.init(s, e);
  }
  getComponents() {
    const s = [
      new d(this.model, this.services),
      new w(this.model, this.services),
      new ae(this.model, this.services),
      new I(this.model, this.services),
      new C(this.model, this.services, {
        skeleton: p.VERT_OR_HORIZ
      })
    ];
    return this.getAxisChartComponents(s);
  }
}
class Ot extends u {
  constructor(s, e) {
    super(s, e), this.model.setOptions(a(r.stackedAreaChart, e.options)), this.init(s, e);
  }
  getComponents() {
    const s = [
      new d(this.model, this.services),
      new w(this.model, this.services),
      new N(this.model, this.services),
      new ie(this.model, this.services),
      new k(this.model, this.services, { stacked: !0 }),
      new re(this.model, this.services, {
        fadeInOnChartHolderMouseover: !0,
        handleThresholds: !0,
        stacked: !0
      }),
      new C(this.model, this.services, {
        skeleton: p.GRID
      })
    ];
    return this.getAxisChartComponents(s);
  }
}
class St extends u {
  constructor(s, e) {
    super(s, e), this.model.setOptions(a(r.stackedBarChart, e.options)), this.init(s, e);
  }
  getComponents() {
    const s = [
      new d(this.model, this.services),
      new w(this.model, this.services),
      new N(this.model, this.services),
      new ce(this.model, this.services),
      new C(this.model, this.services, {
        skeleton: p.VERT_OR_HORIZ
      }),
      new I(this.model, this.services)
    ];
    return this.getAxisChartComponents(s);
  }
}
class ft extends T {
  constructor(s, e) {
    super(s, e), this.model = new Be(this.services), this.model.setOptions(a(r.wordCloudChart, e.options)), this.init(s, e);
  }
  getComponents() {
    const s = [
      new cs(this.model, this.services),
      new C(this.model, this.services, {
        skeleton: p.PIE
      })
    ];
    return this.getChartComponents(s);
  }
}
export {
  mo as Alignments,
  ze as Alluvial,
  tt as AlluvialChart,
  be as AlluvialChartModel,
  oe as Area,
  ot as AreaChart,
  lo as AreaEvent,
  po as ArrowDirections,
  Yo as Axis,
  u as AxisChart,
  te as AxisChartsTooltip,
  Co as AxisEvent,
  uo as AxisFlavor,
  $ as AxisPositions,
  vo as AxisTitleOrientations,
  en as Bar,
  go as BarEvent,
  es as BinnedRuler,
  We as Boxplot,
  nt as BoxplotChart,
  Oe as BoxplotChartModel,
  wo as BoxplotEvent,
  je as Bubble,
  it as BubbleChart,
  $e as Bullet,
  rt as BulletChart,
  Se as BulletChartModel,
  Eo as CalloutDirections,
  Ge as CanvasChartClip,
  ls as CanvasZoom,
  Ro as CanvasZoomEvent,
  To as CartesianOrientations,
  us as CartesianScales,
  T as Chart,
  Ue as ChartBrush,
  Ve as ChartClip,
  bo as ChartEvent,
  Re as ChartModel,
  Le as ChartModelBinned,
  Te as ChartModelCartesian,
  Oo as ChartTheme,
  R as ChartTypes,
  Ke as Choropleth,
  fe as ChoroplethModel,
  Je as CirclePack,
  ht as CirclePackChart,
  Ae as CirclePackChartModel,
  So as ColorClassNameTypes,
  fo as ColorLegendType,
  ne as ColorScaleLegend,
  ct as ComboChart,
  sn as Component,
  vs as Curves,
  Es as DOMUtils,
  Ao as DividerStatus,
  xo as DominantBaseline,
  qe as Donut,
  mt as DonutChart,
  ps as Events,
  at as ExperimentalChoroplethChart,
  ds as Files,
  Qe as Gauge,
  lt as GaugeChart,
  ye as GaugeChartModel,
  yo as GaugeEvent,
  Do as GaugeTypes,
  tn as GeoProjection,
  Rs as GradientUtils,
  w as Grid,
  he as GroupedBar,
  pt as GroupedBarChart,
  Ye as Heatmap,
  dt as HeatmapChart,
  De as HeatmapModel,
  Ze as Highlight,
  ss as Histogram,
  Ct as HistogramChart,
  on as HoverAxis,
  Z as LayoutAlignItems,
  g as LayoutComponent,
  h as LayoutDirection,
  i as LayoutGrowth,
  ee as Legend,
  Lo as LegendItemType,
  U as LegendOrientations,
  K as LegendPositions,
  k as Line,
  ut as LineChart,
  Fo as LineEvent,
  os as Lollipop,
  vt as LollipopChart,
  is as Meter,
  gt as MeterChart,
  Fe as MeterChartModel,
  ns as MeterTitle,
  W as Modal,
  Po as ModalEvent,
  Mo as ModelEvent,
  Xe as Pie,
  Js as PieChart,
  xe as PieChartModel,
  ko as PieEvent,
  Bo as Projection,
  rs as Radar,
  wt as RadarChart,
  Pe as RadarChartModel,
  Io as RadarEvent,
  A as RenderTypes,
  B as Ruler,
  Ie as ScaleTypes,
  M as Scatter,
  Et as ScatterChart,
  Ho as ScatterEvent,
  un as Service,
  ae as SimpleBar,
  bt as SimpleBarChart,
  C as Skeleton,
  ts as SkeletonLines,
  p as Skeletons,
  L as Spacer,
  ie as StackedArea,
  Ot as StackedAreaChart,
  ce as StackedBar,
  St as StackedBarChart,
  N as StackedRuler,
  re as StackedScatter,
  Go as Statuses,
  yt as TIME_INTERVALS,
  Vo as TextAnchor,
  Ne as Threshold,
  Uo as ThresholdEvent,
  No as TickRotations,
  _ as Title,
  z as Toolbar,
  Zo as ToolbarControlTypes,
  se as Tooltip,
  _o as TooltipEvent,
  Cs as Transitions,
  as as Tree,
  Rt as TreeChart,
  Me as TreeChartModel,
  zo as TreeEvent,
  Wo as TreeTypes,
  hs as Treemap,
  Tt as TreemapChart,
  ke as TreemapChartModel,
  jo as TreemapEvent,
  $o as TruncationTypes,
  d as TwoDimensionalAxes,
  cs as WordCloud,
  ft as WordCloudChart,
  Ko as WordCloudEvent,
  Be as WordCloudModel,
  I as ZeroLine,
  gs as Zoom,
  _e as ZoomBar,
  Jo as ZoomBarTypes,
  Xo as ZoomDomainEvent,
  qo as ZoombarEvent,
  Dt as alluvial,
  Lt as area,
  nn as arrowLeft,
  rn as arrowRight,
  Ft as axis,
  Pt as baseTooltip,
  Mt as boxplot,
  an as buildBezierPathString,
  hn as buildElbowPathString,
  cn as buildStraightPathString,
  kt as canvasZoomSettings,
  Bt as carbonPrefix,
  mn as circle,
  It as circlePack,
  Ht as color,
  Gt as computeTimeIntervalName,
  Vt as configurations,
  Ut as defaultLegendAdditionalItems,
  vn as degToRad,
  ln as diamond,
  gn as distanceBetweenPointOnCircAndVerticalDiameter,
  Nt as formatDateTillMilliSeconds,
  Zt as formatTick,
  _t as getColorScale,
  zt as getDomain,
  Wt as getTimeformats,
  jt as grid,
  $t as histogram,
  ho as interfaces,
  Kt as isTickPrimary,
  Jt as legend,
  Xt as lines,
  qt as meter,
  r as options,
  Qt as pie,
  wn as polarToCartesianCoords,
  En as radToDeg,
  Yt as radar,
  Rn as radialLabelPlacement,
  eo as ruler,
  so as spacers,
  pn as square,
  dn as tee,
  to as timeScale,
  oo as toolbar,
  no as tooltips,
  io as transitions,
  ro as zoomBar
};
//# sourceMappingURL=index.mjs.map
