import { B as Js, af as Ua, h as Fa, o as Qs, p as ea, a6 as za, _ as Wa, ag as ja, ah as Xa, ai as Za, m as v, n as Me, x as ut, U as gs, A as ne, s as he, aj as xt, Z as we, W as Ya, z as ta, t as qa, ak as Ue, c as vn, b as yn, F as ke, al as Ot, am as Ge, G as $e, O as He, an as Ka, H as ct, i as Ja, Q as te, J as Ae, ao as Ee, ap as Qa, a as ei, P as ge, L as yt, K as _t, aq as sn, v as ti, ar as ms, R as je } from "./color-scale-utils-CiW9fERh.mjs";
import { select as T, pointer as Zt, brushX as na, scaleTime as ni, extent as Yt, area as Bn, line as Gn, axisBottom as Hn, axisLeft as sa, axisTop as si, axisRight as ai, scaleLinear as qe, arc as Lt, easeLinear as ii, path as $n, interpolateNumber as aa, quantize as ri, scaleBand as Un, hierarchy as Fn, pack as oi, pie as li, interpolate as ci, interpolateRound as di, min as En, max as fs, lineRadial as hi, curveLinearClosed as ui, cluster as pi, tree as gi, linkHorizontal as mi, treemap as fi, hsl as ia, color as ra, geoPath as vi, geoNaturalEarth1 as yi, geoMercator as Ei, geoEquirectangular as bi, geoConicEquidistant as Si, geoConicEqualArea as Oi, geoAlbers as Ti, geoEqualEarth as xi } from "d3";
import { t as Bt, D as S, c as bn, G as vs, a as Li, p as le, r as ys, b as Ai } from "./angle-utils-GQFx3vKM.mjs";
import { y as j, _ as f, K as ie, r as ze, q as st, L as wi, A as Ce, m as z, s as Xe, V as dt, S as pe, e as B, Z as at, i as xe, f as Es, J as an, d as Mi, F as It, n as rn, H as on, C as ln, p as Rt, b as bs, D as cn, Q as Ci, x as Ze, $ as kt, N as dn } from "./enums-DwsxZqjR.mjs";
import { sankey as _i, sankeyLinkHorizontal as Ii, sankeyJustify as Ri, sankeyLeft as ki, sankeyRight as Di } from "d3-sankey";
import { R as X } from "./a11y-ePqvrObQ.mjs";
import { b as oa } from "./_baseEach-Ch85zB0O.mjs";
import Pi from "d3-cloud";
function Ni(o, e, t, n) {
  var s = -1, a = o == null ? 0 : o.length;
  for (n && a && (t = o[++s]); ++s < a; )
    t = e(t, o[s], s, o);
  return t;
}
function Vi(o) {
  return function(e) {
    return o == null ? void 0 : o[e];
  };
}
var Bi = {
  // Latin-1 Supplement block.
  À: "A",
  Á: "A",
  Â: "A",
  Ã: "A",
  Ä: "A",
  Å: "A",
  à: "a",
  á: "a",
  â: "a",
  ã: "a",
  ä: "a",
  å: "a",
  Ç: "C",
  ç: "c",
  Ð: "D",
  ð: "d",
  È: "E",
  É: "E",
  Ê: "E",
  Ë: "E",
  è: "e",
  é: "e",
  ê: "e",
  ë: "e",
  Ì: "I",
  Í: "I",
  Î: "I",
  Ï: "I",
  ì: "i",
  í: "i",
  î: "i",
  ï: "i",
  Ñ: "N",
  ñ: "n",
  Ò: "O",
  Ó: "O",
  Ô: "O",
  Õ: "O",
  Ö: "O",
  Ø: "O",
  ò: "o",
  ó: "o",
  ô: "o",
  õ: "o",
  ö: "o",
  ø: "o",
  Ù: "U",
  Ú: "U",
  Û: "U",
  Ü: "U",
  ù: "u",
  ú: "u",
  û: "u",
  ü: "u",
  Ý: "Y",
  ý: "y",
  ÿ: "y",
  Æ: "Ae",
  æ: "ae",
  Þ: "Th",
  þ: "th",
  ß: "ss",
  // Latin Extended-A block.
  Ā: "A",
  Ă: "A",
  Ą: "A",
  ā: "a",
  ă: "a",
  ą: "a",
  Ć: "C",
  Ĉ: "C",
  Ċ: "C",
  Č: "C",
  ć: "c",
  ĉ: "c",
  ċ: "c",
  č: "c",
  Ď: "D",
  Đ: "D",
  ď: "d",
  đ: "d",
  Ē: "E",
  Ĕ: "E",
  Ė: "E",
  Ę: "E",
  Ě: "E",
  ē: "e",
  ĕ: "e",
  ė: "e",
  ę: "e",
  ě: "e",
  Ĝ: "G",
  Ğ: "G",
  Ġ: "G",
  Ģ: "G",
  ĝ: "g",
  ğ: "g",
  ġ: "g",
  ģ: "g",
  Ĥ: "H",
  Ħ: "H",
  ĥ: "h",
  ħ: "h",
  Ĩ: "I",
  Ī: "I",
  Ĭ: "I",
  Į: "I",
  İ: "I",
  ĩ: "i",
  ī: "i",
  ĭ: "i",
  į: "i",
  ı: "i",
  Ĵ: "J",
  ĵ: "j",
  Ķ: "K",
  ķ: "k",
  ĸ: "k",
  Ĺ: "L",
  Ļ: "L",
  Ľ: "L",
  Ŀ: "L",
  Ł: "L",
  ĺ: "l",
  ļ: "l",
  ľ: "l",
  ŀ: "l",
  ł: "l",
  Ń: "N",
  Ņ: "N",
  Ň: "N",
  Ŋ: "N",
  ń: "n",
  ņ: "n",
  ň: "n",
  ŋ: "n",
  Ō: "O",
  Ŏ: "O",
  Ő: "O",
  ō: "o",
  ŏ: "o",
  ő: "o",
  Ŕ: "R",
  Ŗ: "R",
  Ř: "R",
  ŕ: "r",
  ŗ: "r",
  ř: "r",
  Ś: "S",
  Ŝ: "S",
  Ş: "S",
  Š: "S",
  ś: "s",
  ŝ: "s",
  ş: "s",
  š: "s",
  Ţ: "T",
  Ť: "T",
  Ŧ: "T",
  ţ: "t",
  ť: "t",
  ŧ: "t",
  Ũ: "U",
  Ū: "U",
  Ŭ: "U",
  Ů: "U",
  Ű: "U",
  Ų: "U",
  ũ: "u",
  ū: "u",
  ŭ: "u",
  ů: "u",
  ű: "u",
  ų: "u",
  Ŵ: "W",
  ŵ: "w",
  Ŷ: "Y",
  ŷ: "y",
  Ÿ: "Y",
  Ź: "Z",
  Ż: "Z",
  Ž: "Z",
  ź: "z",
  ż: "z",
  ž: "z",
  Ĳ: "IJ",
  ĳ: "ij",
  Œ: "Oe",
  œ: "oe",
  ŉ: "'n",
  ſ: "s"
}, Gi = Vi(Bi);
const Hi = Gi;
var $i = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Ui = "\\u0300-\\u036f", Fi = "\\ufe20-\\ufe2f", zi = "\\u20d0-\\u20ff", Wi = Ui + Fi + zi, ji = "[" + Wi + "]", Xi = RegExp(ji, "g");
function Zi(o) {
  return o = Js(o), o && o.replace($i, Hi).replace(Xi, "");
}
var Yi = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function qi(o) {
  return o.match(Yi) || [];
}
var Ki = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function Ji(o) {
  return Ki.test(o);
}
var la = "\\ud800-\\udfff", Qi = "\\u0300-\\u036f", er = "\\ufe20-\\ufe2f", tr = "\\u20d0-\\u20ff", nr = Qi + er + tr, ca = "\\u2700-\\u27bf", da = "a-z\\xdf-\\xf6\\xf8-\\xff", sr = "\\xac\\xb1\\xd7\\xf7", ar = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", ir = "\\u2000-\\u206f", rr = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", ha = "A-Z\\xc0-\\xd6\\xd8-\\xde", or = "\\ufe0e\\ufe0f", ua = sr + ar + ir + rr, pa = "['’]", Ss = "[" + ua + "]", lr = "[" + nr + "]", ga = "\\d+", cr = "[" + ca + "]", ma = "[" + da + "]", fa = "[^" + la + ua + ga + ca + da + ha + "]", dr = "\\ud83c[\\udffb-\\udfff]", hr = "(?:" + lr + "|" + dr + ")", ur = "[^" + la + "]", va = "(?:\\ud83c[\\udde6-\\uddff]){2}", ya = "[\\ud800-\\udbff][\\udc00-\\udfff]", lt = "[" + ha + "]", pr = "\\u200d", Os = "(?:" + ma + "|" + fa + ")", gr = "(?:" + lt + "|" + fa + ")", Ts = "(?:" + pa + "(?:d|ll|m|re|s|t|ve))?", xs = "(?:" + pa + "(?:D|LL|M|RE|S|T|VE))?", Ea = hr + "?", ba = "[" + or + "]?", mr = "(?:" + pr + "(?:" + [ur, va, ya].join("|") + ")" + ba + Ea + ")*", fr = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", vr = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", yr = ba + Ea + mr, Er = "(?:" + [cr, va, ya].join("|") + ")" + yr, br = RegExp([
  lt + "?" + ma + "+" + Ts + "(?=" + [Ss, lt, "$"].join("|") + ")",
  gr + "+" + xs + "(?=" + [Ss, lt + Os, "$"].join("|") + ")",
  lt + "?" + Os + "+" + Ts,
  lt + "+" + xs,
  vr,
  fr,
  ga,
  Er
].join("|"), "g");
function Sr(o) {
  return o.match(br) || [];
}
function Or(o, e, t) {
  return o = Js(o), e = t ? void 0 : e, e === void 0 ? Ji(o) ? Sr(o) : qi(o) : o.match(e) || [];
}
var Tr = "['’]", xr = RegExp(Tr, "g");
function Lr(o) {
  return function(e) {
    return Ni(Or(Zi(e).replace(xr, "")), o, "");
  };
}
function Ar(o, e, t) {
  return o === o && (t !== void 0 && (o = o <= t ? o : t), e !== void 0 && (o = o >= e ? o : e)), o;
}
function Sa(o, e, t) {
  return t === void 0 && (t = e, e = void 0), t !== void 0 && (t = Bt(t), t = t === t ? t : 0), e !== void 0 && (e = Bt(e), e = e === e ? e : 0), Ar(Bt(o), e, t);
}
var wr = "Expected a function";
function Mr(o, e, t) {
  if (typeof o != "function")
    throw new TypeError(wr);
  return setTimeout(function() {
    o.apply(void 0, t);
  }, e);
}
var Cr = Ua(function(o, e, t) {
  return Mr(o, Bt(e) || 0, t);
});
function _r(o, e) {
  var t = -1, n = Fa(o) ? Array(o.length) : [];
  return oa(o, function(s, a, i) {
    n[++t] = e(s, a, i);
  }), n;
}
function Ir(o, e) {
  var t = ea(o) ? za : _r;
  return t(o, Qs(e));
}
var Rr = 1 / 0;
function kr(o, e) {
  return Wa(Ir(o, e), Rr);
}
function Oa(o, e) {
  return ja(o, e);
}
var it = Lr(function(o, e, t) {
  return o + (t ? "-" : "") + e.toLowerCase();
});
function Dr(o, e) {
  var t;
  return oa(o, function(n, s, a) {
    return t = e(n, s, a), !t;
  }), !!t;
}
function Pr(o, e, t) {
  var n = ea(o) ? Za : Dr;
  return t && Xa(o, e, t) && (e = void 0), n(o, Qs(e));
}
class Y {
  constructor(e, t, n) {
    if (this.type = "", this.renderType = j.HTML, this.id = "", this.parent = void 0, this.configs = {}, this.model = e, this.services = t, n && (this.configs = n, this.configs.id)) {
      const s = v(this.model.getOptions(), "style", "prefix");
      this.id = `${s}--${this.configs.id}`;
    }
    this.parent || this.setParent(
      T(
        this.services.domUtils.getMainContainer()
      )
    );
  }
  init() {
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e = !0) {
    console.error("Error: Component did not provide the required render function.");
  }
  destroy() {
  }
  // Used to pass down information to the components
  setModel(e) {
    this.model = e;
  }
  // Used to pass down information to the components
  setServices(e) {
    this.services = e;
  }
  setParent(e) {
    var n;
    const t = this.parent;
    if (this.parent = e, !(t && t.node() === e.node()) && this.type) {
      const s = v(this.model.getOptions(), "style", "prefix");
      (n = this.parent) == null || n.classed(`${Me}--${s}--${this.type}`, !0), t && t.classed(`${Me}--${s}--${this.type}`, !1);
    }
  }
  getParent() {
    return this.parent;
  }
  getComponentContainer(e = { withinChartClip: !1 }) {
    if (this.type) {
      const t = v(this.model.getOptions(), "style", "prefix"), n = this.id ? `#${this.id}` : "", s = S.appendOrSelect(
        this.parent,
        `${this.renderType === j.SVG ? "svg" : "div"}${n}.${Me}--${t}--${this.type}`
      );
      if (e.withinChartClip) {
        const a = this.model.get("chartClipId");
        if (a) {
          const r = T(`#${a}`).select("rect");
          r.size() !== 0 && parseFloat(r.attr("height")) > 0 && s.attr("clip-path", `url(#${a})`);
        }
      }
      return s.attr("width", "100%").attr("height", "100%");
    }
    return this.parent;
  }
  /**
   * graphs used in combo charts share a model with global options but can receive their own local options.
   * this function retrieves the global options and merges it with any options passed into this
   * component's config.options object.
   */
  getOptions() {
    return this.configs.options ? ut({}, this.model.getOptions(), this.configs.options) : this.model.getOptions();
  }
}
/*! @license DOMPurify 3.1.0 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.1.0/LICENSE */
const {
  entries: Ta,
  setPrototypeOf: Ls,
  isFrozen: Nr,
  getPrototypeOf: Vr,
  getOwnPropertyDescriptor: Br
} = Object;
let {
  freeze: be,
  seal: _e,
  create: xa
} = Object, {
  apply: Sn,
  construct: On
} = typeof Reflect < "u" && Reflect;
be || (be = function(e) {
  return e;
});
_e || (_e = function(e) {
  return e;
});
Sn || (Sn = function(e, t, n) {
  return e.apply(t, n);
});
On || (On = function(e, t) {
  return new e(...t);
});
const Dt = Le(Array.prototype.forEach), As = Le(Array.prototype.pop), Et = Le(Array.prototype.push), Gt = Le(String.prototype.toLowerCase), hn = Le(String.prototype.toString), ws = Le(String.prototype.match), bt = Le(String.prototype.replace), Gr = Le(String.prototype.indexOf), Hr = Le(String.prototype.trim), De = Le(Object.prototype.hasOwnProperty), Te = Le(RegExp.prototype.test), St = $r(TypeError);
function Le(o) {
  return function(e) {
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), s = 1; s < t; s++)
      n[s - 1] = arguments[s];
    return Sn(o, e, n);
  };
}
function $r(o) {
  return function() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return On(o, t);
  };
}
function Z(o, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Gt;
  Ls && Ls(o, null);
  let n = e.length;
  for (; n--; ) {
    let s = e[n];
    if (typeof s == "string") {
      const a = t(s);
      a !== s && (Nr(e) || (e[n] = a), s = a);
    }
    o[s] = !0;
  }
  return o;
}
function Ur(o) {
  for (let e = 0; e < o.length; e++)
    De(o, e) || (o[e] = null);
  return o;
}
function Ye(o) {
  const e = xa(null);
  for (const [t, n] of Ta(o))
    De(o, t) && (Array.isArray(n) ? e[t] = Ur(n) : n && typeof n == "object" && n.constructor === Object ? e[t] = Ye(n) : e[t] = n);
  return e;
}
function Pt(o, e) {
  for (; o !== null; ) {
    const n = Br(o, e);
    if (n) {
      if (n.get)
        return Le(n.get);
      if (typeof n.value == "function")
        return Le(n.value);
    }
    o = Vr(o);
  }
  function t() {
    return null;
  }
  return t;
}
const Ms = be(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), un = be(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), pn = be(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), Fr = be(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), gn = be(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), zr = be(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), Cs = be(["#text"]), _s = be(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), mn = be(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), Is = be(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), Nt = be(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), Wr = _e(/\{\{[\w\W]*|[\w\W]*\}\}/gm), jr = _e(/<%[\w\W]*|[\w\W]*%>/gm), Xr = _e(/\${[\w\W]*}/gm), Zr = _e(/^data-[\-\w.\u00B7-\uFFFF]/), Yr = _e(/^aria-[\-\w]+$/), La = _e(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), qr = _e(/^(?:\w+script|data):/i), Kr = _e(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), Aa = _e(/^html$/i), Jr = _e(/^[a-z][.\w]*(-[.\w]+)+$/i);
var Rs = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MUSTACHE_EXPR: Wr,
  ERB_EXPR: jr,
  TMPLIT_EXPR: Xr,
  DATA_ATTR: Zr,
  ARIA_ATTR: Yr,
  IS_ALLOWED_URI: La,
  IS_SCRIPT_OR_DATA: qr,
  ATTR_WHITESPACE: Kr,
  DOCTYPE_NAME: Aa,
  CUSTOM_ELEMENT: Jr
});
const Qr = function() {
  return typeof window > "u" ? null : window;
}, eo = function(e, t) {
  if (typeof e != "object" || typeof e.createPolicy != "function")
    return null;
  let n = null;
  const s = "data-tt-policy-suffix";
  t && t.hasAttribute(s) && (n = t.getAttribute(s));
  const a = "dompurify" + (n ? "#" + n : "");
  try {
    return e.createPolicy(a, {
      createHTML(i) {
        return i;
      },
      createScriptURL(i) {
        return i;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + a + " could not be created."), null;
  }
};
function wa() {
  let o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Qr();
  const e = (U) => wa(U);
  if (e.version = "3.1.0", e.removed = [], !o || !o.document || o.document.nodeType !== 9)
    return e.isSupported = !1, e;
  let {
    document: t
  } = o;
  const n = t, s = n.currentScript, {
    DocumentFragment: a,
    HTMLTemplateElement: i,
    Node: r,
    Element: l,
    NodeFilter: c,
    NamedNodeMap: d = o.NamedNodeMap || o.MozNamedAttrMap,
    HTMLFormElement: p,
    DOMParser: h,
    trustedTypes: u
  } = o, g = l.prototype, m = Pt(g, "cloneNode"), E = Pt(g, "nextSibling"), O = Pt(g, "childNodes"), x = Pt(g, "parentNode");
  if (typeof i == "function") {
    const U = t.createElement("template");
    U.content && U.content.ownerDocument && (t = U.content.ownerDocument);
  }
  let y, w = "";
  const {
    implementation: A,
    createNodeIterator: L,
    createDocumentFragment: I,
    getElementsByTagName: P
  } = t, {
    importNode: W
  } = n;
  let k = {};
  e.isSupported = typeof Ta == "function" && typeof x == "function" && A && A.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: C,
    ERB_EXPR: V,
    TMPLIT_EXPR: F,
    DATA_ATTR: M,
    ARIA_ATTR: J,
    IS_SCRIPT_OR_DATA: me,
    ATTR_WHITESPACE: q,
    CUSTOM_ELEMENT: H
  } = Rs;
  let {
    IS_ALLOWED_URI: ae
  } = Rs, ce = null;
  const gt = Z({}, [...Ms, ...un, ...pn, ...gn, ...Cs]);
  let re = null;
  const Ke = Z({}, [..._s, ...mn, ...Is, ...Nt]);
  let Q = Object.seal(xa(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), Fe = null, $ = null, K = !0, se = !0, oe = !1, fe = !0, Ie = !1, _ = !0, R = !1, N = !1, Re = !1, Je = !1, At = !1, wt = !1, Zn = !0, Yn = !1;
  const ka = "user-content-";
  let Kt = !0, mt = !1, Qe = {}, et = null;
  const qn = Z({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let Kn = null;
  const Jn = Z({}, ["audio", "video", "img", "source", "image", "track"]);
  let Jt = null;
  const Qn = Z({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), Mt = "http://www.w3.org/1998/Math/MathML", Ct = "http://www.w3.org/2000/svg", Ne = "http://www.w3.org/1999/xhtml";
  let tt = Ne, Qt = !1, en = null;
  const Da = Z({}, [Mt, Ct, Ne], hn);
  let ft = null;
  const Pa = ["application/xhtml+xml", "text/html"], Na = "text/html";
  let ue = null, nt = null;
  const Va = t.createElement("form"), es = function(b) {
    return b instanceof RegExp || b instanceof Function;
  }, tn = function() {
    let b = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!(nt && nt === b)) {
      if ((!b || typeof b != "object") && (b = {}), b = Ye(b), ft = // eslint-disable-next-line unicorn/prefer-includes
      Pa.indexOf(b.PARSER_MEDIA_TYPE) === -1 ? Na : b.PARSER_MEDIA_TYPE, ue = ft === "application/xhtml+xml" ? hn : Gt, ce = De(b, "ALLOWED_TAGS") ? Z({}, b.ALLOWED_TAGS, ue) : gt, re = De(b, "ALLOWED_ATTR") ? Z({}, b.ALLOWED_ATTR, ue) : Ke, en = De(b, "ALLOWED_NAMESPACES") ? Z({}, b.ALLOWED_NAMESPACES, hn) : Da, Jt = De(b, "ADD_URI_SAFE_ATTR") ? Z(
        Ye(Qn),
        // eslint-disable-line indent
        b.ADD_URI_SAFE_ATTR,
        // eslint-disable-line indent
        ue
        // eslint-disable-line indent
      ) : Qn, Kn = De(b, "ADD_DATA_URI_TAGS") ? Z(
        Ye(Jn),
        // eslint-disable-line indent
        b.ADD_DATA_URI_TAGS,
        // eslint-disable-line indent
        ue
        // eslint-disable-line indent
      ) : Jn, et = De(b, "FORBID_CONTENTS") ? Z({}, b.FORBID_CONTENTS, ue) : qn, Fe = De(b, "FORBID_TAGS") ? Z({}, b.FORBID_TAGS, ue) : {}, $ = De(b, "FORBID_ATTR") ? Z({}, b.FORBID_ATTR, ue) : {}, Qe = De(b, "USE_PROFILES") ? b.USE_PROFILES : !1, K = b.ALLOW_ARIA_ATTR !== !1, se = b.ALLOW_DATA_ATTR !== !1, oe = b.ALLOW_UNKNOWN_PROTOCOLS || !1, fe = b.ALLOW_SELF_CLOSE_IN_ATTR !== !1, Ie = b.SAFE_FOR_TEMPLATES || !1, _ = b.SAFE_FOR_XML !== !1, R = b.WHOLE_DOCUMENT || !1, Je = b.RETURN_DOM || !1, At = b.RETURN_DOM_FRAGMENT || !1, wt = b.RETURN_TRUSTED_TYPE || !1, Re = b.FORCE_BODY || !1, Zn = b.SANITIZE_DOM !== !1, Yn = b.SANITIZE_NAMED_PROPS || !1, Kt = b.KEEP_CONTENT !== !1, mt = b.IN_PLACE || !1, ae = b.ALLOWED_URI_REGEXP || La, tt = b.NAMESPACE || Ne, Q = b.CUSTOM_ELEMENT_HANDLING || {}, b.CUSTOM_ELEMENT_HANDLING && es(b.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (Q.tagNameCheck = b.CUSTOM_ELEMENT_HANDLING.tagNameCheck), b.CUSTOM_ELEMENT_HANDLING && es(b.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (Q.attributeNameCheck = b.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), b.CUSTOM_ELEMENT_HANDLING && typeof b.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (Q.allowCustomizedBuiltInElements = b.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), Ie && (se = !1), At && (Je = !0), Qe && (ce = Z({}, Cs), re = [], Qe.html === !0 && (Z(ce, Ms), Z(re, _s)), Qe.svg === !0 && (Z(ce, un), Z(re, mn), Z(re, Nt)), Qe.svgFilters === !0 && (Z(ce, pn), Z(re, mn), Z(re, Nt)), Qe.mathMl === !0 && (Z(ce, gn), Z(re, Is), Z(re, Nt))), b.ADD_TAGS && (ce === gt && (ce = Ye(ce)), Z(ce, b.ADD_TAGS, ue)), b.ADD_ATTR && (re === Ke && (re = Ye(re)), Z(re, b.ADD_ATTR, ue)), b.ADD_URI_SAFE_ATTR && Z(Jt, b.ADD_URI_SAFE_ATTR, ue), b.FORBID_CONTENTS && (et === qn && (et = Ye(et)), Z(et, b.FORBID_CONTENTS, ue)), Kt && (ce["#text"] = !0), R && Z(ce, ["html", "head", "body"]), ce.table && (Z(ce, ["tbody"]), delete Fe.tbody), b.TRUSTED_TYPES_POLICY) {
        if (typeof b.TRUSTED_TYPES_POLICY.createHTML != "function")
          throw St('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof b.TRUSTED_TYPES_POLICY.createScriptURL != "function")
          throw St('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        y = b.TRUSTED_TYPES_POLICY, w = y.createHTML("");
      } else
        y === void 0 && (y = eo(u, s)), y !== null && typeof w == "string" && (w = y.createHTML(""));
      be && be(b), nt = b;
    }
  }, ts = Z({}, ["mi", "mo", "mn", "ms", "mtext"]), ns = Z({}, ["foreignobject", "desc", "title", "annotation-xml"]), Ba = Z({}, ["title", "style", "font", "a", "script"]), ss = Z({}, [...un, ...pn, ...Fr]), as = Z({}, [...gn, ...zr]), Ga = function(b) {
    let D = x(b);
    (!D || !D.tagName) && (D = {
      namespaceURI: tt,
      tagName: "template"
    });
    const G = Gt(b.tagName), ee = Gt(D.tagName);
    return en[b.namespaceURI] ? b.namespaceURI === Ct ? D.namespaceURI === Ne ? G === "svg" : D.namespaceURI === Mt ? G === "svg" && (ee === "annotation-xml" || ts[ee]) : !!ss[G] : b.namespaceURI === Mt ? D.namespaceURI === Ne ? G === "math" : D.namespaceURI === Ct ? G === "math" && ns[ee] : !!as[G] : b.namespaceURI === Ne ? D.namespaceURI === Ct && !ns[ee] || D.namespaceURI === Mt && !ts[ee] ? !1 : !as[G] && (Ba[G] || !ss[G]) : !!(ft === "application/xhtml+xml" && en[b.namespaceURI]) : !1;
  }, Ve = function(b) {
    Et(e.removed, {
      element: b
    });
    try {
      b.parentNode.removeChild(b);
    } catch {
      b.remove();
    }
  }, nn = function(b, D) {
    try {
      Et(e.removed, {
        attribute: D.getAttributeNode(b),
        from: D
      });
    } catch {
      Et(e.removed, {
        attribute: null,
        from: D
      });
    }
    if (D.removeAttribute(b), b === "is" && !re[b])
      if (Je || At)
        try {
          Ve(D);
        } catch {
        }
      else
        try {
          D.setAttribute(b, "");
        } catch {
        }
  }, is = function(b) {
    let D = null, G = null;
    if (Re)
      b = "<remove></remove>" + b;
    else {
      const ye = ws(b, /^[\r\n\t ]+/);
      G = ye && ye[0];
    }
    ft === "application/xhtml+xml" && tt === Ne && (b = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + b + "</body></html>");
    const ee = y ? y.createHTML(b) : b;
    if (tt === Ne)
      try {
        D = new h().parseFromString(ee, ft);
      } catch {
      }
    if (!D || !D.documentElement) {
      D = A.createDocument(tt, "template", null);
      try {
        D.documentElement.innerHTML = Qt ? w : ee;
      } catch {
      }
    }
    const ve = D.body || D.documentElement;
    return b && G && ve.insertBefore(t.createTextNode(G), ve.childNodes[0] || null), tt === Ne ? P.call(D, R ? "html" : "body")[0] : R ? D.documentElement : ve;
  }, rs = function(b) {
    return L.call(
      b.ownerDocument || b,
      b,
      // eslint-disable-next-line no-bitwise
      c.SHOW_ELEMENT | c.SHOW_COMMENT | c.SHOW_TEXT | c.SHOW_PROCESSING_INSTRUCTION | c.SHOW_CDATA_SECTION,
      null
    );
  }, Ha = function(b) {
    return b instanceof p && (typeof b.nodeName != "string" || typeof b.textContent != "string" || typeof b.removeChild != "function" || !(b.attributes instanceof d) || typeof b.removeAttribute != "function" || typeof b.setAttribute != "function" || typeof b.namespaceURI != "string" || typeof b.insertBefore != "function" || typeof b.hasChildNodes != "function");
  }, os = function(b) {
    return typeof r == "function" && b instanceof r;
  }, Be = function(b, D, G) {
    k[b] && Dt(k[b], (ee) => {
      ee.call(e, D, G, nt);
    });
  }, ls = function(b) {
    let D = null;
    if (Be("beforeSanitizeElements", b, null), Ha(b))
      return Ve(b), !0;
    const G = ue(b.nodeName);
    if (Be("uponSanitizeElement", b, {
      tagName: G,
      allowedTags: ce
    }), b.hasChildNodes() && !os(b.firstElementChild) && Te(/<[/\w]/g, b.innerHTML) && Te(/<[/\w]/g, b.textContent) || b.nodeType === 7 || _ && b.nodeType === 8 && Te(/<[/\w]/g, b.data))
      return Ve(b), !0;
    if (!ce[G] || Fe[G]) {
      if (!Fe[G] && ds(G) && (Q.tagNameCheck instanceof RegExp && Te(Q.tagNameCheck, G) || Q.tagNameCheck instanceof Function && Q.tagNameCheck(G)))
        return !1;
      if (Kt && !et[G]) {
        const ee = x(b) || b.parentNode, ve = O(b) || b.childNodes;
        if (ve && ee) {
          const ye = ve.length;
          for (let Se = ye - 1; Se >= 0; --Se)
            ee.insertBefore(m(ve[Se], !0), E(b));
        }
      }
      return Ve(b), !0;
    }
    return b instanceof l && !Ga(b) || (G === "noscript" || G === "noembed" || G === "noframes") && Te(/<\/no(script|embed|frames)/i, b.innerHTML) ? (Ve(b), !0) : (Ie && b.nodeType === 3 && (D = b.textContent, Dt([C, V, F], (ee) => {
      D = bt(D, ee, " ");
    }), b.textContent !== D && (Et(e.removed, {
      element: b.cloneNode()
    }), b.textContent = D)), Be("afterSanitizeElements", b, null), !1);
  }, cs = function(b, D, G) {
    if (Zn && (D === "id" || D === "name") && (G in t || G in Va))
      return !1;
    if (!(se && !$[D] && Te(M, D))) {
      if (!(K && Te(J, D))) {
        if (!re[D] || $[D]) {
          if (
            // First condition does a very basic check if a) it's basically a valid custom element tagname AND
            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
            !(ds(b) && (Q.tagNameCheck instanceof RegExp && Te(Q.tagNameCheck, b) || Q.tagNameCheck instanceof Function && Q.tagNameCheck(b)) && (Q.attributeNameCheck instanceof RegExp && Te(Q.attributeNameCheck, D) || Q.attributeNameCheck instanceof Function && Q.attributeNameCheck(D)) || // Alternative, second condition checks if it's an `is`-attribute, AND
            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            D === "is" && Q.allowCustomizedBuiltInElements && (Q.tagNameCheck instanceof RegExp && Te(Q.tagNameCheck, G) || Q.tagNameCheck instanceof Function && Q.tagNameCheck(G)))
          )
            return !1;
        } else if (!Jt[D]) {
          if (!Te(ae, bt(G, q, ""))) {
            if (!((D === "src" || D === "xlink:href" || D === "href") && b !== "script" && Gr(G, "data:") === 0 && Kn[b])) {
              if (!(oe && !Te(me, bt(G, q, "")))) {
                if (G)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, ds = function(b) {
    return b !== "annotation-xml" && ws(b, H);
  }, hs = function(b) {
    Be("beforeSanitizeAttributes", b, null);
    const {
      attributes: D
    } = b;
    if (!D)
      return;
    const G = {
      attrName: "",
      attrValue: "",
      keepAttr: !0,
      allowedAttributes: re
    };
    let ee = D.length;
    for (; ee--; ) {
      const ve = D[ee], {
        name: ye,
        namespaceURI: Se,
        value: We
      } = ve, vt = ue(ye);
      let Oe = ye === "value" ? We : Hr(We);
      if (G.attrName = vt, G.attrValue = Oe, G.keepAttr = !0, G.forceKeepAttr = void 0, Be("uponSanitizeAttribute", b, G), Oe = G.attrValue, G.forceKeepAttr || (nn(ye, b), !G.keepAttr))
        continue;
      if (!fe && Te(/\/>/i, Oe)) {
        nn(ye, b);
        continue;
      }
      Ie && Dt([C, V, F], (ps) => {
        Oe = bt(Oe, ps, " ");
      });
      const us = ue(b.nodeName);
      if (cs(us, vt, Oe)) {
        if (Yn && (vt === "id" || vt === "name") && (nn(ye, b), Oe = ka + Oe), y && typeof u == "object" && typeof u.getAttributeType == "function" && !Se)
          switch (u.getAttributeType(us, vt)) {
            case "TrustedHTML": {
              Oe = y.createHTML(Oe);
              break;
            }
            case "TrustedScriptURL": {
              Oe = y.createScriptURL(Oe);
              break;
            }
          }
        try {
          Se ? b.setAttributeNS(Se, ye, Oe) : b.setAttribute(ye, Oe), As(e.removed);
        } catch {
        }
      }
    }
    Be("afterSanitizeAttributes", b, null);
  }, $a = function U(b) {
    let D = null;
    const G = rs(b);
    for (Be("beforeSanitizeShadowDOM", b, null); D = G.nextNode(); )
      Be("uponSanitizeShadowNode", D, null), !ls(D) && (D.content instanceof a && U(D.content), hs(D));
    Be("afterSanitizeShadowDOM", b, null);
  };
  return e.sanitize = function(U) {
    let b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, D = null, G = null, ee = null, ve = null;
    if (Qt = !U, Qt && (U = "<!-->"), typeof U != "string" && !os(U))
      if (typeof U.toString == "function") {
        if (U = U.toString(), typeof U != "string")
          throw St("dirty is not a string, aborting");
      } else
        throw St("toString is not a function");
    if (!e.isSupported)
      return U;
    if (N || tn(b), e.removed = [], typeof U == "string" && (mt = !1), mt) {
      if (U.nodeName) {
        const We = ue(U.nodeName);
        if (!ce[We] || Fe[We])
          throw St("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (U instanceof r)
      D = is("<!---->"), G = D.ownerDocument.importNode(U, !0), G.nodeType === 1 && G.nodeName === "BODY" || G.nodeName === "HTML" ? D = G : D.appendChild(G);
    else {
      if (!Je && !Ie && !R && // eslint-disable-next-line unicorn/prefer-includes
      U.indexOf("<") === -1)
        return y && wt ? y.createHTML(U) : U;
      if (D = is(U), !D)
        return Je ? null : wt ? w : "";
    }
    D && Re && Ve(D.firstChild);
    const ye = rs(mt ? U : D);
    for (; ee = ye.nextNode(); )
      ls(ee) || (ee.content instanceof a && $a(ee.content), hs(ee));
    if (mt)
      return U;
    if (Je) {
      if (At)
        for (ve = I.call(D.ownerDocument); D.firstChild; )
          ve.appendChild(D.firstChild);
      else
        ve = D;
      return (re.shadowroot || re.shadowrootmode) && (ve = W.call(n, ve, !0)), ve;
    }
    let Se = R ? D.outerHTML : D.innerHTML;
    return R && ce["!doctype"] && D.ownerDocument && D.ownerDocument.doctype && D.ownerDocument.doctype.name && Te(Aa, D.ownerDocument.doctype.name) && (Se = "<!DOCTYPE " + D.ownerDocument.doctype.name + `>
` + Se), Ie && Dt([C, V, F], (We) => {
      Se = bt(Se, We, " ");
    }), y && wt ? y.createHTML(Se) : Se;
  }, e.setConfig = function() {
    let U = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    tn(U), N = !0;
  }, e.clearConfig = function() {
    nt = null, N = !1;
  }, e.isValidAttribute = function(U, b, D) {
    nt || tn({});
    const G = ue(U), ee = ue(b);
    return cs(G, ee, D);
  }, e.addHook = function(U, b) {
    typeof b == "function" && (k[U] = k[U] || [], Et(k[U], b));
  }, e.removeHook = function(U) {
    if (k[U])
      return As(k[U]);
  }, e.removeHooks = function(U) {
    k[U] && (k[U] = []);
  }, e.removeAllHooks = function() {
    k = {};
  }, e;
}
var zn = wa();
const Vt = (o) => zn.sanitize(o, {
  USE_PROFILES: {
    html: !0,
    svg: !0,
    svgFilters: !0
  }
}), to = (o) => zn.sanitize(o, {
  NAMESPACE: "http://www.w3.org/2000/svg",
  USE_PROFILES: {
    html: !0,
    svg: !0,
    svgFilters: !0
  }
}), Pe = (o) => zn.sanitize(o, { ALLOWED_TAGS: [] }), jt = class jt extends Y {
  constructor() {
    super(...arguments), this.type = "toolbar", this.renderType = j.HTML;
  }
  init() {
    const e = () => this.updateOverflowMenu(!1);
    this.services.events.addEventListener(f.Toolbar.SHOW_OVERFLOW_MENU, () => {
      this.renderOverflowMenu(), document.body.addEventListener("click", e);
    }), this.services.events.addEventListener(f.Toolbar.HIDE_OVERFLOW_MENU, () => {
      document.body.removeEventListener("click", e);
    });
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e = !0) {
    const t = this.getComponentContainer().attr("role", "toolbar").attr("aria-label", "chart toolbar");
    if (v(this.getOptions(), "data", "loading"))
      t.html(""), this.overflowMenu = null;
    else {
      this.overflowMenu || (this.overflowMenu = t.append("div").attr(
        "class",
        "cds--overflow-menu-options cds--overflow-menu--flip cds--overflow-menu-options cds--overflow-menu--flip"
      ).attr("tabindex", -1).html("<ul role='menu'></ul>"));
      const { buttonList: s, overflowMenuItemList: a } = this.getControlConfigs();
      a && s.push(this.getOverflowButtonConfig());
      const i = t.selectAll("div.toolbar-control").data(s, (c) => c.id);
      i.exit().remove();
      const r = i.enter().append("div").attr("class", "toolbar-control cds--overflow-menu cds--overflow-menu"), l = this;
      r.merge(i).classed("disabled", (c) => c.shouldBeDisabled()).attr("role", "button").attr("aria-disabled", (c) => c.shouldBeDisabled()).attr("aria-label", (c) => c.title).html((c) => `
			<button
				class="cds--overflow-menu__trigger cds--overflow-menu__trigger"
				aria-haspopup="true" aria-expanded="false" id="${this.services.domUtils.generateElementIDString(
        `control-${Pe(c.id)}`
      )}" aria-label="${Pe(c.title)}">
				<svg focusable="false" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg" class="cds--overflow-menu__icon cds--overflow-menu__icon" viewBox="0 0 32 32" aria-hidden="true">
					${to(c.iconSVG.content)}
				</svg>
			</button>`).each(function(c, d) {
        T(this).select("svg").style("pointer-events", "none").style("will-change", "transform").style("width", c.iconSVG.width !== void 0 ? c.iconSVG.width : "20px").style("height", c.iconSVG.height !== void 0 ? c.iconSVG.height : "20px"), T(this).select("button").on("mouseover focus", function(p) {
          const h = T(this);
          h.classed("hovered", !0), l.services.events.dispatchEvent(f.Toolbar.SHOW_TOOLTIP, {
            event: p,
            hoveredElement: h,
            content: c.title,
            noWrap: !0,
            placements: ["top", "bottom"]
          });
        }).on("mouseout blur", function() {
          l.services.events.dispatchEvent(f.Toolbar.HIDE_TOOLTIP);
        }).on("click", (p) => {
          c.shouldBeDisabled() || l.triggerFunctionAndEvent(c, p, this);
        }).on("keydown", (p) => {
          p.key && p.key === "Enter" || p.key === " " ? (p.preventDefault(), l.triggerFunctionAndEvent(c, p, this)) : p.key && p.key === "ArrowLeft" ? l.focusOnPreviousEnabledToolbarItem(d) : p.key && p.key === "ArrowRight" && l.focusOnNextEnabledToolbarItem(d);
        });
      }), this.overflowButton = this.getComponentContainer().select(
        `button.cds--overflow-menu__trigger#${this.services.domUtils.generateElementIDString(
          "control-toolbar-overflow-menu"
        )}`
      );
    }
  }
  renderOverflowMenu() {
    const { overflowMenuItemList: e } = this.getControlConfigs(), t = this.overflowMenu.select("ul").selectAll("li.cds--overflow-menu-options__option").data(e, (s) => v(s, "id"));
    t.exit().remove();
    const n = t.enter().append("li").attr("id", (s) => this.services.domUtils.generateElementIDString(`control-${s.id}`)).attr("class", "cds--overflow-menu-options__option cds--overflow-menu-options__option").attr("role", "menuitem").attr("tabindex", 1);
    n.append("button").attr("class", "cds--overflow-menu-options__btn cds--overflow-menu-options__btn"), n.merge(t).classed("cds--overflow-menu-options__option--disabled", (s) => s.shouldBeDisabled()).classed("cds--overflow-menu-options__option--disabled", (s) => s.shouldBeDisabled()).attr("aria-disabled", (s) => s.shouldBeDisabled()).selectAll("button").text((s) => s.title);
  }
  isOverflowMenuOpen() {
    return this.overflowMenu.classed("is-open");
  }
  // show/hide overflow menu
  updateOverflowMenu(e) {
    this.overflowMenu && (this.overflowMenu.classed("is-open", e), this.overflowButton && (this.overflowButton.attr("aria-expanded", e), T(this.overflowButton.node().parentNode).classed("cds--overflow-menu--open", e).classed("cds--overflow-menu--open", e)), e ? this.services.events.dispatchEvent(f.Toolbar.SHOW_OVERFLOW_MENU) : this.services.events.dispatchEvent(f.Toolbar.HIDE_OVERFLOW_MENU));
  }
  // Toolbar controllers
  focusOnPreviousEnabledToolbarItem(e) {
    const t = this.getToolbarButtonItems();
    let n = t.length;
    for (let s = e - 1; s >= 0; s--)
      if (!t[s].shouldBeDisabled()) {
        n = s;
        break;
      }
    if (n < t.length) {
      const s = T(
        `button#${this.services.domUtils.generateElementIDString(
          `control-${t[n].id}`
        )}`
      ).node();
      "focus" in s && s.focus();
    }
  }
  focusOnNextEnabledToolbarItem(e) {
    const t = this.getToolbarButtonItems();
    let n = -1;
    for (let s = e + 1; s < t.length; s++)
      if (!t[s].shouldBeDisabled()) {
        n = s;
        break;
      }
    if (n > -1) {
      const s = T(
        `button#${this.services.domUtils.generateElementIDString(
          `control-${t[n].id}`
        )}`
      ).node();
      "focus" in s && s.focus();
    }
  }
  focusOnPreviousEnabledMenuItem(e) {
    const t = this.getOverflowMenuItems();
    let n = t.length;
    for (let s = e - 1; s >= 0; s--)
      if (!t[s].shouldBeDisabled()) {
        n = s;
        break;
      }
    if (n < t.length) {
      const s = T(
        `#${this.services.domUtils.generateElementIDString(
          `control-${t[n].id}`
        )} button`
      ).node();
      "focus" in s && s.focus();
    }
  }
  focusOnNextEnabledMenuItem(e) {
    const t = this.getOverflowMenuItems();
    let n = -1;
    for (let s = e + 1; s < t.length; s++)
      if (!t[s].shouldBeDisabled()) {
        n = s;
        break;
      }
    if (n > -1) {
      const s = T(
        `#${this.services.domUtils.generateElementIDString(
          `control-${t[n].id}`
        )} button`
      ).node();
      "focus" in s && s.focus();
    }
  }
  toggleOverflowMenu(e) {
    if (this.isOverflowMenuOpen())
      this.updateOverflowMenu(!1);
    else {
      this.updateOverflowMenu(!0);
      const t = this;
      this.getOverflowMenuItems().forEach((s, a) => {
        const i = T(
          `#${this.services.domUtils.generateElementIDString(`control-${s.id}`)}`
        );
        i !== null && (i.on("click", () => {
          t.triggerFunctionAndEvent(s, e, i.node()), t.updateOverflowMenu(!1);
        }), i.on("keydown", (r) => {
          r && r.key === "Enter" ? t.triggerFunctionAndEvent(s, e, i.node()) : r && r.key === "ArrowUp" ? t.focusOnPreviousEnabledMenuItem(a) : r && r.key === "ArrowDown" ? t.focusOnNextEnabledMenuItem(a) : r && r.key === "Escape" && t.updateOverflowMenu(!1), r.preventDefault();
        }));
      }), t.focusOnNextEnabledMenuItem(-1);
    }
    e && e.stopImmediatePropagation();
  }
  // Calls passed function && dispatches event
  triggerFunctionAndEvent(e, t, n) {
    typeof e.shouldBeDisabled == "function" && e.shouldBeDisabled() || (typeof e.clickFunction == "function" && e.clickFunction(t), this.services.events.dispatchEvent(f.Toolbar.BUTTON_CLICK, {
      control: e,
      event: t,
      element: n
    }));
  }
  getControlConfigs() {
    const e = v(this.getOptions(), "toolbar", "numberOfIcons") - 1, t = v(this.getOptions(), "toolbar", "controls"), n = [], s = [], a = [];
    return t.forEach((i) => {
      let r = null;
      if (i.type === ie.CUSTOM)
        v(i, "id") === null && (i.id = `toolbar-button-${jt.buttonID++}`), v(i, "shouldBeDisabled") === null && (i.shouldBeDisabled = () => !1), r = i;
      else {
        const l = this.services.domUtils.isFullScreenMode();
        i.type === ie.MAKE_FULLSCREEN && l ? i.type = ie.EXIT_FULLSCREEN : i.type === ie.EXIT_FULLSCREEN && !l && (i.type = ie.MAKE_FULLSCREEN), r = this.getControlConfigByType(i.type);
      }
      r && (r.text = i.text ? i.text : i.type, r.id.indexOf("toolbar-export") !== -1 ? n.push(r) : s.length < e ? v(r, "iconSVG", "content") === null ? a.push(r) : s.push(r) : a.push(r));
    }), a.push(...n), a.length ? {
      buttonList: s,
      overflowMenuItemList: a
    } : {
      buttonList: s
    };
  }
  getToolbarButtonItems() {
    const { buttonList: e, overflowMenuItemList: t } = this.getControlConfigs();
    return t && e.push(this.getOverflowButtonConfig()), e || [];
  }
  getOverflowMenuItems() {
    const { overflowMenuItemList: e } = this.getControlConfigs();
    return e || [];
  }
  // special button config for overflow button
  getOverflowButtonConfig() {
    const { moreOptions: e } = v(this.model.getOptions(), "locale", "translations", "toolbar");
    return {
      id: "toolbar-overflow-menu",
      title: e,
      shouldBeDisabled: () => !1,
      iconSVG: {
        content: `<circle cx="16" cy="8" r="2"></circle>
				<circle cx="16" cy="16" r="2"></circle>
				<circle cx="16" cy="24" r="2"></circle>`
      },
      clickFunction: (t) => this.toggleOverflowMenu(t)
    };
  }
  getControlConfigByType(e) {
    const t = this.services.zoom && this.services.zoom.isZoomBarEnabled() && !this.services.zoom.isEmptyState(), n = this.model.getDisplayData(), s = this.model.getOptions(), {
      exportAsCSV: a,
      exportAsJPG: i,
      exportAsPNG: r,
      zoomIn: l,
      zoomOut: c,
      resetZoom: d,
      makeFullScreen: p,
      exitFullScreen: h,
      showAsTable: u
    } = v(
      s,
      "locale",
      "translations",
      "toolbar"
    );
    let g;
    switch (e) {
      case ie.ZOOM_IN:
        t && (g = {
          id: "toolbar-zoomIn",
          title: l,
          shouldBeDisabled: () => this.services.zoom.isMinZoomDomain(),
          iconSVG: {
            content: this.getControlIconByType(e)
          },
          clickFunction: () => this.services.zoom.zoomIn()
        });
        break;
      case ie.ZOOM_OUT:
        t && (g = {
          id: "toolbar-zoomOut",
          title: c,
          shouldBeDisabled: () => this.services.zoom.isMaxZoomDomain(),
          iconSVG: {
            content: this.getControlIconByType(e)
          },
          clickFunction: () => this.services.zoom.zoomOut()
        });
        break;
      case ie.RESET_ZOOM:
        t && (g = {
          id: "toolbar-resetZoom",
          title: d,
          shouldBeDisabled: () => this.services.zoom.isMaxZoomDomain(),
          iconSVG: {
            content: this.getControlIconByType(e)
          },
          clickFunction: () => this.services.zoom.resetZoomDomain()
        });
        break;
      case ie.MAKE_FULLSCREEN:
        g = {
          id: "toolbar-makefullscreen",
          iconSVG: {
            content: this.getControlIconByType(e),
            width: "15px",
            height: "15px"
          },
          title: p,
          shouldBeDisabled: () => !1,
          clickFunction: () => {
            this.services.domUtils.toggleFullscreen();
          }
        };
        break;
      case ie.EXIT_FULLSCREEN:
        g = {
          id: "toolbar-exitfullscreen",
          iconSVG: {
            content: this.getControlIconByType(e),
            width: "15px",
            height: "15px"
          },
          title: h,
          shouldBeDisabled: () => !1,
          clickFunction: () => {
            this.services.domUtils.toggleFullscreen();
          }
        };
        break;
      case ie.SHOW_AS_DATATABLE:
        g = {
          id: "toolbar-showasdatatable",
          iconSVG: {
            content: this.getControlIconByType(e)
          },
          title: u,
          shouldBeDisabled: () => n.length === 0,
          clickFunction: () => this.services.events.dispatchEvent(f.Modal.SHOW)
        };
        break;
      case ie.EXPORT_CSV:
        g = {
          id: "toolbar-export-CSV",
          title: a,
          shouldBeDisabled: () => !1,
          iconSVG: {
            content: this.getControlIconByType(e)
          },
          clickFunction: () => this.model.exportToCSV()
        };
        break;
      case ie.EXPORT_PNG:
        g = {
          id: "toolbar-export-PNG",
          title: r,
          shouldBeDisabled: () => !1,
          iconSVG: {
            content: this.getControlIconByType(e)
          },
          clickFunction: () => this.services.domUtils.exportToPNG()
        };
        break;
      case ie.EXPORT_JPG:
        g = {
          id: "toolbar-export-JPG",
          title: i,
          shouldBeDisabled: () => !1,
          iconSVG: {
            content: this.getControlIconByType(e)
          },
          clickFunction: () => this.services.domUtils.exportToJPG()
        };
        break;
      default:
        throw Error("Not supported toolbar control type: " + e);
    }
    return g;
  }
  getControlIconByType(e) {
    switch (e) {
      case ie.ZOOM_IN:
        return `<polygon points="19 13 15 13 15 9 13 9 13 13 9 13 9 15 13 15 13 19 15 19 15 15 19 15 19 13"/>
						<path d="M22.45,21A10.87,10.87,0,0,0,25,14,11,11,0,1,0,14,25a10.87,10.87,0,0,0,7-2.55L28.59,30,30,28.59ZM14,23a9,9,0,1,1,9-9A9,9,0,0,1,14,23Z"/>`;
      case ie.ZOOM_OUT:
        return `<rect x="9" y="13" width="10" height="2"/>
						<path d="M22.45,21A10.87,10.87,0,0,0,25,14,11,11,0,1,0,14,25a10.87,10.87,0,0,0,7-2.55L28.59,30,30,28.59ZM14,23a9,9,0,1,1,9-9A9,9,0,0,1,14,23Z"/>`;
      case ie.RESET_ZOOM:
        return '<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>';
      case ie.MAKE_FULLSCREEN:
        return '<polygon points="21 2 21 4 26.59 4 17 13.58 18.41 15 28 5.41 28 11 30 11 30 2 21 2"/><polygon points="15 18.42 13.59 17 4 26.59 4 21 2 21 2 30 11 30 11 28 5.41 28 15 18.42"/>';
      case ie.EXIT_FULLSCREEN:
        return '<polygon points="4 18 4 20 10.586 20 2 28.582 3.414 30 12 21.414 12 28 14 28 14 18 4 18"/><polygon points="30 3.416 28.592 2 20 10.586 20 4 18 4 18 14 28 14 28 12 21.414 12 30 3.416"/>';
      case ie.SHOW_AS_DATATABLE:
        return '<rect x="4" y="6" width="18" height="2"/><rect x="4" y="12" width="18" height="2"/><rect x="4" y="18" width="18" height="2"/><rect x="4" y="24" width="18" height="2"/><rect x="26" y="6" width="2" height="2"/><rect x="26" y="12" width="2" height="2"/><rect x="26" y="18" width="2" height="2"/><rect x="26" y="24" width="2" height="2"/>';
      case ie.EXPORT_CSV:
        return '<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>';
      case ie.EXPORT_JPG:
        return '<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>';
      case ie.EXPORT_PNG:
        return '<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>';
      default:
        throw Error("Not supported toolbar control type: " + e);
    }
  }
};
jt.buttonID = 0;
let ks = jt;
const Xt = class Xt extends Y {
  constructor(e, t, n, s) {
    super(e, t, s), this.type = "layout", this.configs = s, this.children = n, this._instanceID = Xt.instanceID++, this.init();
  }
  init() {
    this.children.forEach((e) => {
      e.components.forEach((t) => {
        t.init();
      });
    });
  }
  getPreferedAndFixedSizeSum() {
    const e = this.parent;
    let t = 0;
    return e.selectAll(`div.layout-child-${this._instanceID}`).filter((n) => {
      const s = v(n, "growth");
      return s === ze.PREFERRED || s === ze.FIXED;
    }).each(function(n) {
      t += n.size;
    }), t;
  }
  getNumOfStretchChildren() {
    return this.parent.selectAll(`div.layout-child-${this._instanceID}`).filter((t) => v(t, "growth") === ze.STRETCH).size();
  }
  render(e = !0) {
    const t = this.parent, { width: n, height: s } = S.getHTMLElementSize(t.node()), a = this.configs.direction === st.ROW || this.configs.direction === st.ROW_REVERSE, i = v(this.model.getOptions(), "style", "prefix"), r = t.classed(
      `${Me}--${i}--layout-row`,
      this.configs.direction === st.ROW
    ).classed(
      `${Me}--${i}--layout-row-reverse`,
      this.configs.direction === st.ROW_REVERSE
    ).classed(
      `${Me}--${i}--layout-column`,
      this.configs.direction === st.COLUMN
    ).classed(
      `${Me}--${i}--layout-column-reverse`,
      this.configs.direction === st.COLUMN_REVERSE
    ).classed(
      `${Me}--${i}--layout-alignitems-center`,
      this.configs.alignItems === wi.CENTER
    ).selectAll(`div.layout-child-${this._instanceID}`).data(this.children, (d) => d.id);
    r.enter().append("div").merge(t.selectAll(`div.layout-child-${this._instanceID}`)).attr("class", (d) => `layout-child layout-child-${this._instanceID} ${d.id}`).each(function(d) {
      d.components.forEach((p) => {
        const h = T(this), g = v(d, "renderType") === j.SVG;
        p.setParent(
          g ? S.appendOrSelect(h, "svg.layout-svg-wrapper").attr("width", "100%").attr("height", "100%") : h
        );
        const m = v(d, "growth");
        (m === ze.PREFERRED || m === ze.FIXED) && p.render(e);
      });
    }), t.selectAll(`div.layout-child-${this._instanceID}`).style("height", null).style("width", null).each(function(d) {
      const p = v(d, "growth"), u = v(d, "renderType") === j.SVG ? S.getSVGElementSize(T(this).select("svg.layout-svg-wrapper"), {
        useBBox: !0
      }) : S.getHTMLElementSize(this);
      if (p === ze.PREFERRED) {
        const g = a ? u.width : u.height, m = a ? n : s;
        d.size = g / m * 100;
      }
    }), r.exit().remove(), this.children.filter((d) => v(d, "growth") === ze.STRETCH).forEach((d) => {
      d.size = (100 - +this.getPreferedAndFixedSizeSum()) / +this.getNumOfStretchChildren();
    });
    const c = t.selectAll(`div.layout-child-${this._instanceID}`).data(this.children, (d) => d.id);
    a ? c.style("width", (d) => `${d.size / 100 * n}px`).style("height", "100%") : c.style("height", (d) => `${d.size / 100 * s}px`).style("width", "100%"), c.each(function(d) {
      d.components.forEach((p) => {
        v(d, "growth") === ze.STRETCH && p.render(e);
      });
    });
  }
  // Pass on model to children as well
  setModel(e) {
    super.setModel(e), this.children.forEach((t) => {
      t.components.forEach((n) => n.setModel(e));
    });
  }
  // Pass on essentials to children as well
  setServices(e) {
    super.setServices(e), this.children.forEach((t) => {
      t.components.forEach((n) => n.setServices(e));
    });
  }
  destroy() {
    this.children.forEach((e) => {
      e.components.forEach((t) => t.destroy());
    });
  }
};
Xt.instanceID = Math.floor(Math.random() * 99999999999);
let Ds = Xt;
class fh extends Y {
  constructor() {
    super(...arguments), this.type = "spacer";
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e = !1) {
    this.getComponentContainer().style("width", `${this.configs.size || gs.default.size}px`).style("height", `${this.configs.size || gs.default.size}px`).attr("opacity", 0);
  }
}
var no = {
  prefix: "bx",
  selectorTabbable: `
    a[href], area[href], input:not([disabled]):not([tabindex='-1']),
    button:not([disabled]):not([tabindex='-1']),select:not([disabled]):not([tabindex='-1']),
    textarea:not([disabled]):not([tabindex='-1']),
    iframe, object, embed, *[tabindex]:not([tabindex='-1']), *[contenteditable=true]
  `,
  selectorFocusable: `
    a[href], area[href], input:not([disabled]),
    button:not([disabled]),select:not([disabled]),
    textarea:not([disabled]),
    iframe, object, embed, *[tabindex], *[contenteditable=true]
  `
}, fn = no;
function Ps(o, e) {
  for (var t = 0; t < e.length; t++) {
    var n = e[t];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(o, n.key, n);
  }
}
function so(o, e, t) {
  return e && Ps(o.prototype, e), t && Ps(o, t), Object.defineProperty(o, "prototype", {
    writable: !1
  }), o;
}
function ao(o, e) {
  if (!(o instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function io(o) {
  return co(o) || lo(o) || oo(o) || ro();
}
function ro() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function oo(o, e) {
  if (o) {
    if (typeof o == "string")
      return Tn(o, e);
    var t = Object.prototype.toString.call(o).slice(8, -1);
    if (t === "Object" && o.constructor && (t = o.constructor.name), t === "Map" || t === "Set")
      return Array.from(o);
    if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))
      return Tn(o, e);
  }
}
function lo(o) {
  if (typeof Symbol < "u" && o[Symbol.iterator] != null || o["@@iterator"] != null)
    return Array.from(o);
}
function co(o) {
  if (Array.isArray(o))
    return Tn(o);
}
function Tn(o, e) {
  (e == null || e > o.length) && (e = o.length);
  for (var t = 0, n = new Array(e); t < e; t++)
    n[t] = o[t];
  return n;
}
function Ma(o) {
  return o.reduce(function(e, t) {
    return Array.isArray(t) ? e.push.apply(e, io(Ma(t))) : e.push(t), e;
  }, []);
}
function ho() {
  for (var o = arguments.length, e = new Array(o), t = 0; t < o; t++)
    e[t] = arguments[t];
  return Ma(e).reduce(function(n, s) {
    return s(n);
  }, /* @__PURE__ */ function() {
    function n() {
      ao(this, n);
    }
    return so(n);
  }());
}
function xn(o) {
  "@babel/helpers - typeof";
  return xn = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, xn(o);
}
function uo(o, e) {
  if (!(o instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function Ns(o, e) {
  for (var t = 0; t < e.length; t++) {
    var n = e[t];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(o, n.key, n);
  }
}
function po(o, e, t) {
  return e && Ns(o.prototype, e), t && Ns(o, t), Object.defineProperty(o, "prototype", {
    writable: !1
  }), o;
}
function go(o, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  o.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: o,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(o, "prototype", {
    writable: !1
  }), e && Ln(o, e);
}
function Ln(o, e) {
  return Ln = Object.setPrototypeOf || function(n, s) {
    return n.__proto__ = s, n;
  }, Ln(o, e);
}
function mo(o) {
  var e = vo();
  return function() {
    var n = $t(o), s;
    if (e) {
      var a = $t(this).constructor;
      s = Reflect.construct(n, arguments, a);
    } else
      s = n.apply(this, arguments);
    return fo(this, s);
  };
}
function fo(o, e) {
  if (e && (xn(e) === "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return Ca(o);
}
function Ca(o) {
  if (o === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return o;
}
function vo() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function $t(o) {
  return $t = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, $t(o);
}
function yo(o) {
  var e = /* @__PURE__ */ function(t) {
    go(s, t);
    var n = mo(s);
    function s(a) {
      var i, r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (uo(this, s), i = n.call(this, a, r), i.children = [], !a || a.nodeType !== Node.ELEMENT_NODE)
        throw new TypeError("DOM element should be given to initialize this widget.");
      return i.element = a, i.options = Object.assign(Object.create(i.constructor.options), r), i.constructor.components.set(i.element, Ca(i)), i;
    }
    return po(s, [{
      key: "release",
      value: (
        /**
         * Releases this component's instance from the associated element.
         */
        function() {
          for (var i = this.children.pop(); i; i = this.children.pop())
            i.release();
          return this.constructor.components.delete(this.element), null;
        }
      )
    }], [{
      key: "create",
      value: function(i, r) {
        return this.components.get(i) || new this(i, r);
      }
    }]), s;
  }(o);
  return e;
}
function An(o) {
  "@babel/helpers - typeof";
  return An = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, An(o);
}
function Eo(o, e) {
  if (!(o instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function Vs(o, e) {
  for (var t = 0; t < e.length; t++) {
    var n = e[t];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(o, n.key, n);
  }
}
function bo(o, e, t) {
  return e && Vs(o.prototype, e), t && Vs(o, t), Object.defineProperty(o, "prototype", {
    writable: !1
  }), o;
}
function Ht() {
  return typeof Reflect < "u" && Reflect.get ? Ht = Reflect.get : Ht = function(e, t, n) {
    var s = So(e, t);
    if (s) {
      var a = Object.getOwnPropertyDescriptor(s, t);
      return a.get ? a.get.call(arguments.length < 3 ? e : n) : a.value;
    }
  }, Ht.apply(this, arguments);
}
function So(o, e) {
  for (; !Object.prototype.hasOwnProperty.call(o, e) && (o = pt(o), o !== null); )
    ;
  return o;
}
function Oo(o, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  o.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: o,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(o, "prototype", {
    writable: !1
  }), e && wn(o, e);
}
function wn(o, e) {
  return wn = Object.setPrototypeOf || function(n, s) {
    return n.__proto__ = s, n;
  }, wn(o, e);
}
function To(o) {
  var e = Ao();
  return function() {
    var n = pt(o), s;
    if (e) {
      var a = pt(this).constructor;
      s = Reflect.construct(n, arguments, a);
    } else
      s = n.apply(this, arguments);
    return xo(this, s);
  };
}
function xo(o, e) {
  if (e && (An(e) === "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return Lo(o);
}
function Lo(o) {
  if (o === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return o;
}
function Ao() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function pt(o) {
  return pt = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, pt(o);
}
function wo(o) {
  var e = /* @__PURE__ */ function(t) {
    Oo(s, t);
    var n = To(s);
    function s() {
      var a;
      Eo(this, s);
      for (var i = arguments.length, r = new Array(i), l = 0; l < i; l++)
        r[l] = arguments[l];
      return a = n.call.apply(n, [this].concat(r)), a.handles = /* @__PURE__ */ new Set(), a;
    }
    return bo(s, [{
      key: "manage",
      value: (
        /**
         * Manages the given handle.
         * @param {Handle} handle The handle to manage.
         * @returns {Handle} The given handle.
         */
        function(i) {
          return this.handles.add(i), i;
        }
      )
      /**
       * Stop managing the given handle.
       * @param {Handle} handle The handle to stop managing.
       * @returns {Handle} The given handle.
       */
    }, {
      key: "unmanage",
      value: function(i) {
        return this.handles.delete(i), i;
      }
    }, {
      key: "release",
      value: function() {
        var i = this;
        return this.handles.forEach(function(r) {
          r.release(), i.handles.delete(r);
        }), Ht(pt(s.prototype), "release", this).call(this);
      }
    }]), s;
  }(o);
  return e;
}
function Tt(o) {
  for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++)
    t[n - 1] = arguments[n];
  return o.addEventListener.apply(o, t), {
    release: function() {
      return o.removeEventListener.apply(o, t), null;
    }
  };
}
function Mn(o) {
  "@babel/helpers - typeof";
  return Mn = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Mn(o);
}
function Mo(o) {
  return Ro(o) || Io(o) || _o(o) || Co();
}
function Co() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _o(o, e) {
  if (o) {
    if (typeof o == "string")
      return Cn(o, e);
    var t = Object.prototype.toString.call(o).slice(8, -1);
    if (t === "Object" && o.constructor && (t = o.constructor.name), t === "Map" || t === "Set")
      return Array.from(o);
    if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))
      return Cn(o, e);
  }
}
function Io(o) {
  if (typeof Symbol < "u" && o[Symbol.iterator] != null || o["@@iterator"] != null)
    return Array.from(o);
}
function Ro(o) {
  if (Array.isArray(o))
    return Cn(o);
}
function Cn(o, e) {
  (e == null || e > o.length) && (e = o.length);
  for (var t = 0, n = new Array(e); t < e; t++)
    n[t] = o[t];
  return n;
}
function ko(o, e) {
  if (!(o instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function Bs(o, e) {
  for (var t = 0; t < e.length; t++) {
    var n = e[t];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(o, n.key, n);
  }
}
function Do(o, e, t) {
  return e && Bs(o.prototype, e), t && Bs(o, t), Object.defineProperty(o, "prototype", {
    writable: !1
  }), o;
}
function Po(o, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  o.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: o,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(o, "prototype", {
    writable: !1
  }), e && _n(o, e);
}
function _n(o, e) {
  return _n = Object.setPrototypeOf || function(n, s) {
    return n.__proto__ = s, n;
  }, _n(o, e);
}
function No(o) {
  var e = Go();
  return function() {
    var n = Ut(o), s;
    if (e) {
      var a = Ut(this).constructor;
      s = Reflect.construct(n, arguments, a);
    } else
      s = n.apply(this, arguments);
    return Vo(this, s);
  };
}
function Vo(o, e) {
  if (e && (Mn(e) === "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return Bo(o);
}
function Bo(o) {
  if (o === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return o;
}
function Go() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Ut(o) {
  return Ut = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, Ut(o);
}
function Ho(o) {
  var e = /* @__PURE__ */ function(t) {
    Po(s, t);
    var n = No(s);
    function s() {
      return ko(this, s), n.apply(this, arguments);
    }
    return Do(s, [{
      key: "_changeState",
      value: (
        /* eslint-disable jsdoc/check-param-names */
        /**
         * The internal implementation for {@link EventedState#changeState `.changeState()`}, performing actual change in state.
         * @param {string} [state] The new state. Can be an omitted, which means toggling.
         * @param {object} [detail]
         *   The object that should be put to event details that is fired before/after changing state.
         *   Can have a `group` property, which specifies what state to be changed.
         * @param {EventedState~changeStateCallback} callback The callback called once changing state is finished or is canceled.
         * @private
         */
        function() {
          throw new Error("_changeState() should be overridden to perform actual change in state.");
        }
      )
      /**
       * Changes the state of this component.
       * @param {string} [state] The new state. Can be an omitted, which means toggling.
       * @param {object} [detail]
       *   The object that should be put to event details that is fired before/after changing state.
       *   Can have a `group` property, which specifies what state to be changed.
       * @param {EventedState~changeStateCallback} [callback] The callback called once changing state is finished or is canceled.
       */
    }, {
      key: "changeState",
      value: function() {
        for (var i = this, r = arguments.length, l = new Array(r), c = 0; c < r; c++)
          l[c] = arguments[c];
        var d = typeof l[0] == "string" ? l.shift() : void 0, p = Object(l[0]) === l[0] && typeof l[0] != "function" ? l.shift() : void 0, h = typeof l[0] == "function" ? l.shift() : void 0;
        if (typeof this.shouldStateBeChanged == "function" && !this.shouldStateBeChanged(d, p)) {
          h && h(null, !0);
          return;
        }
        var u = {
          group: p && p.group,
          state: d
        }, g = [u.group, d].filter(Boolean).join("-").split("-").map(function(w) {
          return w[0].toUpperCase() + w.substr(1);
        }).join(""), m = new CustomEvent(this.options["eventBefore".concat(g)], {
          bubbles: !0,
          cancelable: !0,
          detail: p
        }), E = p && p.delegatorNode || this.element, O = !E.dispatchEvent(m);
        if (O) {
          if (h) {
            var x = new Error("Changing state (".concat(JSON.stringify(u), ") has been canceled."));
            x.canceled = !0, h(x);
          }
        } else {
          var y = [d, p].filter(Boolean);
          this._changeState.apply(this, Mo(y).concat([function() {
            E.dispatchEvent(new CustomEvent(i.options["eventAfter".concat(g)], {
              bubbles: !0,
              cancelable: !0,
              detail: p
            })), h && h();
          }]));
        }
      }
      /* eslint-enable jsdoc/check-param-names */
      /**
       * Tests if change in state should happen or not.
       * Classes inheriting {@link EventedState `EventedState`} should override this function.
       * @function EventedState#shouldStateBeChanged
       * @param {string} [state] The new state. Can be an omitted, which means toggling.
       * @param {object} [detail]
       *   The object that should be put to event details that is fired before/after changing state.
       *   Can have a `group` property, which specifies what state to be changed.
       * @returns {boolean}
       *   `false` if change in state shouldn't happen, e.g. when the given new state is the same as the current one.
       */
    }]), s;
  }(o);
  return e;
}
function In(o, e) {
  var t = o.target, n = o.currentTarget;
  if (typeof t.matches == "function") {
    if (t.matches(e))
      return t;
    if (t.matches("".concat(e, " *"))) {
      var s = t.closest(e);
      if ((n.nodeType === Node.DOCUMENT_NODE ? n.documentElement : n).contains(s))
        return s;
    }
  }
}
function Gs(o) {
  if (!o || typeof o == "function")
    return {
      launchingElement: null,
      launchingEvent: null
    };
  var e = o.delegateTarget || o.currentTarget || o, t = o.currentTarget && o;
  if (e && !e.nodeType)
    throw new TypeError("DOM Node should be given for launching element.");
  if (t && !t.type)
    throw new TypeError("DOM event should be given for launching event.");
  return {
    launchingElement: e,
    launchingEvent: t
  };
}
function Rn(o) {
  "@babel/helpers - typeof";
  return Rn = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Rn(o);
}
function $o(o, e) {
  if (!(o instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function Hs(o, e) {
  for (var t = 0; t < e.length; t++) {
    var n = e[t];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(o, n.key, n);
  }
}
function Uo(o, e, t) {
  return e && Hs(o.prototype, e), t && Hs(o, t), Object.defineProperty(o, "prototype", {
    writable: !1
  }), o;
}
function Fo(o, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  o.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: o,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(o, "prototype", {
    writable: !1
  }), e && kn(o, e);
}
function kn(o, e) {
  return kn = Object.setPrototypeOf || function(n, s) {
    return n.__proto__ = s, n;
  }, kn(o, e);
}
function zo(o) {
  var e = Xo();
  return function() {
    var n = Ft(o), s;
    if (e) {
      var a = Ft(this).constructor;
      s = Reflect.construct(n, arguments, a);
    } else
      s = n.apply(this, arguments);
    return Wo(this, s);
  };
}
function Wo(o, e) {
  if (e && (Rn(e) === "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return jo(o);
}
function jo(o) {
  if (o === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return o;
}
function Xo() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Ft(o) {
  return Ft = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, Ft(o);
}
function Zo(o) {
  var e = /* @__PURE__ */ function(t) {
    Fo(s, t);
    var n = zo(s);
    function s() {
      return $o(this, s), n.apply(this, arguments);
    }
    return Uo(s, [{
      key: "show",
      value: (
        /**
         */
        /**
         * Switch to 'shown' state.
         * @param [evtOrElem] The launching event or element.
         * @param {EventedState~changeStateCallback} [callback] The callback.
         */
        function(i, r) {
          (!i || typeof i == "function") && (r = i), this.changeState("shown", Gs(i), r);
        }
      )
      /**
       * Switch to 'hidden' state.
       * @param [evtOrElem] The launching event or element.
       * @param {EventedState~changeStateCallback} [callback] The callback.
       */
    }, {
      key: "hide",
      value: function(i, r) {
        (!i || typeof i == "function") && (r = i), this.changeState("hidden", Gs(i), r);
      }
    }]), s;
  }(o);
  return e;
}
var Yo = [Ho, Zo];
const qo = Yo;
function Ko(o) {
  return o && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") ? o.default : o;
}
var _a = function() {
};
process.env.NODE_ENV !== "production" && (_a = function(o, e, t) {
  var n = arguments.length;
  t = new Array(n > 2 ? n - 2 : 0);
  for (var s = 2; s < n; s++)
    t[s - 2] = arguments[s];
  if (e === void 0)
    throw new Error(
      "`warning(condition, format, ...args)` requires a warning message argument"
    );
  if (e.length < 10 || /^[s\W]*$/.test(e))
    throw new Error(
      "The warning format should be able to uniquely identify this warning. Please, use a more descriptive format than: " + e
    );
  if (!o) {
    var a = 0, i = "Warning: " + e.replace(/%s/g, function() {
      return t[a++];
    });
    typeof console < "u" && console.error(i);
    try {
      throw new Error(i);
    } catch {
    }
  }
});
var Jo = _a;
const Qo = /* @__PURE__ */ Ko(Jo);
function Dn(o) {
  "@babel/helpers - typeof";
  return Dn = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Dn(o);
}
function el(o, e) {
  if (!(o instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function $s(o, e) {
  for (var t = 0; t < e.length; t++) {
    var n = e[t];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(o, n.key, n);
  }
}
function tl(o, e, t) {
  return e && $s(o.prototype, e), t && $s(o, t), Object.defineProperty(o, "prototype", {
    writable: !1
  }), o;
}
function nl(o, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  o.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: o,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(o, "prototype", {
    writable: !1
  }), e && Pn(o, e);
}
function Pn(o, e) {
  return Pn = Object.setPrototypeOf || function(n, s) {
    return n.__proto__ = s, n;
  }, Pn(o, e);
}
function sl(o) {
  var e = rl();
  return function() {
    var n = zt(o), s;
    if (e) {
      var a = zt(this).constructor;
      s = Reflect.construct(n, arguments, a);
    } else
      s = n.apply(this, arguments);
    return al(this, s);
  };
}
function al(o, e) {
  if (e && (Dn(e) === "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return il(o);
}
function il(o) {
  if (o === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return o;
}
function rl() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function zt(o) {
  return zt = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, zt(o);
}
function ol(o) {
  var e = /* @__PURE__ */ function(t) {
    nl(s, t);
    var n = sl(s);
    function s() {
      return el(this, s), n.apply(this, arguments);
    }
    return tl(s, null, [{
      key: "init",
      value: (
        /**
         * `true` suggests that this component is lazily initialized upon an action/event, etc.
         * @type {boolean}
         */
        /**
         * Instantiates this component in the given element.
         * If the given element indicates that it's an component of this class, instantiates it.
         * Otherwise, instantiates this component by clicking on launcher buttons
         * (buttons with attribute that `options.attribInitTarget` points to) of this component in the given node.
         * @param {Node} target The DOM node to instantiate this component in. Should be a document or an element.
         * @param {object} [options] The component options.
         * @param {string} [options.selectorInit] The CSS selector to find this component.
         * @param {string} [options.attribInitTarget] The attribute name in the launcher buttons to find target component.
         * @returns {Handle} The handle to remove the event listener to handle clicking.
         */
        function() {
          var i = this, r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : document, l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, c = Object.assign(Object.create(this.options), l);
          if (!r || r.nodeType !== Node.ELEMENT_NODE && r.nodeType !== Node.DOCUMENT_NODE)
            throw new TypeError("DOM document or DOM element should be given to search for and initialize this widget.");
          if (r.nodeType === Node.ELEMENT_NODE && r.matches(c.selectorInit))
            this.create(r, l);
          else {
            var d = c.initEventNames.map(function(p) {
              return Tt(r, p, function(h) {
                var u = In(h, "[".concat(c.attribInitTarget, "]"));
                if (u) {
                  h.delegateTarget = u;
                  var g = u.ownerDocument.querySelectorAll(u.getAttribute(c.attribInitTarget));
                  if (g.length > 1)
                    throw new Error("Target widget must be unique.");
                  if (g.length === 1) {
                    u.tagName === "A" && h.preventDefault();
                    var m = i.create(g[0], l);
                    typeof m.createdByLauncher == "function" && m.createdByLauncher(h);
                  }
                }
              });
            });
            return {
              release: function() {
                for (var h = d.pop(); h; h = d.pop())
                  h.release();
              }
            };
          }
          return "";
        }
      )
    }]), s.forLazyInit = !0, s;
  }(o);
  return e;
}
function Nn(o) {
  "@babel/helpers - typeof";
  return Nn = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Nn(o);
}
function ll(o, e) {
  if (!(o instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function Us(o, e) {
  for (var t = 0; t < e.length; t++) {
    var n = e[t];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(o, n.key, n);
  }
}
function cl(o, e, t) {
  return e && Us(o.prototype, e), t && Us(o, t), Object.defineProperty(o, "prototype", {
    writable: !1
  }), o;
}
function dl(o, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  o.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: o,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(o, "prototype", {
    writable: !1
  }), e && Vn(o, e);
}
function Vn(o, e) {
  return Vn = Object.setPrototypeOf || function(n, s) {
    return n.__proto__ = s, n;
  }, Vn(o, e);
}
function hl(o) {
  var e = gl();
  return function() {
    var n = Wt(o), s;
    if (e) {
      var a = Wt(this).constructor;
      s = Reflect.construct(n, arguments, a);
    } else
      s = n.apply(this, arguments);
    return ul(this, s);
  };
}
function ul(o, e) {
  if (e && (Nn(e) === "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return pl(o);
}
function pl(o) {
  if (o === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return o;
}
function gl() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Wt(o) {
  return Wt = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, Wt(o);
}
var ml = /* @__PURE__ */ function(o) {
  dl(t, o);
  var e = hl(t);
  function t(n, s) {
    var a;
    return ll(this, t), a = e.call(this, n, s), a._handleFocusinListener = void 0, a._handleKeydownListener = void 0, a._handleFocusin = function(i) {
      var r = a.element.querySelector(a.options.selectorModalContainer) || a.element;
      a.element.classList.contains(a.options.classVisible) && !r.contains(i.target) && a.options.selectorsFloatingMenus.every(function(l) {
        return !In(i, l);
      }) && a.element.querySelector(fn.selectorTabbable).focus();
    }, a._hookCloseActions(), a;
  }
  return cl(t, [{
    key: "createdByLauncher",
    value: (
      /**
       * A method that runs when `.init()` is called from `initComponentByLauncher`.
       * @param {Event} evt The event fired on the launcher button.
       */
      function(s) {
        this.show(s);
      }
    )
    /**
     * Determines whether or not to emit events and callback function when `.changeState()` is called from `eventedState`.
     * @param {string} state The new state.
     * @returns {boolean} `true` if the given `state` is different from current state.
     */
  }, {
    key: "shouldStateBeChanged",
    value: function(s) {
      return s === "shown" ? !this.element.classList.contains(this.options.classVisible) : this.element.classList.contains(this.options.classVisible);
    }
    /**
     * Changes the shown/hidden state.
     * @private
     * @param {string} state The new state.
     * @param {object} detail The detail data to be included in the event that will be fired.
     * @param {Function} callback Callback called when change in state completes.
     */
  }, {
    key: "_changeState",
    value: function(s, a, i) {
      var r = this, l, c = function() {
        if (l && (l = r.unmanage(l).release()), s === "shown" && r.element.offsetWidth > 0 && r.element.offsetHeight > 0) {
          r.previouslyFocusedNode = r.element.ownerDocument.activeElement;
          var u = r.element.querySelector(r.options.selectorPrimaryFocus) || r.element.querySelector(fn.selectorTabbable);
          u.focus(), process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "production" && Qo(u, "Modals need to contain a focusable element by either using " + "`".concat(r.options.selectorPrimaryFocus, "` or settings.selectorTabbable."));
        }
        i();
      };
      if (this._handleFocusinListener && (this._handleFocusinListener = this.unmanage(this._handleFocusinListener).release()), s === "shown") {
        var d = "onfocusin" in this.element.ownerDocument.defaultView, p = d ? "focusin" : "focus";
        this._handleFocusinListener = this.manage(Tt(this.element.ownerDocument, p, this._handleFocusin, !d));
      }
      s === "hidden" ? (this.element.classList.toggle(this.options.classVisible, !1), this.element.ownerDocument.body.classList.toggle(this.options.classBody, !1), (this.options.selectorFocusOnClose || this.previouslyFocusedNode) && (this.element.ownerDocument.querySelector(this.options.selectorFocusOnClose) || this.previouslyFocusedNode).focus()) : s === "shown" && (this.element.classList.toggle(this.options.classVisible, !0), this.element.ownerDocument.body.classList.toggle(this.options.classBody, !0)), l = this.manage(Tt(this.element, "transitionend", c));
    }
  }, {
    key: "_hookCloseActions",
    value: function() {
      var s = this;
      this.manage(Tt(this.element, "click", function(a) {
        var i = In(a, s.options.selectorModalClose);
        i && (a.delegateTarget = i), (i || a.target === s.element) && s.hide(a);
      })), this._handleKeydownListener && (this._handleKeydownListener = this.unmanage(this._handleKeydownListener).release()), this._handleKeydownListener = this.manage(Tt(this.element.ownerDocument.body, "keydown", function(a) {
        a.which === 27 && s.shouldStateBeChanged("hidden") && (a.stopPropagation(), s.hide(a));
      }));
    }
    /**
     * Handles `focusin` (or `focus` depending on browser support of `focusin`) event to do wrap-focus behavior.
     * @param {Event} evt The event.
     * @private
     */
  }], [{
    key: "options",
    get: (
      /**
       * The component options.
       * If `options` is specified in the constructor, {@linkcode Modal.create .create()}, or {@linkcode Modal.init .init()},
       * properties in this object are overridden for the instance being create and how {@linkcode Modal.init .init()} works.
       * @member Modal.options
       * @type {object}
       * @property {string} selectorInit The CSS class to find modal dialogs.
       * @property {string} [selectorModalClose] The selector to find elements that close the modal.
       * @property {string} [selectorPrimaryFocus] The CSS selector to determine the element to put focus when modal gets open.
       * @property {string} [selectorFocusOnClose] The CSS selector to determine the element to put focus when modal closes.
       *   If undefined, focus returns to the previously focused element prior to the modal opening.
       * @property {string} [selectorModalContainer] The CSS selector for the content container of the modal for focus wrap feature.
       * @property {string} attribInitTarget The attribute name in the launcher buttons to find target modal dialogs.
       * @property {string[]} [selectorsFloatingMenu]
       *   The CSS selectors of floating menus.
       *   Used for detecting if focus-wrap behavior should be disabled temporarily.
       * @property {string} [classVisible] The CSS class for the visible state.
       * @property {string} [classBody] The CSS class for `<body>` with open modal.
       * @property {string} [classNoScroll] The CSS class for hiding scroll bar in body element while modal is shown.
       * @property {string} [eventBeforeShown]
       *   The name of the custom event fired before this modal is shown.
       *   Cancellation of this event stops showing the modal.
       * @property {string} [eventAfterShown]
       *   The name of the custom event telling that modal is sure shown
       *   without being canceled by the event handler named by `eventBeforeShown` option (`modal-beingshown`).
       * @property {string} [eventBeforeHidden]
       *   The name of the custom event fired before this modal is hidden.
       *   Cancellation of this event stops hiding the modal.
       * @property {string} [eventAfterHidden]
       *   The name of the custom event telling that modal is sure hidden
       *   without being canceled by the event handler named by `eventBeforeHidden` option (`modal-beinghidden`).
       */
      function() {
        var s = fn.prefix;
        return {
          selectorInit: "[data-modal]",
          selectorModalClose: "[data-modal-close]",
          selectorPrimaryFocus: "[data-modal-primary-focus]",
          selectorsFloatingMenus: [".".concat(s, "--overflow-menu-options"), ".".concat(s, "--tooltip"), ".flatpickr-calendar"],
          selectorModalContainer: ".".concat(s, "--modal-container"),
          classVisible: "is-visible",
          classBody: "".concat(s, "--body--with-modal-open"),
          attribInitTarget: "data-modal-target",
          initEventNames: ["click"],
          eventBeforeShown: "modal-beingshown",
          eventAfterShown: "modal-shown",
          eventBeforeHidden: "modal-beinghidden",
          eventAfterHidden: "modal-hidden"
        };
      }
    )
  }]), t.components = /* @__PURE__ */ new WeakMap(), t;
}(ho(yo, ol, qo, wo));
class vh extends Y {
  constructor(e, t, n) {
    super(e, t, n), this.type = "modal", this.isEventListenerAdded = !1, this.handleShowModal = () => {
      const s = this.services.domUtils.getChartID();
      this.modal.attr("data-modal", !0).attr("class", "cds--modal").attr("role", "dialog").attr("aria-modal", !0).attr("aria-labelledby", `${s}__modal-title`).attr("aria-describedby", `${s}__modal-description`).attr("tabindex", -1), this.modal.html(this.getModalHTML()), this.modal.select("div.cds--modal-footer button.cds--btn").on("click", () => this.model.exportToCSV()), ml.create(this.modal.node()).show(), document.addEventListener("modal-hidden", this.handleHideModal);
    }, this.handleHideModal = () => {
      this.modal.attr("role", null).attr("aria-modal", null).attr("aria-labelledby", null).attr("aria-describedby", null).attr("tabindex", null), document.removeEventListener("modal-hidden", this.handleHideModal);
    }, this.init();
  }
  addEventListeners() {
    this.services.events.addEventListener(f.Modal.SHOW, this.handleShowModal);
  }
  removeEventListeners() {
    this.services.events.removeEventListener(f.Modal.SHOW, this.handleShowModal);
  }
  getModalHTML() {
    const e = this.services.domUtils.getChartID(), t = this.model.getOptions(), { title: n, downloadAsCSV: s } = v(t, "locale", "translations", "tabularRep"), a = v(t, "style", "prefix"), i = this.model.getTabularDataArray();
    return `
		<div class="cds--modal-container">
			<div class="cds--modal-header">

				<p class="cds--modal-header__label cds--type-delta" id="modal-title">${n}</p>

				<p class="cds--modal-header__heading cds--type-beta" id="${e}__modal-description">${Pe(
      t.title
    )}</p>

				<button class="cds--modal-close" type="button" data-modal-close aria-label="close modal"  data-modal-primary-focus>
					<svg focusable="false" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg" fill="currentColor" aria-label="Close" width="20" height="20" viewBox="0 0 32 32" role="img" class="cds--modal-close__icon">
						<path d="M24 9.4L22.6 8 16 14.6 9.4 8 8 9.4 14.6 16 8 22.6 9.4 24 16 17.4 22.6 24 24 22.6 17.4 16 24 9.4z"></path>
					</svg>
				</button>
			</div>

			<div class="cds--modal-content">
				<table class="cds--data-table cds--data-table--no-border">
					<thead>
						<tr>
							${ne(i, 0).map(
      (r) => `<th scope="col">
								<div class="cds--table-header-label">${Pe(r)}</div>
							</th>`
    ).join("")}
						</tr>
					</thead>

					<tbody>${i.slice(1).map(
      (r) => `
							<tr>
								${r.map((l) => `<td>${Pe(l)}</td>`).join("")}
							</tr>`
    ).join("")}
					</tbody>
				</table>
			</div>

			<div class="cds--modal-footer">
			  <div class="${Me}--${a}-modal-footer-spacer"></div>
			  <button class="cds--btn cds--btn--primary" type="button" data-modal-primary-focus>${s}</button>
			</div>
		</div>`;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e = !1) {
    const t = this.model.getOptions();
    if (!this.isEventListenerAdded) {
      const n = T(this.services.domUtils.getHolder()), s = v(t, "style", "prefix");
      this.modal = S.appendOrSelect(n, `div.${Me}--${s}--modal`), this.addEventListeners(), this.isEventListenerAdded = !0;
    }
  }
  destroy() {
    this.removeEventListeners(), this.isEventListenerAdded = !1;
  }
}
class fl extends Y {
  constructor() {
    super(...arguments), this.type = "title", this.renderType = j.HTML;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e = !1) {
    const t = this.getComponentContainer(), n = v(this.getOptions(), "title"), s = t.selectAll("p.title").data([n]);
    if (s.enter().append("p").classed("title", !0).attr("role", "heading").attr("aria-level", 2).merge(s).html((a) => Pe(a)), s.node() && s.node().offsetWidth < s.node().scrollWidth) {
      const a = this;
      s.on("mouseover", function(i) {
        a.services.events.dispatchEvent(f.Tooltip.SHOW, {
          event: i,
          hoveredElement: s,
          content: s.text()
        });
      }).on("mousemove", function(i) {
        a.services.events.dispatchEvent(f.Tooltip.MOVE, {
          event: i
        });
      }).on("mouseout", function() {
        a.services.events.dispatchEvent(f.Tooltip.HIDE);
      });
    }
    s.exit().remove();
  }
  /**
   * Truncates title creating ellipses and attaching tooltip for exposing full title.
   */
  truncateTitle(e, t) {
    if (t <= 0)
      return;
    const n = e.text();
    if (e.node().getComputedTextLength() > t) {
      e.append("tspan").text("...");
      const s = S.appendOrSelect(e, "tspan").node().getComputedTextLength(), a = e.text(), i = this.getSubstringIndex(
        e.node(),
        0,
        a.length - 1,
        t - s
      );
      e.html(a.substring(0, i - 1)).append("tspan").text("...");
      const r = this;
      e.on("mouseover", function(l) {
        r.services.events.dispatchEvent(f.Tooltip.SHOW, {
          event: l,
          hoveredElement: e,
          content: n
        });
      }).on("mousemove", function(l) {
        r.services.events.dispatchEvent(f.Tooltip.MOVE, {
          event: l
        });
      }).on("mouseout", function() {
        r.services.events.dispatchEvent(f.Tooltip.HIDE);
      });
    }
  }
  // computes the maximum space a title can take
  getMaxTitleWidth() {
    return S.getSVGElementSize(this.parent.node(), {
      useAttrs: !0
    }).width;
  }
  /**
   * Returns the index for a maximum length substring that is less than the width parameter.
   * @param title the title node used for getting the text lengths of substrings
   * @param start the start index for the binary search
   * @param end the end index for the binary search
   * @param width the width of the svg container that holds the title
   */
  getSubstringIndex(e, t, n, s) {
    const a = Math.floor((n + t) / 2);
    return e.getSubStringLength(0, a) > s ? this.getSubstringIndex(e, t, a, s) : e.getSubStringLength(0, a) < s ? e.getSubStringLength(0, a + 1) > s ? a : this.getSubstringIndex(e, a, n, s) : a;
  }
}
class vl extends Y {
  constructor() {
    super(...arguments), this.type = "legend", this.renderType = j.HTML;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e = !1) {
    const t = this.getOptions(), n = v(t, "legend"), s = v(n, "alignment"), a = v(t, "legend", "orientation");
    let i = this.model.getDataGroups();
    const { DISABLED: r } = he.items.status, l = i.some((x) => x.status === r), c = v(n, "order"), d = this.getComponentContainer().classed("center-aligned", s === Ce.CENTER).classed("right-aligned", s === Ce.RIGHT).classed(a, !0).classed("has-deactivated-items", l).attr("role", X.GROUP).attr("aria-label", "Data groups").attr("data-name", "legend-items");
    c && (i = this.sortDataGroups(i, c));
    const p = d.selectAll("div.legend-item").data(i, (x) => x.name), h = p.enter().append("div").attr("class", "legend-item");
    h.merge(d.selectAll("div.legend-item")).classed("active", function(x) {
      return x.status === he.items.status.ACTIVE;
    });
    const u = v(this.getOptions(), "legend", "clickable");
    d.classed("clickable", u && i.length > 1);
    const g = he.checkbox.radius, m = h.append("div").classed("checkbox", !0), E = m.merge(p.select("div.checkbox")).attr("role", X.CHECKBOX).attr("tabindex", u ? 0 : -1).attr(
      "aria-labelledby",
      (x, y) => this.services.domUtils.generateElementIDString(`legend-datagroup-${y}-title`)
    ).attr("aria-checked", ({ status: x }) => x === he.items.status.ACTIVE).attr("width", g * 2).attr("height", g * 2).attr(
      "class",
      (x) => this.model.getColorClassName({
        classNameTypes: [z.BACKGROUND],
        dataGroupName: x.name,
        originalClassName: "checkbox"
      })
    ).style(
      "background",
      (x) => x.status === he.items.status.ACTIVE ? this.model.getFillColor(x.name) || this.model.getStrokeColor(x.name) : null
    ).classed("active", function(x) {
      return x.status === he.items.status.ACTIVE;
    });
    m.append("svg").attr("focusable", !1).attr("preserveAspectRatio", "xMidYMid meet").attr("xmlns", "http://www.w3.org/2000/svg").attr("width", "11").attr("height", "11").attr("viewBox", "0 0 31 28").attr("aria-hidden", !0).style("will-change", "transform").append("path").attr("d", "M13 21.2l-7.1-7.1-1.4 1.4 7.1 7.1L13 24 27.1 9.9l-1.4-1.5z"), h.append("p").merge(p.select("p"));
    const O = v(t, "legend", "additionalItems");
    if (O && i.length) {
      const x = this, y = d.selectAll("div.additional-item").data(O);
      y.exit().remove();
      const w = y.enter().append("div").merge(y).classed("legend-item", !0).classed("additional", !0).attr(
        "aria-labelledby",
        (I, P) => this.services.domUtils.generateElementIDString(
          `legend-datagroup-${E.size() + P}-title`
        )
      );
      w.selectAll("*").remove();
      let A, L = 1;
      w.append("svg").classed("icon", !0).each(function(I) {
        const P = T(this);
        !A || A != I.type ? (A = I.type, L = 1) : L++, x.addAdditionalItem(P, I, L);
      }), w.append("p").merge(w.select("p")), this.truncateLegendText();
    }
    p.exit().on("mouseover", null).on("click", null).on("mouseout", null).remove(), u && h.size() > 1 && this.addEventListeners();
  }
  sortDataGroups(e, t) {
    if (e.sort(
      (n, s) => t.indexOf(n.name) - t.indexOf(s.name)
    ), t.length < e.length) {
      const n = e.length - t.length;
      return e.slice(n).concat(e.slice(0, n));
    }
    return e;
  }
  addAdditionalItem(e, t, n) {
    const { width: s, height: a } = he.area;
    if (t.type === Xe.RADIUS ? e.style("width", `${a}px`).style("height", `${a}px`) : e.style("width", `${s}px`).style("height", `${a}px`), t.type === Xe.RADIUS) {
      const { iconData: i, fill: r, stroke: l } = he.radius;
      e.attr("fill", "none").selectAll("circle").data(i).enter().append("circle").classed("radius", !0).attr("role", X.IMG).attr("aria-label", "radius").attr("cx", (d) => d.cx).attr("cy", (d) => d.cy).attr("r", (d) => d.r).style("fill", t.fill ? t.fill : r).style("stroke", t.stroke ? t.stroke : l);
    } else if (t.type === Xe.LINE) {
      const i = he.line;
      e.select("line.line").empty() && e.append("line").classed(`line-${n}`, !0).attr("role", X.IMG).attr("aria-label", "line").attr("x1", 0).attr("y1", i.yPosition).attr("x2", s).attr("y2", i.yPosition).style("stroke", t.stroke ? t.stroke : i.stroke).style("stroke-width", i.strokeWidth);
    } else if (t.type === Xe.AREA)
      e.select("rect.area").empty() && e.append("rect").classed(`area-${n}`, !0).attr("role", X.IMG).attr("aria-label", "area").attr("width", s).attr("height", a).style(
        "fill",
        n > 3 && !t.fill ? he.area.fill : t.fill
      ).style("stroke", t.stroke);
    else if (t.type === Xe.SIZE) {
      const { iconData: i, fill: r, stroke: l } = he.size;
      e.attr("fill", "none").attr("role", X.IMG).attr("aria-label", "size").selectAll("rect").data(i).enter().append("rect").classed("size", !0).attr("width", (d) => d.width).attr("height", (d) => d.height).attr("y", () => 0).style("fill", t.fill ? t.fill : r).style("stroke", t.stroke ? t.stroke : l).style("stroke-width", 1);
    } else if (t.type === Xe.QUARTILE) {
      const { iconData: i } = he.quartile;
      e.selectAll("rect").attr("role", X.IMG).attr("aria-label", "quartile").data(i).enter().append("rect").attr("class", (l, c) => `quartile-${c === 0 ? "wrapper" : "line"}`).attr("x", (l) => l.x).attr("y", (l) => l.y).attr("width", (l) => l.width).attr("height", (l) => l.height);
    } else if (t.type === Xe.ZOOM) {
      const { iconData: i, color: r } = v(he, "zoom"), l = e.attr("role", X.IMG).attr("aria-label", "zoom").selectAll("g.icon").data(i).enter();
      l.append("g").attr("x", (c) => c.x).attr("y", (c) => c.y).attr("width", (c) => c.width).attr("height", (c) => c.height).append("polygon").attr(
        "points",
        "7.7 4.82 5.78 4.82 5.78 2.89 4.82 2.89 4.82 4.82 2.89 4.82 2.89 5.78 4.82 5.78 4.82 7.7 5.78 7.7 5.78 5.78 7.7 5.78 7.7 4.82"
      ).attr("fill", () => t.color ? t.color : r), l.append("path").attr(
        "d",
        "M9.36,8.67A5.22,5.22,0,0,0,10.59,5.3,5.3,5.3,0,1,0,5.3,10.59,5.22,5.22,0,0,0,8.67,9.36L12.32,13l.68-.68Zm-4.06,1A4.34,4.34,0,1,1,9.63,5.3,4.33,4.33,0,0,1,5.3,9.63Z"
      ).attr("fill", () => t.color ? t.color : r);
    }
  }
  truncateLegendText() {
    const e = this.getComponentContainer(), t = v(this.getOptions(), "legend", "truncation"), n = v(t, "type"), s = v(t, "threshold"), a = v(t, "numCharacter"), i = e.selectAll("div.legend-item p");
    i.attr("id", function() {
      return (this.parentNode.querySelector("div.checkbox") || this.parentNode).getAttribute("aria-labelledby");
    }), n !== dt.NONE ? i.html(function(r) {
      const l = Pe(r.name);
      return l.length > s && l.length !== a ? xt(l, n, a) : l;
    }) : i.html((r) => Pe(r.name));
  }
  addEventListeners() {
    const e = this, t = this.getComponentContainer(), n = this.getOptions(), s = v(n, "legend"), a = v(s, "truncation");
    t.selectAll("div.legend-item").on("mouseover", function(i) {
      e.services.events.dispatchEvent(f.Legend.ITEM_HOVER, {
        hoveredElement: T(this)
      });
      const r = T(this);
      r.select("div.checkbox").classed("hovered", !0);
      const l = r.datum();
      l.name.length > a.threshold && a.numCharacter < l.name.length && a.type !== dt.NONE && e.services.events.dispatchEvent(f.Tooltip.SHOW, {
        event: i,
        hoveredElement: r,
        content: l.name
      });
    }).on("mousemove", function(i) {
      T(this).datum().name.length > a.threshold && a.type !== dt.NONE && e.services.events.dispatchEvent(f.Tooltip.MOVE, {
        event: i
      });
    }).on("click", function() {
      e.services.events.dispatchEvent(f.Legend.ITEM_CLICK, {
        clickedElement: T(this)
      });
      const r = T(this).datum();
      e.model.toggleDataLabel(r.name);
    }).on("mouseout", function() {
      const i = T(this);
      i.select("div.checkbox").classed("hovered", !1), i.datum().name.length > a.threshold && a.type !== dt.NONE && e.services.events.dispatchEvent(f.Tooltip.HIDE), e.services.events.dispatchEvent(f.Legend.ITEM_MOUSEOUT, {
        hoveredElement: i
      });
    }), t.selectAll("div.legend-item div.checkbox").on("keyup", function(i) {
      i.key && i.key === "Tab" && e.services.events.dispatchEvent(f.Legend.ITEM_HOVER, {
        hoveredElement: T(this)
      });
    }), t.selectAll("div.legend-item div.checkbox").on("keydown", function(i, r) {
      i.key && i.key === " " ? (i.preventDefault(), e.model.toggleDataLabel(r.name)) : i.key && i.key === "Tab" && e.services.events.dispatchEvent(f.Legend.ITEM_MOUSEOUT, {
        hoveredElement: T(this)
      });
    }), t.selectAll("g.additional-item").on("mouseover", function(i) {
      const r = T(this), l = r.datum();
      l.name.length > a.threshold && e.services.events.dispatchEvent(f.Tooltip.SHOW, {
        event: i,
        hoveredElement: r,
        content: l.name
      });
    });
  }
}
class yl extends Y {
  constructor(e, t, n) {
    super(e, t, n), this.type = "chart-clip", this.renderType = j.SVG, this.chartClipId = "chart-clip-id-" + Math.floor(Math.random() * 99999999999), this.init();
  }
  init() {
    this.model.set({ chartClipId: this.chartClipId }, { skipUpdate: !0 });
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e = !0) {
    this.createClipPath();
  }
  createClipPath() {
    const e = this.parent, { cartesianScales: t } = this.services;
    if (!t)
      throw new Error("Service cartesianScales was undefined");
    const n = t.getMainXScale(), s = t.getMainYScale(), [a, i] = n.range(), [r, l] = s.range();
    if (!e)
      throw new Error("svg is undefined");
    this.chartClipPath = S.appendOrSelect(
      e,
      `clipPath.${this.type}`
    ).attr("id", this.chartClipId);
    const c = S.appendOrSelect(this.chartClipPath, `rect.${this.type}`);
    i - a > 0 && c.attr("x", a).attr("y", l).attr("width", i - a).attr("height", r - l), this.chartClipPath.merge(c).lower();
  }
}
class yh extends yl {
  constructor() {
    super(...arguments), this.type = "canvas-chart-clip", this.chartClipId = "canvas-chart-clip-id-" + Math.floor(Math.random() * 99999999999);
  }
  createClipPath() {
    const e = this.parent, { width: t, height: n } = S.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    this.chartClipPath = S.appendOrSelect(e, `clipPath.${this.type}`).attr(
      "id",
      this.chartClipId
    );
    const s = S.appendOrSelect(this.chartClipPath, `rect.${this.type}`);
    s.attr("x", 0).attr("y", 0).attr("width", t).attr("height", n), this.chartClipPath.merge(s).lower();
  }
}
var rt, de;
(function(o) {
  o.LEFT = "left", o.RIGHT = "right", o.TOP = "top", o.BOTTOM = "bottom";
})(de || (de = {}));
var Fs = (rt = {}, rt[de.LEFT] = function(o, e, t) {
  return {
    top: o.top - Math.round(e.offsetHeight / 2) + Math.round(t.height / 2),
    left: Math.round(o.left - e.offsetWidth)
  };
}, rt[de.RIGHT] = function(o, e, t) {
  return {
    top: o.top - Math.round(e.offsetHeight / 2) + Math.round(t.height / 2),
    left: Math.round(o.left + t.width)
  };
}, rt[de.TOP] = function(o, e, t) {
  return {
    top: Math.round(o.top - e.offsetHeight),
    left: o.left - Math.round(e.offsetWidth / 2) + Math.round(t.width / 2)
  };
}, rt[de.BOTTOM] = function(o, e, t) {
  return {
    top: Math.round(o.top + t.height),
    left: o.left - Math.round(e.offsetWidth / 2) + Math.round(t.width / 2)
  };
}, rt), zs = typeof window < "u" ? window : {
  innerHeight: 0,
  scrollY: 0,
  innerWidth: 0,
  scrollX: 0
}, qt = (
  /** @class */
  function() {
    function o(e) {
      e === void 0 && (e = {}), this.positions = Fs, this.positions = Object.assign({}, Fs, e);
    }
    return o.prototype.getRelativeOffset = function(e) {
      for (var t = {
        left: e.offsetLeft,
        top: e.offsetTop
      }; e.offsetParent && getComputedStyle(e.offsetParent).position === "static"; )
        t.left += e.offsetLeft, t.top += e.offsetTop, e = e.offsetParent;
      return t;
    }, o.prototype.getAbsoluteOffset = function(e) {
      for (var t = e, n = {
        top: 0,
        left: 0
      }; t.offsetParent; ) {
        var s = getComputedStyle(t.offsetParent);
        s.position === "static" && s.marginLeft && s.marginTop && (parseInt(s.marginTop, 10) && (n.top += parseInt(s.marginTop, 10)), parseInt(s.marginLeft, 10) && (n.left += parseInt(s.marginLeft, 10))), t = t.offsetParent;
      }
      var a = e.getBoundingClientRect(), i = document.body.getBoundingClientRect();
      return {
        top: a.top - i.top + n.top,
        left: a.left - i.left + n.left
      };
    }, o.prototype.findRelative = function(e, t, n) {
      var s = this.getRelativeOffset(e), a = e.getBoundingClientRect();
      return this.calculatePosition(s, a, t, n);
    }, o.prototype.findAbsolute = function(e, t, n) {
      var s = this.getAbsoluteOffset(e), a = e.getBoundingClientRect();
      return this.calculatePosition(s, a, t, n);
    }, o.prototype.findPosition = function(e, t, n, s) {
      s === void 0 && (s = this.getAbsoluteOffset.bind(this));
      var a = s(e), i = e.getBoundingClientRect();
      return this.calculatePosition(a, i, t, n);
    }, o.prototype.findPositionAt = function(e, t, n) {
      return this.calculatePosition(e, { top: 0, left: 0, height: 0, width: 0 }, t, n);
    }, o.prototype.getPlacementBox = function(e, t) {
      var n = e.offsetHeight + t.top, s = e.offsetWidth + t.left;
      return {
        top: t.top,
        bottom: n,
        left: t.left,
        right: s
      };
    }, o.prototype.addOffset = function(e, t, n) {
      return t === void 0 && (t = 0), n === void 0 && (n = 0), Object.assign({}, e, {
        top: e.top + t,
        left: e.left + n
      });
    }, o.prototype.setElement = function(e, t) {
      e.style.top = t.top + "px", e.style.left = t.left + "px";
    }, o.prototype.findBestPlacement = function(e, t, n, s, a) {
      var i = this;
      s === void 0 && (s = this.defaultContainerFunction.bind(this)), a === void 0 && (a = this.findPosition.bind(this));
      var r = n.map(function(l) {
        var c = a(e, t, l), d = i.getPlacementBox(t, c), p = 0, h = 0, u = s();
        d.top < u.top ? p = u.top - d.top : d.bottom > u.height && (p = d.bottom - u.height), d.left < u.left ? h = u.left - d.left : d.right > u.width && (h = d.right - u.width), p && !h ? h = 1 : h && !p && (p = 1);
        var g = t.offsetHeight * t.offsetWidth, m = p * h, E = g - m, O = E / g;
        return {
          placement: l,
          weight: O
        };
      });
      return r.sort(function(l, c) {
        return c.weight - l.weight;
      }), r[0].placement;
    }, o.prototype.findBestPlacementAt = function(e, t, n, s) {
      var a = this;
      s === void 0 && (s = this.defaultContainerFunction.bind(this));
      var i = function(r, l, c) {
        return a.findPositionAt(e, l, c);
      };
      return this.findBestPlacement(null, t, n, s, i);
    }, o.prototype.defaultContainerFunction = function() {
      return {
        // we go with window here, because that's going to be the simple/common case
        top: 0,
        left: 0,
        height: zs.innerHeight,
        width: zs.innerWidth
      };
    }, o.prototype.calculatePosition = function(e, t, n, s) {
      return this.positions[s] ? this.positions[s](e, n, t) : (console.error("No function found for placement, defaulting to 0,0"), { left: 0, top: 0 });
    }, o;
  }()
);
new qt();
class El extends Y {
  constructor(e, t, n) {
    super(e, t, n), this.type = "tooltip", this.renderType = j.HTML, this.isEventListenerAdded = !1, this.lastTriggeredEventType = "", this.positionService = new qt(), this.handleShowTooltip = (s) => {
      const a = s.detail.data || s.detail.items;
      let i;
      const r = this.formatItems(this.getItems(s));
      s.detail.content ? i = `<div class="title-tooltip"><p>${Vt(s.detail.content)}</p></div>` : i = Vt(this.getTooltipHTML(r));
      const l = S.appendOrSelect(this.tooltip, "div.content-box");
      if (v(this.getOptions(), "tooltip", "customHTML"))
        if (s.detail.content) {
          const c = `<div class="title-tooltip"><p>${Vt(
            s.detail.content
          )}</p></div>`;
          l.html(c);
        } else
          l.html(
            `<div class="title-tooltip"><p>${Vt(
              this.model.getOptions().tooltip.customHTML(a, i)
            )}</p></div>`
          );
      else
        l.html(i);
      l.selectAll(".datapoint-tooltip").each(function(c, d) {
        const p = r[d];
        r[d] && r[d].color && T(this).select(".tooltip-color").attr("class", "tooltip-color").style("background-color", p.color);
      }), this.positionTooltip(s), this.tooltip.classed("hidden", !1).attr("aria-hidden", !1), this.lastTriggeredEventType = s.type;
    }, this.handleHideTooltip = () => {
      this.tooltip.classed("hidden", !0).attr("aria-hidden", !0);
    }, this.init();
  }
  addTooltipEventListener() {
    this.services.events.addEventListener(f.Tooltip.MOVE, (e) => {
      this.lastTriggeredEventType !== f.Toolbar.SHOW_TOOLTIP && this.tooltip.classed("hidden") === !1 && this.positionTooltip(e);
    }), this.services.events.addEventListener(f.Tooltip.SHOW, this.handleShowTooltip), this.services.events.addEventListener(f.Tooltip.HIDE, this.handleHideTooltip), this.services.events.addEventListener(f.Chart.MOUSEOUT, this.handleHideTooltip), this.services.events.addEventListener(f.Toolbar.SHOW_TOOLTIP, this.handleShowTooltip), this.services.events.addEventListener(f.Toolbar.HIDE_TOOLTIP, this.handleHideTooltip);
  }
  removeTooltipEventListener() {
    this.services.events.removeEventListener(f.Tooltip.MOVE, null), this.services.events.removeEventListener(f.Tooltip.SHOW, this.handleShowTooltip), this.services.events.removeEventListener(f.Tooltip.HIDE, this.handleHideTooltip), this.services.events.removeEventListener(f.Chart.MOUSEOUT, this.handleHideTooltip), this.services.events.removeEventListener(f.Toolbar.SHOW_TOOLTIP, this.handleShowTooltip), this.services.events.removeEventListener(f.Toolbar.HIDE_TOOLTIP, this.handleHideTooltip);
  }
  getItems(e) {
    return e.detail.items ? e.detail.items : [];
  }
  formatItems(e) {
    const t = this.getOptions(), n = v(t, "tooltip", "truncation", "type"), s = v(t, "tooltip", "truncation", "threshold"), a = v(t, "tooltip", "truncation", "numCharacter");
    return n !== dt.NONE ? e.map((i) => {
      const r = i.labelIcon ? 12 : 0;
      return i.value = i.value ? this.valueFormatter(i.value, i.label) : i.value, i.label && i.label.length + r > s && (i.label = xt(i.label, n, a)), i.value && i.value.length > s && (i.value = xt(i.value, n, a)), i;
    }) : e.map((i) => (i.value = i.value ? this.valueFormatter(i.value, i.label) : i.value, i));
  }
  getTooltipHTML(e) {
    return '<ul class="multi-tooltip">' + e.map(
      (t) => `<li>
					<div class="datapoint-tooltip${t.bold ? " bold" : ""}">
						${t.class || t.color ? `<div class="tooltip-color ${t.class}"></div>` : ""}
						<div class="label">
						<p>${t.label || ""}</p>
						${t.labelIcon ? `<span class="label-icon"/>${t.labelIcon}</span>` : ""}
						</div>
						${t.value === void 0 || t.value === null ? "" : `<p class="value"/>${t.value}</p>`}
					</div>
				</li>`
    ).join("") + "</ul>";
  }
  valueFormatter(e, t) {
    const n = this.getOptions(), s = v(n, "tooltip", "valueFormatter"), {
      code: a,
      number: i,
      date: r
    } = v(n, "locale");
    if (s)
      return s(e, t);
    if (typeof e.getTime == "function")
      return r(e, a, { month: "short", day: "numeric", year: "numeric" });
    try {
      if (typeof e == "string" && /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{3}Z/.test(e)) {
        const l = new Date(e);
        return r(l, a, {
          month: "short",
          day: "numeric",
          year: "numeric"
        });
      }
    } catch {
    }
    return i(e, a);
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e = !1) {
    const t = this.getOptions(), n = v(t, "tooltip", "enabled");
    if (n) {
      const s = T(this.services.domUtils.getHolder()), a = v(t, "style", "prefix");
      this.tooltip = S.appendOrSelect(s, `div.${Me}--${a}--tooltip`), this.tooltip.style("max-width", null).attr("role", "tooltip"), this.isEventListenerAdded || (this.addTooltipEventListener(), this.isEventListenerAdded = !0), this.tooltip.classed("hidden", !0);
    } else
      !n && this.isEventListenerAdded && (this.removeTooltipEventListener(), this.isEventListenerAdded = !1);
  }
  addOffsetByPlacement(e, t, n) {
    const s = Object.assign({}, e);
    return t == de.LEFT ? s.left -= n : t == de.RIGHT ? s.left += n : t == de.TOP ? s.top -= n : t == de.BOTTOM && (s.top += n), s;
  }
  positionTooltip(e) {
    const t = this.services.domUtils.getHolder(), n = t.offsetWidth, s = t.offsetHeight, a = this.tooltip.node(), i = this.getOptions(), r = v(i, "zoomBar", "top", "enabled"), l = !!v(e, "detail", "noWrap"), c = Array.isArray(v(e, "detail", "placements")), d = c ? v(e, "detail", "placements") : [de.RIGHT, de.LEFT, de.TOP, de.BOTTOM];
    let p, { horizontalOffset: h, defaultOffset: u } = Ya;
    if (this.tooltip.select("div.title-tooltip").classed("title-tooltip-nowrap", l), c) {
      const E = v(e, "detail", "event", "target"), O = this.services.domUtils.getElementOffset(E, !0);
      p = this.positionService.findBestPlacementAt(
        O,
        a,
        d,
        () => ({
          top: 0,
          left: 0,
          width: n,
          height: s
        })
      );
      let x = this.positionService.findPosition(
        E,
        a,
        p,
        () => this.services.domUtils.getElementOffset(E)
      );
      x = this.addOffsetByPlacement(
        x,
        p,
        u
      ), this.positionService.setElement(a, x);
      return;
    }
    let g = v(e, "detail", "mousePosition");
    if (!g)
      g = Zt(v(e, "detail", "event"), t);
    else {
      const E = v(i, "zoomBar", "top", "type"), O = we.height[E];
      r && (g[1] += O + we.spacerHeight);
    }
    g[0] / n > 0.9 ? p = de.LEFT : g[0] / n < 0.1 ? p = de.RIGHT : p = this.positionService.findBestPlacementAt(
      {
        left: g[0],
        top: g[1]
      },
      a,
      d,
      () => ({
        top: void 0,
        // properties were never set to optional (probably should)
        left: void 0,
        // ditto
        width: n,
        height: s
      })
    ), p === de.LEFT && (h *= -1);
    const m = this.positionService.findPositionAt(
      {
        left: g[0] + h,
        top: g[1]
      },
      a,
      p
    );
    this.positionService.setElement(a, m);
  }
}
const ht = class ht extends Y {
  constructor() {
    super(...arguments), this.type = "grid-brush", this.renderType = j.SVG, this.selectionSelector = "rect.selection", this.frontSelectionSelector = "rect.frontSelection";
  }
  // needs to match the class name in _grid-brush.scss
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e = !0) {
    const t = this.parent, n = this.getComponentContainer();
    if (!t)
      throw new Error("SVG was not defined");
    const s = S.appendOrSelect(
      t,
      "svg.chart-grid-backdrop"
    ), a = S.appendOrSelect(s, `g.${this.type}`), i = S.appendOrSelect(a, this.selectionSelector), { width: r, height: l } = S.getSVGElementSize(s, {
      useAttrs: !0
    }), { cartesianScales: c } = this.services, d = c.getMainXScaleType(), p = c.getMainXScale(), [h] = p.range();
    n.attr("transform", `translate(${h},0)`);
    const u = S.appendOrSelect(n, this.frontSelectionSelector);
    if (p && d === pe.TIME) {
      let g = this.model.get("zoomDomain");
      g === void 0 && (g = this.services.zoom.getDefaultZoomBarDomain(), g && this.model.set({ zoomDomain: g }, { animate: !1 }));
      const m = (A) => {
        const L = A[1] - A[0];
        let I = "0," + L.toString();
        const P = Math.floor(l / ht.DASH_LENGTH), W = P * ht.DASH_LENGTH;
        for (let k = 0; k < P; k++)
          I += "," + ht.DASH_LENGTH;
        I += "," + (l - W), P % 2 === 1 && (I += ",0"), I += "," + L.toString(), I += "," + l.toString(), u.attr("stroke-dasharray", I);
      }, E = (A) => {
        const L = A.selection;
        L === null || L[0] === L[1] || (u.attr("x", parseFloat(i.attr("x")) + parseFloat(s.attr("x"))).attr("y", i.attr("y")).attr("width", i.attr("width")).attr("height", i.attr("height")).style("cursor", "pointer").style("display", null), m(L));
      }, O = (A, L) => {
        const I = ni().range([0, r]).domain(g);
        let P = [I.invert(A), I.invert(L)];
        P[0].valueOf() === P[1].valueOf() && (P = this.services.zoom.getDefaultZoomBarDomain()), (g[0].valueOf() !== P[0].valueOf() || g[1].valueOf() !== P[1].valueOf()) && this.services.zoom.handleDomainChange(P);
      };
      let x;
      const y = (A) => {
        const L = A.selection;
        L !== null && (O(L[0], L[1]), a.call(x.move, null), u.style("display", "none"));
      };
      l != 0 && r != 0 && (x = na().extent([
        [0, 0],
        [r - 1, l]
      ]).on("start brush end", E).on("end.brushed", y), a.call(x));
      const w = this.services.zoom.getZoomRatio();
      s.on("click", function(A) {
        if (A.shiftKey) {
          const L = this.services.domUtils.getHolder(), I = Zt(a.node(), L)[0];
          let P = I - r * w / 2;
          P < 0 && (P = 0);
          let W = I + r * w / 2;
          W > r && (W = r), O(P, W);
        }
      });
    }
  }
};
ht.DASH_LENGTH = 4;
let Ws = ht;
class Eh extends Y {
  constructor() {
    super(...arguments), this.type = "zoom-bar", this.renderType = j.SVG, this.MIN_SELECTION_DIFF = 9e-10, this.brushSelector = "g.zoom-bar-brush", this.clipId = "zoomBarClip-" + Math.floor(Math.random() * 99999999999), this.brush = na(), this.highlightStrokeWidth = 1;
  }
  init() {
    this.services.events.addEventListener(f.ZoomBar.UPDATE, this.render.bind(this));
    const e = v(this.getOptions(), "zoomBar", B.TOP, "data");
    this.model.setZoomBarData(e);
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e = !0) {
    const t = this.getComponentContainer(), n = this.services.zoom.isZoomBarLoading(B.TOP), s = this.services.zoom.isZoomBarLocked(B.TOP), a = v(this.getOptions(), "zoomBar", B.TOP, "type"), i = v(this.getOptions(), "axes", B.BOTTOM, "highlights"), r = we.height[a], { width: l } = S.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    if (l === 0)
      return;
    let c = 0;
    const d = this.model.get("axesMargins");
    d && d.left && (c = d.left);
    const p = S.appendOrSelect(t, "svg.zoom-container").attr("width", "100%").attr("height", r).attr("opacity", 1);
    if (S.appendOrSelect(t, "rect.zoom-spacer").attr("x", 0).attr("y", r).attr("width", "100%").attr("height", we.spacerHeight).attr("opacity", 1).attr("fill", "none"), a === at.GRAPH_VIEW ? S.appendOrSelect(p, "rect.zoom-bg").attr("x", c).attr("y", 0).attr("width", l - c).attr("height", "100%").classed("zoom-bg-skeleton", n).style(
      "stroke",
      n ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    ) : a === at.SLIDER_VIEW && S.appendOrSelect(p, "rect.zoom-slider-bg").attr("x", c).attr("y", r / 2 - 1).attr("width", l - c).attr("height", 2).classed("zoom-slider-bg-skeleton", n).style(
      "stroke",
      n ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    ), n) {
      this.renderSkeleton(p, c, l);
      return;
    }
    const { cartesianScales: h } = this.services, u = h.getMainXScale(), g = h.getMainYScale(), m = h.getMainXScaleType();
    if (u && m === pe.TIME) {
      let E = this.services.zoom.getZoomBarData();
      if (ta(E) || E.length === 1)
        return;
      this.xScale = u.copy(), this.yScale = g.copy();
      const O = this.services.zoom.getDefaultZoomBarDomain(E);
      E = this.compensateDataForDefaultDomain(E, O);
      const x = this.model.get("initialZoomDomain"), y = v(
        this.getOptions(),
        "zoomBar",
        B.TOP,
        "initialZoomDomain"
      );
      y && y[0] && y[1] && (y[0] = new Date(y[0]), y[1] = new Date(y[1])), y && !(x && x[0].valueOf() === y[0].valueOf() && x[1].valueOf() === y[1].valueOf()) ? this.model.set(
        {
          // use a new object instead of newInitialZoomDomain
          initialZoomDomain: ut([], y),
          zoomDomain: y ? ut([], y) : O
        },
        { skipUpdate: !0 }
      ) : y === null && x !== null && this.model.set(
        {
          initialZoomDomain: null,
          zoomDomain: ut([], O)
        },
        { skipUpdate: !0 }
      ), this.xScale.range([c, l]).domain(O), this.maxSelectionRange = this.xScale.range(), this.yScale.range([0, r - 6]).domain(Yt(E, (L) => L.value));
      const w = this.model.get("zoomDomain");
      if (a === at.GRAPH_VIEW && (this.renderZoomBarArea(p, "path.zoom-graph-area-unselected", E, null), this.updateClipPath(t, this.clipId, 0, 0, 0, 0), this.renderZoomBarArea(p, "path.zoom-graph-area", E, this.clipId), this.renderZoomBarBaseline(p, c, l), i)) {
        const L = i.highlightStartMapsTo, I = i.highlightEndMapsTo, P = i.color, W = i.labelMapsTo;
        i.data.forEach((k, C) => {
          S.appendOrSelect(p, `rect.highlight-${C}`).attr("height", r - 2 * this.highlightStrokeWidth).attr("y", this.highlightStrokeWidth).attr("x", this.xScale(k[L])).attr(
            "width",
            this.xScale(k[I]) - this.xScale(k[L])
          ).style(
            "fill",
            P && P.scale[k[W]] ? P.scale[k[W]] : null
          ).style("fill-opacity", 0.1).style(
            "stroke",
            P && P.scale[k[W]] ? P.scale[k[W]] : null
          ).style("stroke-dasharray", "2, 2").attr("stroke-width", "1px");
        });
      }
      this.addBrushEventListener(w, c, l);
      const A = S.appendOrSelect(t, this.brushSelector).call(this.brush);
      if (w !== void 0)
        if (w[0].valueOf() === w[1].valueOf())
          A.call(this.brush.move, this.xScale.range()), this.updateBrushHandle(this.getComponentContainer(), this.xScale.range());
        else {
          const L = w.map((I) => this.xScale(I));
          L[1] - L[0] < this.MIN_SELECTION_DIFF || (A.call(this.brush.move, L), this.updateBrushHandle(this.getComponentContainer(), L));
        }
      s && (this.brush.filter(() => !1), A.selectAll("rect").attr("cursor", "auto"));
    }
  }
  addBrushEventListener(e, t, n) {
    const s = (r) => {
      const l = r.selection;
      l === null ? this.handleBrushedEvent(r, e, this.xScale, this.xScale.range()) : l[0] === l[1] || this.handleBrushedEvent(r, e, this.xScale, l);
    }, a = v(this.getOptions(), "zoomBar", B.TOP, "type"), i = we.height[a];
    this.brush.extent([
      [t, 0],
      [n, i]
    ]).on("start brush end", null).on("start brush end", s);
  }
  // brush event listener
  handleBrushedEvent(e, t, n, s) {
    const a = [n.invert(s[0]), n.invert(s[1])];
    if (this.updateBrushHandle(this.getComponentContainer(), s), e.sourceEvent != null && (e.sourceEvent.type === "mousemove" || e.sourceEvent.type === "mouseup" || e.sourceEvent.type === "mousedown" || e.sourceEvent.type === "touchstart" || e.sourceEvent.type === "touchmove" || e.sourceEvent.type === "touchend")) {
      (t === void 0 || t[0] !== a[0] || t[1] !== a[1]) && this.services.zoom.handleDomainChange(a, {
        dispatchEvent: !1
      });
      let i;
      e.type === "start" ? i = f.ZoomBar.SELECTION_START : e.type === "brush" ? i = f.ZoomBar.SELECTION_IN_PROGRESS : e.type === "end" && (i = f.ZoomBar.SELECTION_END, this.services.events.dispatchEvent(f.ZoomDomain.CHANGE, {
        newDomain: a
      })), this.services.events.dispatchEvent(i, {
        selection: s,
        newDomain: a
      });
    }
  }
  updateBrushHandle(e, t) {
    const n = this, s = we.handleWidth, a = v(this.getOptions(), "zoomBar", B.TOP, "type"), i = we.height[a], r = -s / 2, l = we.handleBarWidth, c = a === at.GRAPH_VIEW ? we.handleBarHeight : 6, d = -l / 2, p = (i - c) / 2;
    e.select(this.brushSelector).selectAll("rect.handle").data([{ type: "w" }, { type: "e" }]).attr("x", function(u) {
      if (u.type === "w")
        return Math.max(t[0] + r, n.maxSelectionRange[0]);
      if (u.type === "e")
        return Math.min(t[1] + r, n.maxSelectionRange[1] - s);
    }).attr("y", 0).attr("width", s).attr("height", i).attr("cursor", "ew-resize").style("display", null);
    const h = e.select(this.brushSelector).selectAll("rect.handle-bar").data([{ type: "w" }, { type: "e" }]);
    h.enter().append("rect").attr("class", function(u) {
      return "handle-bar handle-bar--" + u.type;
    }), h.attr("x", function(u) {
      if (u.type === "w")
        return Math.max(
          t[0] + d,
          n.maxSelectionRange[0] - r + d
        );
      if (u.type === "e")
        return Math.min(
          t[1] + d,
          n.maxSelectionRange[1] + r + d
        );
    }).attr("y", p).attr("width", l).attr("height", c).attr("cursor", "ew-resize"), a === at.SLIDER_VIEW && this.updateSliderSelectedArea(t), this.updateClipPath(
      e,
      this.clipId,
      t[0],
      0,
      t[1] - t[0],
      i
    );
  }
  updateSliderSelectedArea(e) {
    const t = v(this.getOptions(), "zoomBar", B.TOP, "type"), n = we.height[t], a = this.getComponentContainer().select("svg.zoom-container");
    S.appendOrSelect(a, "rect.zoom-slider-selected-area").attr("x", e[0]).attr("y", n / 2 - 1).attr("width", e[1] - e[0]).attr("height", 2);
  }
  renderZoomBarArea(e, t, n, s) {
    const { cartesianScales: a } = this.services, i = a.getMainXAxisPosition(), r = a.getMainYAxisPosition(), l = a.getMainXScaleType(), c = a.getMainYScaleType(), d = (O, x, y) => (w) => a.getValueFromScale(O, x, y, w), p = d(this.xScale, l, i), h = d(this.yScale, c, r), u = v(this.getOptions(), "zoomBar", B.TOP, "type"), g = we.height[u], m = Bn().x((O) => p(O)).y0(g).y1((O) => g - h(O)), E = S.appendOrSelect(e, t).datum(n).attr("d", m);
    s && E.attr("clip-path", `url(#${s})`);
  }
  updateClipPath(e, t, n, s, a, i) {
    const r = S.appendOrSelect(e, "clipPath").attr("id", t);
    S.appendOrSelect(r, "rect").attr("x", n).attr("y", s).attr("width", a).attr("height", i);
  }
  // assume the domains in data are already sorted
  compensateDataForDefaultDomain(e, t) {
    if (!e || e.length < 2)
      return;
    const n = qa(e), s = this.services.cartesianScales.getDomainIdentifier(), a = this.services.cartesianScales.getRangeIdentifier();
    if (Number(t[0]) < Number(n[0][s])) {
      const i = {};
      i[s] = t[0], i[a] = 0, n.unshift(i);
    }
    if (Number(t[1]) > Number(n[n.length - 1][s])) {
      const i = {};
      i[s] = t[1], i[a] = 0, n.push(i);
    }
    return n;
  }
  renderZoomBarBaseline(e, t, n, s = !1) {
    const a = v(
      this.model.getOptions(),
      "zoomBar",
      B.TOP,
      "type"
    ), i = we.height[a], r = Gn()([
      [t, i],
      [n, i]
    ]);
    S.appendOrSelect(e, "path.zoom-bg-baseline").attr("d", r).classed("zoom-bg-baseline-skeleton", s).style(
      "stroke",
      s ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    );
  }
  renderSkeleton(e, t, n) {
    this.renderZoomBarArea(e, "path.zoom-graph-area-unselected", [], null), this.renderZoomBarArea(e, "path.zoom-graph-area", [], this.clipId), this.brush.on("start brush end", null), S.appendOrSelect(this.getComponentContainer(), this.brushSelector).html(null), v(this.getOptions(), "zoomBar", B.TOP, "type") === at.GRAPH_VIEW && this.renderZoomBarBaseline(e, t, n, !0);
  }
  destroy() {
    this.brush.on("start brush end", null), this.services.events.removeEventListener(f.ZoomBar.UPDATE, this.render.bind(this));
  }
}
class bh extends Y {
  constructor(e, t) {
    super(e, t), this.type = "threshold", this.renderType = j.SVG, this.positionService = new qt();
  }
  render(e = !1) {
    const t = v(this.getOptions(), "axes"), n = [];
    Object.keys(t).forEach((h) => {
      if (Object.values(B).includes(h)) {
        const u = t[h];
        u.thresholds && u.thresholds.length > 0 && n.push({
          axisPosition: h,
          thresholds: u.thresholds,
          correspondingDatasets: u == null ? void 0 : u.correspondingDatasets,
          mapsTo: u == null ? void 0 : u.mapsTo
        });
      }
    });
    const a = this.getComponentContainer({ withinChartClip: !0 }).selectAll("g.axis-thresholds").data(n, (h) => h.axisPosition);
    a.exit().attr("opacity", 0).remove();
    const r = a.enter().append("g").merge(a);
    r.attr("class", (h) => `axis-thresholds ${h.axisPosition}`);
    const l = r.selectAll("g.threshold-group").data(
      (h) => h.thresholds.map((u) => (u.axisPosition = h.axisPosition, u.datum = this.constructDatumObj(h, u), u))
    );
    l.exit().attr("opacity", 0).remove();
    const c = l.enter().append("g");
    c.append("line").attr("class", "threshold-line"), c.append("rect").attr("class", "threshold-hoverable-area"), c.merge(l).attr("class", "threshold-group");
    const p = this;
    r.each(function({ axisPosition: h }) {
      const u = p.services.cartesianScales.getScaleByPosition(
        h
      ), g = p.services.cartesianScales.getScaleTypeByPosition(h);
      let m = null, E = null;
      h === B.LEFT || h === B.RIGHT ? (E = u, m = p.services.cartesianScales.getMainXScale()) : (m = u, E = p.services.cartesianScales.getMainYScale());
      const O = g === pe.LABELS, [x, y] = m.range(), [w, A] = E.range(), { cartesianScales: L } = p.services, I = L.getOrientation(), P = (F) => L.getDomainValue(F), W = (F) => L.getRangeValue(F), [k, C] = Ue(
        P,
        W,
        I
      ), V = T(this);
      h === B.TOP || h === B.BOTTOM ? (V.selectAll("line.threshold-line").transition().call(
        (F) => p.services.transitions.setupTransition({
          transition: F,
          name: "threshold-line-update",
          animate: e
        })
      ).attr("y1", A).attr("y2", w).attr(
        "x1",
        ({ datum: F }) => k(F) + (O ? u.step() / 2 : 0)
      ).attr(
        "x2",
        ({ datum: F }) => k(F) + (O ? u.step() / 2 : 0)
      ).style("stroke", ({ fillColor: F }) => F), V.selectAll("rect.threshold-hoverable-area").attr("x", 0).attr("y", ({ datum: F }) => -k(F)).attr("width", Math.abs(w - A)).classed("rotate", !0)) : (V.selectAll("line.threshold-line").transition().call(
        (F) => p.services.transitions.setupTransition({
          transition: F,
          name: "threshold-line-update",
          animate: e
        })
      ).attr("x1", x).attr("x2", y).attr(
        "y1",
        ({ datum: F }) => C(F) + (O ? u.step() / 2 : 0)
      ).attr(
        "y2",
        ({ datum: F }) => C(F) + (O ? u.step() / 2 : 0)
      ).style("stroke", ({ fillColor: F }) => F), V.selectAll("rect.threshold-hoverable-area").attr("x", x).attr("y", ({ datum: F }) => C(F)).attr("width", Math.abs(y - x)).classed("rotate", !1));
    }), this.services.events.addEventListener(f.Threshold.SHOW, (h) => {
      this.setThresholdLabelPosition(h.detail), this.label.classed("hidden", !1);
    }), this.services.events.addEventListener(f.Threshold.HIDE, () => {
      this.label.classed("hidden", !0);
    }), this.appendThresholdLabel(), this.addEventListeners();
  }
  getFormattedValue(e) {
    const { value: t, axisPosition: n } = e, s = this.getOptions(), a = this.services.cartesianScales.getScaleTypeByPosition(n), { code: i, number: r } = v(s, "locale");
    if (a === pe.TIME) {
      const l = [B.LEFT, B.RIGHT].includes(n), c = this.services.cartesianScales.getMainXScale(), d = this.services.cartesianScales.getMainYScale(), p = l ? d : c, h = v(s, "timeScale"), u = vn(
        p.ticks(),
        v(h, "timeInterval")
      );
      return yn(t, 0, p.ticks(), u, h, s.locale);
    }
    return r(t, i);
  }
  appendThresholdLabel() {
    const e = T(this.services.domUtils.getHolder()), t = v(this.getOptions(), "style", "prefix");
    this.label = S.appendOrSelect(
      e,
      `div.${Me}--${t}--threshold--label`
    ).classed("hidden", !0);
  }
  setThresholdLabelPosition({ event: e, datum: t }) {
    const n = this.services.domUtils.getHolder(), s = Zt(e, n), a = t.valueFormatter ? t.valueFormatter(t.value) : this.getFormattedValue(t);
    this.label.html(Pe(`${t.label || "Threshold"}: ${a}`)).style("background-color", t.fillColor);
    const i = this.label.node(), r = this.positionService.findBestPlacementAt(
      {
        left: s[0],
        top: s[1]
      },
      i,
      [de.RIGHT, de.LEFT, de.TOP, de.BOTTOM],
      () => ({
        top: void 0,
        // other package lists this as non-optional
        left: void 0,
        // ditto
        width: n.offsetWidth,
        height: n.offsetHeight
      })
    ), l = this.positionService.findPositionAt(
      {
        left: s[0],
        top: s[1]
      },
      i,
      r
    );
    this.positionService.setElement(i, l);
  }
  // Constructs object to pass in scale functions
  constructDatumObj(e, t) {
    const n = {};
    return e.correspondingDatasets && (n.group = v(e, "correspondingDatasets", 0)), n[e.mapsTo] = t.value, n;
  }
  addEventListeners() {
    const e = this;
    this.getComponentContainer({ withinChartClip: !0 }).selectAll("rect.threshold-hoverable-area").on("mouseover mousemove", function(n) {
      T(this.parentNode).select("line.threshold-line").classed("active", !0), e.services.events.dispatchEvent(f.Threshold.SHOW, {
        event: n,
        hoveredElement: T(this),
        datum: T(this).datum()
      });
    }).on("mouseout", function(n) {
      T(this.parentNode).select("line.threshold-line").classed("active", !1), e.services.events.dispatchEvent(f.Threshold.HIDE, {
        event: n,
        hoveredElement: T(this),
        datum: T(this).datum()
      });
    });
  }
}
class Sh extends Y {
  constructor(e, t) {
    super(e, t), this.type = "highlight", this.renderType = j.SVG, this.positionService = new qt(), this.highlightStrokeWidth = 1;
  }
  render(e = !1) {
    const t = v(this.getOptions(), "axes"), n = [];
    Object.keys(t).forEach((h) => {
      if (Object.values(B).includes(h)) {
        const u = t[h];
        u.highlights && u.highlights.data.length > 0 && n.push({
          axisPosition: h,
          highlightStartMapsTo: u.highlights.highlightStartMapsTo,
          highlightEndMapsTo: u.highlights.highlightEndMapsTo,
          labelMapsTo: u.highlights.labelMapsTo,
          highlight: u.highlights.data,
          color: u.highlights.color
        });
      }
    });
    const a = this.getComponentContainer({ withinChartClip: !0 }).selectAll("g.axis-highlight").data(n, (h) => h.axisPosition);
    a.exit().attr("opacity", 0).remove();
    const r = a.enter().append("g").merge(a);
    r.attr("class", (h) => `axis-highlight ${h.axisPosition}`);
    const l = r.selectAll("g.highlight-group").data(
      (h) => h.highlight.map((u) => (u.axisPosition = h.axisPosition, u.highlightStartMapsTo = h.highlightStartMapsTo, u.labelMapsTo = h.labelMapsTo, u.color = h.color, u.highlightEndMapsTo = h.highlightEndMapsTo, u))
    );
    l.exit().attr("opacity", 0).remove();
    const c = l.enter().append("g");
    c.append("rect").attr("class", "highlight-bar"), c.append("line").attr("class", "highlight-line"), c.merge(l).attr("class", "highlight-group");
    const p = this;
    r.each(function({ axisPosition: h }) {
      const u = p.services.cartesianScales.getMainXScale(), g = p.services.cartesianScales.getMainYScale(), [m, E] = u.range(), [O, x] = g.range(), { cartesianScales: y } = p.services, w = y.getOrientation(), A = (k) => y.getDomainValue(k), L = (k) => y.getRangeValue(k), [I, P] = Ue(
        A,
        L,
        w
      ), W = T(this);
      h === B.TOP || h === B.BOTTOM ? W.selectAll("rect.highlight-bar").transition().call(
        (k) => p.services.transitions.setupTransition({
          transition: k,
          name: "highlight-bar-update",
          animate: e
        })
      ).attr("y", Math.max(x + p.highlightStrokeWidth, 0)).attr("height", Math.max(O - 2 * p.highlightStrokeWidth, 0)).attr("x", ({ highlightStartMapsTo: k, ...C }) => I(C[k])).attr(
        "width",
        ({ highlightStartMapsTo: k, highlightEndMapsTo: C, ...V }) => Math.max(I(V[C]) - I(V[k]), 0)
      ).style("stroke", ({ color: k, labelMapsTo: C, ...V }) => k && k.scale[V[C]] ? k.scale[V[C]] : null).style("stroke-dasharray", "2, 2").attr("stroke-width", p.highlightStrokeWidth + "px").style("fill-opacity", 0.1).style("fill", ({ color: k, labelMapsTo: C, ...V }) => k && k.scale[V[C]] ? k.scale[V[C]] : null) : W.selectAll("rect.highlight-bar").transition().call(
        (k) => p.services.transitions.setupTransition({
          transition: k,
          name: "highlight-bar-update",
          animate: e
        })
      ).attr("x", m).attr("width", Math.max(E - m, 0)).attr("y", ({ highlightEndMapsTo: k, ...C }) => P(C[k])).attr(
        "height",
        ({ highlightStartMapsTo: k, highlightEndMapsTo: C, ...V }) => Math.max(P(V[k]) - P(V[C]), 0)
      ).style("stroke", ({ color: k, labelMapsTo: C, ...V }) => k && k.scale[V[C]] ? k.scale[V[C]] : null).style("stroke-dasharray", "2, 2").attr("stroke-width", p.highlightStrokeWidth + "px").style("fill-opacity", 0.1).style("fill", ({ color: k, labelMapsTo: C, ...V }) => k && k.scale[V[C]] ? k.scale[V[C]] : null);
    });
  }
}
class Oh extends El {
  getItems(e) {
    if (e.detail.items)
      return e.detail.items;
    const { data: t } = e.detail;
    if (!t || !t.length || !t[0])
      return [];
    const n = this.getOptions(), { cartesianScales: s } = this.services, a = s.getDomainIdentifier(), i = s.isDualAxes(), { groupMapsTo: r } = n.data, l = s.getDomainLabel();
    let c = s.getRangeLabel();
    const d = t[0][a];
    let p;
    if (t.length === 1) {
      const h = t[0], u = s.getRangeIdentifier(h);
      if (i) {
        const m = s.getRangeAxisPosition({
          datum: h,
          groups: [h[r]]
        });
        c = s.getScaleLabel(m);
      }
      const g = h[u];
      p = [
        {
          label: l,
          value: d
        },
        ...Array.isArray(g) && g.length === 2 ? [
          {
            label: "Start",
            value: g[0]
          },
          {
            label: "End",
            value: g[1]
          }
        ] : [
          {
            label: c,
            value: h[u]
          }
        ]
      ], e.detail.additionalItems && e.detail.additionalItems.forEach(
        (m) => p.push({
          label: m.label,
          value: m.value
        })
      ), p.push({
        label: ne(n, "locale.translations.group") || ne(n, "tooltip.groupLabel"),
        value: h[r],
        color: this.model.getFillColor(h[r]),
        class: this.model.getColorClassName({
          classNameTypes: [z.TOOLTIP],
          dataGroupName: h[r]
        })
      });
    } else if (t.length > 1 && (p = [
      {
        label: l,
        value: d
      }
    ], p = p.concat(
      t.map((h) => {
        const u = h[s.getRangeIdentifier(h)];
        return {
          label: h[r],
          value: Array.isArray(u) && u.length === 2 ? `${u[0]} - ${u[1]}` : u,
          color: this.model.getFillColor(h[r]),
          class: this.model.getColorClassName({
            classNameTypes: [z.TOOLTIP],
            dataGroupName: h[r]
          })
        };
      }).sort((h, u) => u.value - h.value)
    ), !i && v(n, "tooltip", "showTotal") === !0)) {
      const h = s.getRangeIdentifier();
      p.push({
        label: ne(n, "locale.translations.total") || ne(n, "tooltip.totalLabel") || "Total",
        value: t.reduce(
          (u, g) => u + g[h],
          0
        ),
        bold: !0
      });
    }
    return p;
  }
}
class Th extends Y {
  constructor() {
    super(...arguments), this.type = "alluvial", this.renderType = j.SVG, this.gradient_id = "gradient-id-" + Math.floor(Math.random() * 99999999999);
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e = !0) {
    const t = this.getComponentContainer({ withinChartClip: !0 });
    t.html("");
    const { width: n, height: s } = S.getSVGElementSize(t, {
      useAttrs: !0
    });
    if (n < 1 || s < 1)
      return;
    const a = this.model.getOptions(), i = this.model.getDisplayData(), r = v(
      this.getOptions(),
      "color",
      "gradient",
      "enabled"
    );
    let l = ke.minNodePadding;
    a.alluvial.nodePadding > ke.minNodePadding && (l = a.alluvial.nodePadding);
    const c = v(a, "alluvial", "nodeAlignment");
    let d = Ri;
    c === Ce.LEFT ? d = ki : c === Ce.RIGHT && (d = Di);
    const p = _i().nodeId((y) => y.name).nodeWidth(ke.nodeWidth).nodePadding(l).nodeAlign(d).extent([
      [2, 30],
      [n - 2, s]
    ]);
    this.graph = p({
      nodes: a.alluvial.nodes.map((y) => Object.assign({}, y)),
      links: i.map((y) => Object.assign({}, y))
    }), this.graph.nodes = this.graph.nodes.filter((y) => y.value !== 0);
    const h = {};
    this.graph.nodes.forEach((y) => {
      const w = y.x0;
      y.category && (h[w] = y == null ? void 0 : y.category);
    }), t.append("g").classed("header-arrows", !0).selectAll("g").data(Object.keys(h)).join("g").attr("transform", (y) => `translate(${y}, 0)`).append("text").attr(
      "id",
      (y, w) => this.services.domUtils.generateElementIDString(`alluvial-category-${w}`)
    ).style("font-size", "14px").text((y) => h[y] ? h[y] : "").attr("y", 20).attr("x", (y, w) => {
      const A = this.services.domUtils.generateElementIDString(
        `alluvial-category-${w}`
      ), { width: L } = S.getSVGElementSize(T(`text#${A}`), {
        useBBox: !0
      });
      let I = 0;
      return y + I >= L && (I = -L + 4), I;
    });
    const g = t.append("g").attr("fill", "none").selectAll("g").data(this.graph.links);
    if (g.exit().remove(), r) {
      const y = v(this.getOptions(), "color", "scale");
      y && g.enter().append("linearGradient").attr("id", (w) => `${this.gradient_id}-link-${w.index}`).attr("gradientUnits", "userSpaceOnUse").call(
        (w) => w.append("stop").attr("offset", "0%").attr("stop-color", (A) => y[A.source.name])
      ).call(
        (w) => w.append("stop").attr("offset", "100%").attr("stop-color", (A) => y[A.target.name])
      ), g.exit().remove();
    }
    g.enter().append("path").classed("link", !0).attr("d", Ii()).attr(
      "id",
      (y) => this.services.domUtils.generateElementIDString(`alluvial-line-${y.index}`)
    ).attr("class", (y) => a.alluvial.monochrome ? this.model.getColorClassName({
      classNameTypes: [z.STROKE],
      dataGroupName: 0,
      originalClassName: "link"
    }) : this.model.getColorClassName({
      classNameTypes: [z.STROKE],
      dataGroupName: y.source.index,
      originalClassName: "link"
    })).style("stroke", (y) => r ? `url(#${this.gradient_id}-link-${y.index})` : this.model.getFillColor(y.source.name, null, {
      ...y,
      source: y.source.name,
      target: y.target.name
    })).attr("stroke-width", (y) => Math.max(1, y.width)).style("stroke-opacity", ke.opacity.default).attr(
      "aria-label",
      (y) => `${y.source.name} → ${y.target.name} (${y.value}${a.alluvial.units ? " " + a.alluvial.units : ""})`
    );
    const m = t.append("g").selectAll("g").data(this.graph.nodes).enter().append("g").attr(
      "id",
      (y) => this.services.domUtils.generateElementIDString(`alluvial-node-${y.index}`)
    ).classed("node-group", !0).attr("transform", (y) => `translate(${y.x0}, ${y.y0})`);
    m.append("rect").classed("node", !0).attr("height", (y) => y.y1 - y.y0).attr("width", (y) => y.x1 - y.x0).attr("fill", "black");
    const E = m.append("g").attr(
      "id",
      (y) => this.services.domUtils.generateElementIDString(`alluvial-node-title-${y.index}`)
    ), { code: O, number: x } = v(a, "locale");
    E.append("text").attr(
      "id",
      (y) => this.services.domUtils.generateElementIDString(`alluvial-node-text-${y.index}`)
    ).attr("class", "node-text").style("font-size", "12px").attr("text-anchor", "start").attr("fill", "white").attr("x", 4).attr("dy", 13).text((y) => `${y.name} (${x(y.value, O)})`).attr("aria-label", (y) => `${y.name} (${y.value})`), E.append("rect").classed("node-text-bg", !0).attr("width", (y, w) => {
      const A = this.services.domUtils.generateElementIDString(
        `alluvial-node-text-${w}`
      ), { width: L } = S.getSVGElementSize(T(`text#${A}`), {
        useBBox: !0
      });
      return L + 8;
    }).attr("height", 18).attr("stroke-width", 2).lower(), E.attr("transform", (y, w) => {
      const A = this.services.domUtils.generateElementIDString(
        `alluvial-node-text-${w}`
      ), { width: L } = S.getSVGElementSize(T(`text#${A}`), {
        useBBox: !0
      }), I = (y.y1 - y.y0) / 2 - 9;
      let P = y.x1 - y.x0;
      return y.x1 >= L ? P = P - (L + 16) : P += 4, `translate(${P}, ${I})`;
    }), this.addLineEventListener(), this.addNodeEventListener();
  }
  addLineEventListener() {
    const e = this.getOptions(), t = this, { number: n, code: s } = v(this.getOptions(), "locale"), a = bn((i, r = "mouseover") => {
      const l = t.parent.selectAll("path.link").transition().call(
        (c) => t.services.transitions.setupTransition({
          transition: c,
          name: "alluvial-links-mouse-highlight"
        })
      );
      r === "mouseout" ? (T(i).lower(), l.style("stroke-opacity", ke.opacity.default)) : l.style("stroke-opacity", function() {
        return i === this ? (T(this).raise(), ke.opacity.selected) : ke.opacity.unfocus;
      });
    }, 33);
    this.parent.selectAll("path.link").on("mouseover", function(i, r) {
      const l = T(this);
      a(this, "mouseover"), l.classed("link-hovered", !0);
      const c = getComputedStyle(this).getPropertyValue("stroke");
      t.services.events.dispatchEvent(f.Alluvial.LINE_MOUSEOVER, {
        event: i,
        element: l,
        datum: r
      }), t.services.events.dispatchEvent(f.Tooltip.SHOW, {
        event: i,
        hoveredElement: l,
        items: [
          {
            label: r.target.name,
            value: (n(r.value, s) ? `${n(r.value, s)}` : "-") + (e.alluvial.units ? ` ${e.alluvial.units}` : ""),
            color: c,
            labelIcon: t.getRightArrowIcon()
          }
        ]
      });
    }).on("mousemove", function(i, r) {
      t.services.events.dispatchEvent(f.Alluvial.LINE_MOUSEMOVE, {
        event: i,
        element: T(this),
        datum: r
      }), t.services.events.dispatchEvent(f.Tooltip.MOVE, {
        event: i
      });
    }).on("click", function(i, r) {
      t.services.events.dispatchEvent(f.Alluvial.LINE_CLICK, {
        event: i,
        element: T(this),
        datum: r
      });
    }).on("mouseout", function(i, r) {
      const l = T(this);
      a(this, "mouseout"), l.classed("link-hovered", !1), t.services.events.dispatchEvent(f.Alluvial.LINE_MOUSEOUT, {
        event: i,
        element: l,
        datum: r
      }), t.services.events.dispatchEvent(f.Tooltip.HIDE, {
        event: i,
        hoveredElement: l
      });
    });
  }
  addNodeEventListener() {
    const e = this, t = bn((n = [], s = "mouseover") => {
      if (s === "mouseout" || n.length === 0) {
        e.parent.selectAll("path.link").classed("link-hovered", !1).data(this.graph.links, (i) => i.index).order().style("stroke-opacity", ke.opacity.default);
        return;
      }
      e.parent.selectAll("path.link").transition().call(
        (i) => this.services.transitions.setupTransition({
          transition: i,
          name: "alluvial-link-mouse-highlight"
        })
      ).style("stroke-opacity", function(i) {
        return n.some((r) => r === i.index) ? (T(this).classed("link-hovered", !0).raise(), ke.opacity.selected) : ke.opacity.unfocus;
      });
    }, 66);
    e.parent.selectAll(".node-group").on("mouseover", function(n, s) {
      const a = T(this), i = [];
      if (e.traverse({ link: "sourceLinks", node: "target" }, s, i), e.traverse({ link: "targetLinks", node: "source" }, s, i), i.length) {
        const r = Ot(a.attr("transform"));
        if (a.attr("transform", `translate(${r.x - 2}, ${r.y})`), a.classed("node-hovered", !0).selectAll("rect.node").attr("width", 8), s.x0 - 2 === 0) {
          const c = e.services.domUtils.generateElementIDString(
            `alluvial-node-title-${s.index}`
          ), d = e.parent.select(`g#${c}`), p = Ot(d.attr("transform"));
          d.attr("transform", `translate(${p.x + 4},${p.y})`);
        }
        const l = e.services.domUtils.generateElementIDString(
          `alluvial-node-text-${s.index}`
        );
        e.parent.select(`text#${l}`).style("font-weight", "bold"), t(i, "mouseover"), e.services.events.dispatchEvent(f.Alluvial.NODE_MOUSEOVER, {
          event: n,
          element: a,
          datum: s
        });
      }
    }).on("mousemove", function(n, s) {
      e.services.events.dispatchEvent(f.Alluvial.NODE_MOUSEMOVE, {
        event: n,
        element: T(this),
        datum: s
      }), e.services.events.dispatchEvent(f.Tooltip.MOVE, {
        event: n
      });
    }).on("click", function(n, s) {
      e.services.events.dispatchEvent(f.Alluvial.NODE_CLICK, {
        event: n,
        element: T(this),
        datum: s
      });
    }).on("mouseout", function(n, s) {
      const a = T(this), i = Ot(a.attr("transform"));
      if (a.classed("node-hovered", !1).attr("transform", `translate(${i.x + 2}, ${i.y})`).select("rect.node").attr("width", ke.nodeWidth), s.x0 - 2 === 0) {
        const l = e.services.domUtils.generateElementIDString(
          `alluvial-node-title-${s.index}`
        ), c = e.parent.select(`g#${l}`), d = Ot(c.attr("transform"));
        c.attr("transform", `translate(${d.x - 4},${d.y})`);
      }
      const r = e.services.domUtils.generateElementIDString(
        `alluvial-node-text-${s.index}`
      );
      e.parent.select(`text#${r}`).style("font-weight", "normal"), t([], "mouseout"), e.services.events.dispatchEvent(f.Alluvial.NODE_MOUSEOUT, {
        event: n,
        element: a,
        datum: s
      }), e.services.events.dispatchEvent(f.Tooltip.HIDE, {
        hoveredElement: a
      });
    });
  }
  // Traverse graph and get all connected links to node
  traverse(e, t, n = []) {
    t[e.link].map((a) => (n.push(a.index), a[e.node])).forEach((a) => this.traverse(e, a, n));
  }
  getRightArrowIcon() {
    return `
		<svg xmlns="http://www.w3.org/2000/svg" class="arrow-right" width="32" height="32" viewBox="0 0 32 32">
			<polygon points="18 6 16.57 7.393 24.15 15 4 15 4 17 24.15 17 16.57 24.573 18 26 28 16 18 6"/>
			<rect width="32" height="32"/>
		</svg>`;
  }
  // Remove event listeners
  destroy() {
    this.parent.selectAll("path.line,.node-group").on("mouseover", null).on("mousemove", null).on("click", null).on("mouseout", null);
  }
}
class xh extends Y {
  constructor() {
    super(...arguments), this.type = "grid", this.renderType = j.SVG;
  }
  render(e = !0) {
    const t = v(this.getOptions(), "grid", "x", "enabled"), n = v(this.getOptions(), "grid", "y", "enabled");
    this.drawBackdrop(t, n), !(!t && !n) && (t && (S.appendOrSelect(this.backdrop, "g.x.grid"), this.drawXGrid(e)), n && (S.appendOrSelect(this.backdrop, "g.y.grid"), this.drawYGrid(e)));
  }
  drawXGrid(e) {
    const t = this.parent, n = this.backdrop.attr("height"), s = this.services.cartesianScales.getMainXScale(), a = Hn(s).tickSizeInner(-n).tickSizeOuter(0);
    if (v(this.getOptions(), "grid", "x", "alignWithAxisTicks")) {
      const l = this.services.cartesianScales.getDomainAxisPosition(), c = v(this.getOptions(), "axes", l, "ticks", "values");
      c && a.tickValues(c);
    } else {
      const l = v(this.getOptions(), "grid", "x", "numberOfTicks");
      a.ticks(l);
    }
    const r = t.select(".x.grid").attr("transform", `translate(${-this.backdrop.attr("x")}, ${n})`);
    e ? r.transition().call(
      (l) => this.services.transitions.setupTransition({
        transition: l,
        name: "grid-update",
        animate: e
      })
    ).call(a) : r.call(a), this.cleanGrid(r);
  }
  drawYGrid(e) {
    const t = this.parent, n = this.backdrop.attr("width"), s = this.services.cartesianScales.getMainYScale(), a = sa(s).tickSizeInner(-n).tickSizeOuter(0);
    if (v(this.getOptions(), "grid", "y", "alignWithAxisTicks")) {
      const l = this.services.cartesianScales.getRangeAxisPosition(), c = v(this.getOptions(), "axes", l, "ticks", "values");
      c && a.tickValues(c);
    } else {
      const l = v(this.getOptions(), "grid", "y", "numberOfTicks");
      a.ticks(l);
    }
    const r = t.select(".y.grid").attr("transform", `translate(0, ${-this.backdrop.attr("y")})`);
    e ? r.transition().call(
      (l) => this.services.transitions.setupTransition({
        transition: l,
        name: "grid-update",
        animate: e
      })
    ).call(a) : r.call(a), this.cleanGrid(r);
  }
  /**
   * Returns the threshold for the gridline tooltips based on the mouse location.
   * Calculated based on the mouse position between the two closest gridlines or edges of chart.
   */
  getGridlineThreshold(e) {
    const t = this.parent, n = t.selectAll(".x.grid .tick").nodes().sort((d, p) => Number(Ge(d).tx) - Number(Ge(p).tx));
    let s = -1;
    if (!n.length)
      return;
    n.forEach((d) => {
      e[0] >= +Ge(d).tx && s++;
    });
    const a = s + 1 < n.length ? s + 1 : n.length, i = n[s], r = n[a];
    let l;
    if (!i)
      l = +Ge(r).tx;
    else if (r)
      l = +Ge(r).tx - +Ge(i).tx;
    else {
      const d = t.select("rect.chart-grid-backdrop").node();
      l = S.getSVGElementSize(d).width - +Ge(i).tx;
    }
    const { threshold: c } = this.getOptions().tooltip.gridline;
    return l * c;
  }
  /**
   * Returns the active gridlines based on the gridline threshold and mouse position.
   * @param position mouse positon
   */
  getActiveGridline(e) {
    const t = v(this.getOptions, "tooltip", "gridline", "threshold"), n = t || this.getGridlineThreshold(e);
    return this.parent.selectAll(".x.grid .tick").filter(function() {
      const i = Ge(this), r = {
        min: Number(i.tx) - n,
        max: Number(i.tx) + n
      };
      return r.min <= e[0] && e[0] <= r.max;
    });
  }
  drawBackdrop(e, t) {
    const n = this.parent, s = this.services.cartesianScales.getMainXScale(), a = this.services.cartesianScales.getMainYScale(), [i, r] = s.range(), [l, c] = a.range();
    this.backdrop = S.appendOrSelect(n, "svg.chart-grid-backdrop");
    const d = S.appendOrSelect(
      this.backdrop,
      e || t ? "rect.chart-grid-backdrop.stroked" : "rect.chart-grid-backdrop"
    );
    this.backdrop.merge(d).attr("x", i).attr("y", c).attr("width", Math.abs(r - i)).attr("height", Math.abs(l - c)).lower(), d.attr("width", "100%").attr("height", "100%");
  }
  cleanGrid(e) {
    e.selectAll("text").remove(), e.select(".domain").remove();
  }
}
class Lh extends Y {
  constructor() {
    super(...arguments), this.type = "area", this.renderType = j.SVG, this.gradient_id = "gradient-id-" + Math.floor(Math.random() * 99999999999), this.handleLegendOnHover = (e) => {
      const { hoveredElement: t } = e.detail;
      this.parent.selectAll("path.area").transition("legend-hover-area").call(
        (n) => this.services.transitions.setupTransition({
          transition: n,
          name: "legend-hover-area"
        })
      ).attr("opacity", (n) => n.name !== t.datum().name ? $e.opacity.unselected : $e.opacity.selected);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.area").transition("legend-mouseout-area").call(
        (e) => this.services.transitions.setupTransition({
          transition: e,
          name: "legend-mouseout-area"
        })
      ).attr("opacity", $e.opacity.selected);
    };
  }
  init() {
    const e = this.services.events;
    e.addEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.addEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(e = !0) {
    const t = this.getComponentContainer({ withinChartClip: !0 }), n = this.getOptions();
    let s = [0, 0];
    const { cartesianScales: a } = this.services, i = a.getOrientation(), r = Bn().curve(this.services.curves.getD3Curve()).defined((A) => {
      const L = a.getRangeIdentifier(), I = A[L];
      return I != null;
    }), l = this.model.getGroupedData(this.configs.groups), c = v(n, "bounds"), d = c && l && l.length === 1;
    !d && c && console.warn(
      `Bounds can only be shown when having 1 single datagroup, you've supplied ${l.length}`
    );
    let p = 0;
    const h = (A, L) => {
      v(n, "axes", A, "includeZero") === !1 && L[0] > 0 && L[1] > 0 && (p = L[0]);
    }, u = (A) => d ? a.getBoundedScaledValues(A)[0] : a.getRangeValue(p), g = (A) => d ? a.getBoundedScaledValues(A)[1] : a.getRangeValue(A);
    i === xe.VERTICAL ? (s = a.getMainYScale().domain(), h(a.getMainYAxisPosition(), s), r.x((A) => a.getDomainValue(A)).y0((A) => u(A)).y1((A) => g(A))) : (s = a.getMainXScale().domain(), h(a.getMainXAxisPosition(), s), r.x0((A) => u(A)).x1((A) => g(A)).y((A) => a.getDomainValue(A)));
    const m = v(n, "color", "gradient", "enabled"), E = l && l.length === 1 && m;
    l.length > 1 && m && console.error("Gradients can only be enabled when having 1 single dataset");
    const O = t.selectAll("path.area").data(l, (A) => A.name), x = T(this.services.domUtils.getMainContainer());
    if (O.exit().attr("opacity", 0).remove(), !l.length)
      return;
    if (E) {
      const A = x.select(
        `path.${this.model.getColorClassName({
          classNameTypes: [z.STROKE],
          dataGroupName: l[0].name
        })}`
      ).node();
      let L;
      if (A)
        L = getComputedStyle(A, null).getPropertyValue(
          "stroke"
        );
      else {
        const I = v(this.model.getOptions(), "color", "scale");
        if (I !== null) {
          const P = Object.keys(I);
          L = I[P[0]];
        }
      }
      vs.appendOrUpdateLinearGradient({
        svg: this.parent,
        id: this.services.domUtils.generateElementIDString(
          `${l[0].name.replace(" ", "")}_${this.gradient_id}`
        ),
        x1: "0%",
        x2: "0%",
        y1: "0%",
        y2: "100%",
        stops: vs.getStops(s, L)
      });
    } else
      this.parent.selectAll("defs linearGradient").empty() || this.parent.selectAll("defs linearGradient").each(function() {
        this.parentNode.remove();
      });
    const y = this, w = O.enter().append("path");
    E ? w.merge(O).style(
      "fill",
      (A) => `url(#${this.services.domUtils.generateElementIDString(
        `${A.name.replace(" ", "")}_${this.gradient_id}`
      )})`
    ).attr("class", "area").attr(
      "class",
      (A) => this.model.getColorClassName({
        classNameTypes: [z.FILL],
        dataGroupName: A.name,
        originalClassName: "area"
      })
    ).attr("d", (A) => {
      const { data: L } = A;
      return r(L);
    }) : (w.attr("opacity", 0).merge(O).attr("class", "area").attr(
      "class",
      (A) => this.model.getColorClassName({
        classNameTypes: [z.FILL, z.STROKE],
        dataGroupName: A.name,
        originalClassName: "area"
      })
    ).style("fill", (A) => y.model.getFillColor(A.name, null, A.data)).transition().call(
      (A) => this.services.transitions.setupTransition({
        transition: A,
        name: "area-update-enter",
        animate: e
      })
    ).attr("opacity", d ? 1 : $e.opacity.selected).attr("d", (A) => {
      const { data: L } = A;
      return r(L);
    }), d && w.attr("fill-opacity", $e.opacity.selected).style("stroke", (A) => y.model.getStrokeColor(A.name, null, A.data)).style("stroke-dasharray", "2, 2").attr("stroke-width", 0.7 + "px"));
  }
  destroy() {
    const e = this.services.events;
    e.removeEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.removeEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
class Ah extends Y {
  constructor() {
    super(...arguments), this.type = "line", this.renderType = j.SVG, this.handleLegendOnHover = (e) => {
      const { hoveredElement: t } = e.detail;
      this.parent.selectAll("path.line").transition("legend-hover-line").call(
        (n) => this.services.transitions.setupTransition({
          transition: n,
          name: "legend-hover-line"
        })
      ).attr("opacity", (n) => n.name !== t.datum().name ? He.opacity.unselected : He.opacity.selected);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.line").transition("legend-mouseout-line").call(
        (e) => this.services.transitions.setupTransition({
          transition: e,
          name: "legend-mouseout-line"
        })
      ).attr("opacity", He.opacity.selected);
    };
  }
  init() {
    const { events: e } = this.services;
    e.addEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.addEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(e = !0) {
    const t = this.getComponentContainer({ withinChartClip: !0 }), { cartesianScales: n, curves: s } = this.services, a = (g) => n.getDomainValue(g), i = (g) => n.getRangeValue(g), [r, l] = Ue(
      a,
      i,
      n.getOrientation()
    ), c = this.getOptions(), d = Gn().x(r).y(l).curve(s.getD3Curve()).defined((g) => {
      const m = n.getRangeIdentifier(g), E = g[m];
      return E != null;
    });
    let p = [];
    if (this.configs.stacked) {
      const g = Object.keys(c.axes).some((O) => c.axes[O].percentage), { groupMapsTo: m } = c.data;
      p = this.model.getStackedData({
        groups: this.configs.groups,
        percentage: g
      }).map((O) => {
        const x = this.services.cartesianScales.getDomainIdentifier(O), y = this.services.cartesianScales.getRangeIdentifier(O);
        return {
          name: v(O, 0, m),
          data: O.map((w) => ({
            [x]: w.data.sharedStackKey,
            [m]: w[m],
            [y]: w[1]
          })),
          hidden: !Pr(O, (w) => w[0] !== w[1])
        };
      });
    } else
      p = this.model.getGroupedData(this.configs.groups);
    const h = t.selectAll("path.line").data(p, (g) => g.name);
    h.exit().attr("opacity", 0).remove(), h.enter().append("path").classed("line", !0).attr("opacity", 0).merge(h).data(p, (g) => g.name).attr(
      "class",
      (g) => this.model.getColorClassName({
        classNameTypes: [z.STROKE],
        dataGroupName: g.name,
        originalClassName: "line"
      })
    ).style("stroke", (g) => this.model.getStrokeColor(g.name, null, g.data)).attr("role", X.GRAPHICS_SYMBOL).attr("aria-roledescription", "line").attr("aria-label", (g) => {
      const { data: m } = g;
      return m.map((E) => {
        const O = this.services.cartesianScales.getRangeIdentifier(E);
        return E[O];
      }).join(",");
    }).transition().call(
      (g) => this.services.transitions.setupTransition({
        transition: g,
        name: "line-update-enter",
        animate: e
      })
    ).attr("opacity", (g) => g.hidden ? 0 : 1).attr("d", (g) => {
      const { data: m } = g;
      return d(m);
    });
  }
  destroy() {
    const e = this.services.events;
    e.removeEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.removeEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
const js = 5;
function bl(o, e) {
  return o > e - js && o < e + js;
}
class Ia extends Y {
  constructor() {
    super(...arguments), this.type = "ruler", this.renderType = j.SVG, this.isXGridEnabled = v(this.getOptions(), "grid", "x", "enabled"), this.isYGridEnabled = v(this.getOptions(), "grid", "y", "enabled"), this.isEventListenerAdded = !1;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e = !1) {
    const t = v(this.getOptions(), "ruler", "enabled");
    this.drawBackdrop(), t && !this.isEventListenerAdded ? this.addBackdropEventListeners() : !t && this.isEventListenerAdded && this.removeBackdropEventListeners();
  }
  removeBackdropEventListeners() {
    this.isEventListenerAdded = !1, this.backdrop.on("mousemove mouseover mouseout", null);
  }
  formatTooltipData(e) {
    return e;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  showRuler(e, [t, n]) {
    const s = this.parent, a = this.services.cartesianScales.getOrientation(), i = this.model.getDisplayData(), r = this.services.cartesianScales.getRangeScale(), [l, c] = r.range(), d = a === xe.HORIZONTAL ? n : t, p = S.appendOrSelect(s, "g.ruler").attr("aria-label", "ruler"), h = S.appendOrSelect(p, "line.ruler-line"), u = s.selectAll("[role=graphics-symbol]"), g = i.map((E) => ({
      domainValue: this.services.cartesianScales.getDomainValue(E),
      originalData: E
    })).filter((E) => bl(E.domainValue, d));
    if (this.pointsWithinLine && g.length === this.pointsWithinLine.length && g.map((E) => E.domainValue).join() === this.pointsWithinLine.map((E) => E.domainValue).join())
      return this.pointsWithinLine = g, this.services.events.dispatchEvent(f.Tooltip.MOVE, {
        mousePosition: [t, n]
      });
    this.pointsWithinLine = g;
    const m = this.pointsWithinLine.reduce((E, O) => {
      if (E.length === 0)
        return E.push(O), E;
      const x = E[0].domainValue, y = Math.abs(d - O.domainValue), w = Math.abs(d - x);
      return y > w || (y < w ? E = [O] : E.push(O)), E;
    }, []);
    if (m.length > 0) {
      const E = m.map((w) => w.originalData).filter((w) => {
        const A = this.services.cartesianScales.getRangeIdentifier(w), L = w[A];
        return L != null;
      }), O = m.map(
        (w) => w.domainValue
      ), x = u.filter((w) => {
        const A = this.services.cartesianScales.getDomainValue(w);
        return O.includes(A);
      });
      this.elementsToHighlight && this.elementsToHighlight.size() > 0 && !Oa(this.elementsToHighlight, x) && this.hideRuler(), x.dispatch("mouseover"), this.elementsToHighlight = x, this.services.events.dispatchEvent(f.Tooltip.SHOW, {
        mousePosition: [t, n],
        hoveredElement: h,
        data: this.formatTooltipData(E)
      }), p.attr("opacity", 1);
      const y = m[0];
      a === "horizontal" ? h.attr("x1", c).attr("x2", l).attr("y1", y.domainValue).attr("y2", y.domainValue) : h.attr("y1", c).attr("y2", l).attr("x1", y.domainValue).attr("x2", y.domainValue);
    } else
      this.hideRuler();
  }
  hideRuler() {
    const e = this.parent, t = S.appendOrSelect(e, "g.ruler");
    e.selectAll("[role=graphics-symbol]").dispatch("mouseout"), this.services.events.dispatchEvent(f.Tooltip.HIDE), t.attr("opacity", 0);
  }
  /**
   * Adds the listener on the X grid to trigger multiple point tooltips along the x axis.
   */
  addBackdropEventListeners() {
    this.isEventListenerAdded = !0;
    const e = this, t = this.services.domUtils.getHolder(), n = this.model.getDisplayData();
    let s = function(a) {
      const i = Zt(a, e.parent.node());
      e.showRuler(a, i);
    };
    if (n.length > 100) {
      const a = n.length % 50 * 12.5;
      s = Ka(
        function(i) {
          const { mousePosition: r } = this;
          e.showRuler(i, r);
        },
        a,
        t
      );
    }
    this.backdrop.on("mousemove mouseover", s).on("mouseout", this.hideRuler.bind(this));
  }
  drawBackdrop() {
    const e = this.parent;
    this.backdrop = S.appendOrSelect(e, "svg.chart-grid-backdrop");
  }
}
class Wn extends Y {
  constructor() {
    super(...arguments), this.type = "scatter", this.renderType = j.SVG, this.handleChartHolderOnHover = () => {
      if (!this.parent)
        throw new Error("Parent not defined");
      this.parent.selectAll("circle.dot").transition("chart-holder-hover-scatter").call(
        (e) => {
          var t;
          return (t = this.services.transitions) == null ? void 0 : t.setupTransition({
            transition: e,
            name: "chart-holder-hover-scatter"
          });
        }
      ).attr("opacity", 1);
    }, this.handleChartHolderOnMouseOut = () => {
      if (!this.parent)
        throw new Error("Parent not defined");
      this.parent.selectAll("circle.dot").transition("chart-holder-mouseout-scatter").call(
        (e) => {
          var t;
          return (t = this.services.transitions) == null ? void 0 : t.setupTransition({
            transition: e,
            name: "chart-holder-mouseout-scatter"
          });
        }
      ).attr("opacity", 0);
    }, this.handleLegendOnHover = (e) => {
      const { hoveredElement: t } = e.detail, { groupMapsTo: n } = this.getOptions().data;
      if (!this.parent)
        throw new Error("Parent not defined");
      this.parent.selectAll("circle.dot").transition("legend-hover-scatter").call(
        (s) => {
          var a;
          return (a = this.services.transitions) == null ? void 0 : a.setupTransition({
            transition: s,
            name: "legend-hover-scatter"
          });
        }
      ).attr("opacity", (s) => s[n] !== t.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      if (!this.parent)
        throw new Error("Parent not defined");
      this.parent.selectAll("circle.dot").transition("legend-mouseout-scatter").call(
        (e) => {
          var t;
          return (t = this.services.transitions) == null ? void 0 : t.setupTransition({
            transition: e,
            name: "legend-mouseout-scatter"
          });
        }
      ).attr("opacity", 1);
    };
  }
  init() {
    const { events: e } = this.services;
    if (!e)
      throw new Error("Services events are undefined.");
    e.addEventListener(
      f.Legend.ITEM_HOVER,
      this.handleLegendOnHover
    ), e.addEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
    const { fadeInOnChartHolderMouseover: t } = this.configs;
    t && (e.addEventListener(f.Chart.MOUSEOVER, this.handleChartHolderOnHover), e.addEventListener(f.Chart.MOUSEOUT, this.handleChartHolderOnMouseOut));
  }
  filterBasedOnZoomDomain(e) {
    const { cartesianScales: t } = this.services;
    if (!t)
      throw new Error("Services cartesianScales are undefined.");
    const n = t.getDomainIdentifier(e), s = this.model.get("zoomDomain");
    return s !== void 0 ? e.filter(
      (a) => a[n].getTime() >= s[0].getTime() && a[n].getTime() <= s[1].getTime()
    ) : e;
  }
  getScatterData() {
    const e = this.getOptions(), { stacked: t } = this.configs;
    let n;
    if (t) {
      const s = Object.keys(e.axes).some((a) => e.axes[a].percentage);
      n = this.model.getStackedData({
        groups: this.configs.groups,
        percentage: s
      });
    } else {
      const { cartesianScales: s } = this.services;
      if (!s)
        throw new Error("Services cartesianScales are undefined.");
      n = this.model.getDisplayData(this.configs.groups).filter((a) => {
        const i = s.getRangeIdentifier(a);
        return a[i] !== void 0 && a[i] !== null;
      });
    }
    return this.filterBasedOnZoomDomain(n);
  }
  render(e) {
    if (!(v(this.getOptions(), "points", "enabled") || v(this.getOptions(), "bubble", "enabled")))
      return;
    const n = this.getComponentContainer({ withinChartClip: !0 }), s = this.getOptions(), { groupMapsTo: a } = s.data, { cartesianScales: i } = this.services;
    if (!i)
      throw new Error("Services cartesianScales are undefined.");
    const r = i.getDomainIdentifier(), l = n.selectAll("circle.dot").data(
      this.getScatterData(),
      (p) => `${p[a]}-${p[r]}`
    );
    l.exit().attr("opacity", 0).remove();
    const d = l.enter().append("circle").classed("dot", !0).attr("opacity", 0).merge(l);
    this.styleCircles(d, e), this.addEventListeners();
  }
  // A value is an anomaly if is above all defined domain and range thresholds
  isDatapointThresholdAnomaly(e) {
    const { handleThresholds: t } = this.configs;
    if (!t)
      return !1;
    const { cartesianScales: n } = this.services;
    if (!n)
      throw new Error("Cartesian scales service is undefined");
    const s = n.getOrientation(), [a, i] = Ue(
      n.getHighestDomainThreshold(),
      n.getHighestRangeThreshold(),
      s
    ), [r, l] = Ue(
      (p) => n.getDomainValue(p),
      (p) => n.getRangeValue(p),
      s
    ), c = r(e), d = l(e);
    return i && a ? d <= i.scaleValue && c >= a.scaleValue : i ? d <= i.scaleValue : a ? c >= a.scaleValue : !1;
  }
  styleCircles(e, t) {
    const n = this.getOptions(), { filled: s, fillOpacity: a } = n.points, { cartesianScales: i } = this.services;
    if (!i)
      throw new Error("Cartesian scales service is undefined");
    const { groupMapsTo: r } = n.data, l = (u) => i.getDomainValue(u), c = (u) => i.getRangeValue(u), [d, p] = Ue(
      l,
      c,
      i.getOrientation()
    ), { fadeInOnChartHolderMouseover: h } = this.configs;
    e.raise().classed("dot", !0).attr("class", (u) => {
      const g = i.getDomainIdentifier(u), E = this.model.getIsFilled(u[r], u[g], u, s) ? [z.FILL, z.STROKE] : [z.STROKE];
      return this.model.getColorClassName({
        classNameTypes: E,
        dataGroupName: u[r],
        originalClassName: "dot"
      }) || "";
    }).classed("threshold-anomaly", (u) => this.isDatapointThresholdAnomaly(u)).classed("filled", (u) => {
      const g = i.getDomainIdentifier(u);
      return this.model.getIsFilled(u[r], u[g], u, s);
    }).classed("unfilled", (u) => {
      const g = i.getDomainIdentifier(u);
      return !this.model.getIsFilled(u[r], u[g], u, s);
    }).transition().call(
      (u) => {
        var g;
        return (g = this.services.transitions) == null ? void 0 : g.setupTransition({
          transition: u,
          name: "scatter-update-enter",
          animate: t
        });
      }
    ).attr("cx", d).attr("cy", p).attr("r", n.points.radius).style("fill", (u) => {
      const g = i.getDomainIdentifier(u);
      if (this.model.getIsFilled(u[r], u[g], u, s))
        return this.model.getFillColor(u[r], u[g], u);
    }).style("stroke", (u) => {
      const g = i.getDomainIdentifier(u);
      return this.model.getStrokeColor(u[r], u[g], u);
    }).attr("fill-opacity", s ? a : 1).attr("opacity", h ? 0 : 1).attr("role", X.GRAPHICS_SYMBOL).attr("aria-roledescription", "point").attr("aria-label", (u) => {
      const g = i.getRangeIdentifier(u);
      return u[g];
    }), this.addEventListeners();
  }
  // Extended in bubble graphs
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getTooltipAdditionalItems(e) {
    return null;
  }
  addEventListeners() {
    const e = this, { groupMapsTo: t } = e.getOptions().data;
    if (!this.parent)
      throw new Error("Parent not defined");
    this.parent.selectAll("circle").on("mouseover", function(n, s) {
      var i, r;
      const a = T(this);
      a.classed("hovered", !0).attr(
        "class",
        (l) => e.model.getColorClassName({
          classNameTypes: [z.FILL],
          dataGroupName: l[t],
          originalClassName: a.attr("class")
        })
      ).style("fill", (l) => {
        var d;
        const c = (d = e.services.cartesianScales) == null ? void 0 : d.getDomainIdentifier(l);
        return e.model.getFillColor(l[t], l[c], l);
      }).classed("unfilled", !1), (i = e.services.events) == null || i.dispatchEvent(f.Tooltip.SHOW, {
        event: n,
        hoveredElement: a,
        data: [s],
        additionalItems: e.getTooltipAdditionalItems(s)
      }), (r = e.services.events) == null || r.dispatchEvent(f.Scatter.SCATTER_MOUSEOVER, {
        event: n,
        element: a,
        datum: s
      });
    }).on("mousemove", function(n, s) {
      var i, r;
      const a = T(this);
      (i = e.services.events) == null || i.dispatchEvent(f.Scatter.SCATTER_MOUSEMOVE, {
        event: n,
        element: a,
        datum: s
      }), (r = e.services.events) == null || r.dispatchEvent(f.Tooltip.MOVE, {
        event: n
      });
    }).on("click", function(n, s) {
      var a;
      (a = e.services.events) == null || a.dispatchEvent(f.Scatter.SCATTER_CLICK, {
        event: n,
        element: T(this),
        datum: s
      });
    }).on("mouseout", function(n, s) {
      var i, r, l;
      const a = T(this);
      if (a.classed("hovered", !1), !e.configs.filled) {
        const { filled: c } = e.getOptions().points, d = (i = e.services.cartesianScales) == null ? void 0 : i.getDomainIdentifier(s), p = e.model.getIsFilled(
          s[t],
          s[d],
          s,
          c
        );
        a.classed("unfilled", !p).style("fill", (h) => p || c ? e.model.getFillColor(h[t], h[d], h) : null);
      }
      (r = e.services.events) == null || r.dispatchEvent(f.Scatter.SCATTER_MOUSEOUT, {
        event: n,
        element: a,
        datum: s
      }), (l = e.services.events) == null || l.dispatchEvent(f.Tooltip.HIDE, {
        hoveredElement: a
      });
    });
  }
  destroy() {
    var t;
    (t = this.parent) == null || t.selectAll("circle").on("mousemove", null).on("mouseout", null);
    const { events: e } = this.services;
    if (!e)
      throw new Error("Services events undefined");
    e.removeEventListener(
      f.Legend.ITEM_HOVER,
      this.handleLegendOnHover
    ), e.removeEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut), e.removeEventListener(f.Chart.MOUSEOVER, this.handleChartHolderOnHover), e.removeEventListener(f.Chart.MOUSEOUT, this.handleChartHolderOnMouseOut);
  }
}
class Ra extends Y {
  constructor(e, t, n) {
    super(e, t, n), this.type = "axes", this.renderType = j.SVG, this.truncation = {
      [B.LEFT]: !1,
      [B.RIGHT]: !1,
      [B.TOP]: !1,
      [B.BOTTOM]: !1
    }, n && (this.configs = n), this.margins = this.configs.margins;
  }
  render(e = !0) {
    const { position: t } = this.configs, n = this.getOptions(), s = v(n, "axes", t, "visible"), a = this.getComponentContainer(), { width: i, height: r } = S.getSVGElementSize(a, {
      useAttrs: !0
    }), l = S.appendOrSelect(a, `g.axis.${t}`);
    let c, d;
    if (t === B.BOTTOM || t === B.TOP ? (c = this.configs.axes[B.LEFT] ? this.margins.left : 0, d = this.configs.axes[B.RIGHT] ? i - this.margins.right : i) : (c = r - this.margins.bottom, d = this.margins.top), !this.services.cartesianScales)
      throw new Error("Services cartesianScales undefined");
    const p = this.services.cartesianScales.getScaleByPosition(t);
    this.scaleType === pe.LABELS || this.scaleType === pe.LABELS_RATIO ? p.rangeRound([c, d]) : p.range([c, d]);
    let h;
    switch (t) {
      case B.LEFT:
        h = sa;
        break;
      case B.BOTTOM:
        h = Hn;
        break;
      case B.RIGHT:
        h = ai;
        break;
      case B.TOP:
        h = si;
        break;
    }
    l.attr("aria-label", `${t} axis`);
    const u = !l.select("g.ticks").empty();
    let g = S.appendOrSelect(l, "g.ticks");
    u || (g.attr("role", `${X.GRAPHICS_OBJECT} ${X.GROUP}`), g.attr("aria-label", `${t} ticks`));
    const m = S.appendOrSelect(l, "g.ticks.invisible").style("opacity", "0").style("pointer-events", "none").attr("aria-hidden", !0).attr("aria-label", `invisible ${t} ticks`), E = v(n, "axes", t), O = this.scaleType === pe.TIME || E.scaleType === pe.TIME, x = t === B.LEFT || t === B.RIGHT, y = this.model.get("zoomDomain");
    if (y && O && !x && p.domain(y), !s) {
      g.attr("aria-hidden", !0);
      return;
    }
    const w = v(E, "scaleType"), A = v(n, "data", "loading"), L = v(E, "ticks", "number"), I = v(E, "ticks", "values"), P = v(E, "truncation", "type"), W = v(E, "truncation", "threshold"), k = v(E, "truncation", "numCharacter"), C = L !== null, V = v(n, "timeScale"), F = S.appendOrSelect(m, "g.tick"), M = S.appendOrSelect(F, "text").text("0"), J = S.getSVGElementSize(M.node(), {
      useBBox: !0
    }).height;
    F.remove();
    const me = this.scaleType || E.scaleType || pe.LINEAR, q = h(p).tickSizeOuter(0);
    if (p.ticks) {
      let $;
      if (C ? $ = L : ($ = ct.ticks.number, x && ($ = this.getNumberOfFittingTicks(
        r,
        J,
        ct.ticks.verticalSpaceRatio
      ))), p.ticks().length === 1 && p.ticks()[0] === 0 && ($ = 0), q.ticks($), O)
        if (!p.ticks($).length)
          q.tickValues([]);
        else {
          const K = v(n, "timeScale", "addSpaceOnEdges"), se = v(n, "axes", t, "domain"), oe = p.copy();
          K && !se && oe.nice($);
          const fe = oe.ticks($);
          K && fe.length > 2 && !se && (fe.splice(fe.length - 1, 1), fe.splice(0, 1)), q.tickValues(fe);
        }
    }
    let H;
    const ae = v(E, "ticks", "formatter"), { code: ce, number: gt } = v(n, "locale");
    if (O) {
      const $ = vn(
        q.tickValues(),
        v(n, "timeScale", "timeInterval")
      );
      ae === null ? H = (K, se) => yn(K, se, q.tickValues(), $, V, n.locale) : H = (K, se) => {
        const oe = yn(
          K,
          se,
          q.tickValues(),
          $,
          V,
          n.locale
        );
        return ae(K, se, oe);
      };
    } else
      ae === null ? me === pe.LINEAR && (H = ($) => gt($, ce)) : H = ae;
    q.tickFormat(H);
    const [re, Ke] = this.services.cartesianScales.getScaleByPosition(t).domain();
    let Q;
    if (I) {
      if (O)
        I.forEach(($, K) => {
          $.getTime === void 0 && (I[K] = new Date($));
        }), Q = I.filter(($) => {
          const K = $.getTime();
          return K >= new Date(re).getTime() && K <= new Date(Ke).getTime();
        });
      else if (w === pe.LABELS) {
        const $ = this.services.cartesianScales.getScaleByPosition(t).domain();
        Q = I.filter((K) => $.includes(K));
      } else
        Q = I.filter(
          ($) => $ >= re && $ <= Ke
        );
      q.tickValues(Q);
    }
    switch (t) {
      case B.LEFT:
        g.attr("transform", `translate(${this.margins.left}, 0)`);
        break;
      case B.BOTTOM:
        g.attr("transform", `translate(0, ${r - this.margins.bottom})`);
        break;
      case B.RIGHT:
        g.attr("transform", `translate(${i - this.margins.right}, 0)`);
        break;
      case B.TOP:
        g.attr("transform", `translate(0, ${this.margins.top})`);
        break;
    }
    const Fe = this.model.isDataEmpty();
    if (E.title) {
      const $ = S.appendOrSelect(l, "text.axis-title").html(
        Fe || A ? "" : Pe(E.title)
      ), K = v(E, "titleOrientation");
      let se;
      switch (t) {
        case B.LEFT:
          K === Es.RIGHT ? $.attr("transform", "rotate(90)").attr("y", 0).attr("x", p.range()[0] / 2).attr("dy", "-0.5em").style("text-anchor", "middle") : $.attr("transform", "rotate(-90)").attr("y", 0).attr("x", -(p.range()[0] / 2)).attr("dy", "0.75em").style("text-anchor", "middle");
          break;
        case B.BOTTOM:
          $.attr(
            "transform",
            `translate(${this.margins.left / 2 + p.range()[1] / 2}, ${r + 4})`
          ).style("text-anchor", "middle");
          break;
        case B.RIGHT:
          K === Es.LEFT ? $.attr("transform", "rotate(-90)").attr("y", i).attr("x", -(p.range()[0] / 2)).style("text-anchor", "middle") : $.attr("transform", "rotate(90)").attr("y", -i).attr("x", p.range()[0] / 2).attr("dy", "0.75em").style("text-anchor", "middle");
          break;
        case B.TOP:
          se = S.getSVGElementSize($, {
            useBBox: !0
          }).height, $.attr(
            "transform",
            `translate(${this.margins.left / 2 + p.range()[1] / 2}, ${se / 2})`
          ).style("text-anchor", "middle");
          break;
      }
    }
    if (O) {
      const $ = vn(
        q.tickValues(),
        v(n, "timeScale", "timeInterval")
      ), K = V.showDayName, se = g;
      e && (g = g.transition().call(
        (fe) => this.services.transitions.setupTransition({
          transition: fe,
          name: "axis-update",
          animate: e
        })
      )), g = g.call(q), se.selectAll(".tick").data(q.tickValues(), p).order().select("text").style("font-weight", (fe, Ie) => Ja(fe, Ie, q.tickValues(), $, K) ? "bold" : "normal");
    } else
      !e || !u ? g = g.call(q) : g = g.transition().call(
        ($) => this.services.transitions.setupTransition({
          transition: $,
          name: "axis-update",
          animate: e
        })
      ).call(q);
    if (m.call(q), t === B.BOTTOM || t === B.TOP) {
      let $ = !1;
      const K = v(E, "ticks", "rotation");
      if (K === an.ALWAYS)
        $ = !0;
      else if (K === an.NEVER)
        $ = !1;
      else if (!K || K === an.AUTO)
        if (p.step)
          $ = m.selectAll("g.tick text").nodes().some(
            (oe) => S.getSVGElementSize(oe, {
              useBBox: !0
            }).width >= p.step()
          );
        else {
          $ = !1;
          const se = m.append("text").text("A"), oe = S.getSVGElementSize(se.node(), {
            useBBox: !0
          }).width;
          let fe;
          m.selectAll("g.tick").each(function() {
            const Ie = T(this), _ = parseFloat(v(Ge(this), "tx"));
            _ !== null && fe + Ie.text().length * oe * 0.8 >= _ && ($ = !0), fe = _;
          }), se.remove();
        }
      $ ? (C || (q.ticks(
        this.getNumberOfFittingTicks(i, J, ct.ticks.horizontalSpaceRatio)
      ), m.call(q), g.call(q)), l.selectAll("g.ticks g.tick text").attr("transform", "rotate(-45)").attr("text-anchor", t === B.TOP ? "start" : "end")) : l.selectAll("g.ticks g.tick text").attr("transform", null).attr("text-anchor", null);
    }
    if (A ? l.attr("opacity", 0) : l.attr("opacity", 1), g.selectAll("g.tick").attr("aria-label", ($) => $), m.selectAll("g.tick").attr("aria-label", ($) => $), P !== dt.NONE && w === pe.LABELS && !I) {
      const $ = this.services.cartesianScales.getScaleDomain(t);
      if ($.length > 0) {
        const K = a.select(`g.axis.${t} g.ticks g.tick`).html();
        l.selectAll("g.ticks g.tick").html(K);
        const se = this;
        l.selectAll("g.tick text").data($).text(function(oe) {
          return oe.length > W ? (se.truncation[t] = !0, xt(oe, P, k)) : oe;
        }), this.getInvisibleAxisRef().selectAll("g.tick text").data($).text(function(oe) {
          return oe.length > W ? xt(oe, P, k) : oe;
        }), l.selectAll("g.ticks").html(this.getInvisibleAxisRef().html()), l.selectAll("g.tick text").data($);
      }
    }
    this.addEventListeners();
  }
  addEventListeners() {
    const e = this.getComponentContainer(), { position: t } = this.configs, n = S.appendOrSelect(e, `g.axis.${t}`), s = this.getOptions(), a = v(s, "axes", t), i = v(a, "scaleType"), r = v(a, "truncation", "threshold"), l = this;
    n.selectAll("g.tick text").on("mouseover", function(c, d) {
      l.services.events.dispatchEvent(f.Axis.LABEL_MOUSEOVER, {
        event: c,
        element: T(this),
        datum: d
      }), i === pe.LABELS && d.length > r && l.services.events.dispatchEvent(f.Tooltip.SHOW, {
        event: c,
        hoveredElement: T(this),
        content: d
      });
    }).on("mousemove", function(c, d) {
      l.services.events.dispatchEvent(f.Axis.LABEL_MOUSEMOVE, {
        event: c,
        element: T(this),
        datum: d
      }), i === pe.LABELS && d.length > r && l.services.events.dispatchEvent(f.Tooltip.MOVE, {
        event: c
      });
    }).on("click", function(c, d) {
      l.services.events.dispatchEvent(f.Axis.LABEL_CLICK, {
        event: c,
        element: T(this),
        datum: d
      });
    }).on("mouseout", function(c, d) {
      l.services.events.dispatchEvent(f.Axis.LABEL_MOUSEOUT, {
        event: c,
        element: T(this),
        datum: d
      }), i === pe.LABELS && l.services.events.dispatchEvent(f.Tooltip.HIDE);
    });
  }
  getInvisibleAxisRef() {
    const { position: e } = this.configs;
    return this.getComponentContainer().select(`g.axis.${e} g.ticks.invisible`);
  }
  getTitleRef() {
    const { position: e } = this.configs;
    return this.getComponentContainer().select(`g.axis.${e} text.axis-title`);
  }
  getNumberOfFittingTicks(e, t, n) {
    const s = Math.floor(e / (t * n));
    return Sa(s, 2, ct.ticks.number);
  }
  destroy() {
    const e = this.getComponentContainer(), { position: t } = this.configs;
    S.appendOrSelect(e, `g.axis.${t}`).selectAll("g.tick text").on("mouseover", null).on("mousemove", null).on("mouseout", null);
  }
}
class Sl extends Ra {
  constructor(e, t, n) {
    super(e, t, n);
  }
  render(e = !0) {
    super.render(e), super.destroy();
    const t = this.configs.position, n = this.getComponentContainer(), s = S.appendOrSelect(n, `g.axis.${t}`), a = this;
    s.selectAll("g.tick").each(function(i, r) {
      const l = T(this);
      l.classed("tick-hover", !0).attr("tabindex", r === 0 ? 0 : -1);
      const c = l.select("text"), { width: d, height: p } = S.getSVGElementSize(c, {
        useBBox: !0
      }), h = S.appendOrSelect(l, "rect.axis-holder");
      let u = 0, g = 0;
      switch (t) {
        case B.LEFT:
          u = -d + Number(c.attr("x")), g = -(p / 2);
          break;
        case B.RIGHT:
          u = Math.abs(Number(c.attr("x"))), g = -(p / 2);
          break;
        case B.TOP:
          u = -(d / 2), g = -p + Number(c.attr("y")) / 2, a.truncation[t] && (u = 0, h.attr("transform", "rotate(-45)"));
          break;
        case B.BOTTOM:
          u = -(d / 2), g = p / 2 - 2, a.truncation[t] && (u = -d, h.attr("transform", "rotate(-45)"));
          break;
      }
      h.attr("x", u - ct.hover.rectanglePadding).attr("y", g).attr("width", d + ct.hover.rectanglePadding * 2).attr("height", p).lower();
    }), this.addEventListeners();
  }
  addEventListeners() {
    const e = this.getComponentContainer(), { position: t } = this.configs, n = S.appendOrSelect(e, `g.axis.${t}`), s = this.getOptions(), a = v(s, "axes", t), i = v(a, "scaleType"), r = v(a, "truncation", "threshold"), l = this;
    n.selectAll("g.tick.tick-hover").on("mouseover", function(c) {
      const d = T(this).select("text"), p = d.datum();
      l.services.events.dispatchEvent(f.Axis.LABEL_MOUSEOVER, {
        event: c,
        element: d,
        datum: p
      }), i === pe.LABELS && p.length > r && l.services.events.dispatchEvent(f.Tooltip.SHOW, {
        event: c,
        element: d,
        datum: p
      });
    }).on("mousemove", function(c) {
      const d = T(this).select("text"), p = d.datum();
      l.services.events.dispatchEvent(f.Axis.LABEL_MOUSEMOVE, {
        event: c,
        element: d,
        datum: p
      }), l.services.events.dispatchEvent(f.Tooltip.MOVE, {
        event: c
      });
    }).on("click", function(c) {
      l.services.events.dispatchEvent(f.Axis.LABEL_CLICK, {
        event: c,
        element: T(this).select("text"),
        datum: T(this).select("text").datum()
      });
    }).on("mouseout", function(c) {
      l.services.events.dispatchEvent(f.Axis.LABEL_MOUSEOUT, {
        event: c,
        element: T(this).select("text"),
        datum: T(this).select("text").datum()
      }), i === pe.LABELS && l.services.events.dispatchEvent(f.Tooltip.HIDE);
    }).on("focus", function(c) {
      const d = { clientX: 0, clientY: 0 };
      if (c.target) {
        c.target.focus();
        const p = c.target.getBoundingClientRect();
        d.clientX = p.x, d.clientY = p.y;
      }
      l.services.events.dispatchEvent(f.Axis.LABEL_FOCUS, {
        event: { ...c, ...d },
        element: T(this),
        datum: T(this).select("text").datum()
      });
    }).on("blur", function(c) {
      l.services.events.dispatchEvent(f.Axis.LABEL_BLUR, {
        event: c,
        element: T(this),
        datum: T(this).select("text").datum()
      });
    }).on("keydown", function(c) {
      c.key && c.key === "Escape" && (l.services.events.dispatchEvent(f.Tooltip.HIDE), l.services.events.dispatchEvent(f.Axis.LABEL_BLUR, {
        event: c,
        element: T(this),
        datum: T(this).select("text").datum()
      })), t === B.LEFT || t === B.RIGHT ? c.key && c.key === "ArrowUp" ? l.goNext(this, c) : c.key && c.key === "ArrowDown" && l.goPrevious(this, c) : c.key && c.key === "ArrowLeft" ? l.goPrevious(this, c) : c.key && c.key === "ArrowRight" && l.goNext(this, c);
    });
  }
  // Focus on the next HTML element sibling
  goNext(e, t) {
    e.nextElementSibling && e.nextElementSibling.tagName !== "path" && e.nextElementSibling.dispatchEvent(new Event("focus")), t.preventDefault();
  }
  // Focus on the previous HTML element sibling
  goPrevious(e, t) {
    e.previousElementSibling && e.previousElementSibling.tagName !== "path" && e.previousElementSibling.dispatchEvent(new Event("focus")), t.preventDefault();
  }
  destroy() {
    const e = this.getComponentContainer(), { position: t } = this.configs;
    S.appendOrSelect(e, `g.axis.${t}`).selectAll("g.tick.tick-hover").on("mouseover", null).on("mousemove", null).on("mouseout", null).on("focus", null).on("blur", null);
  }
}
class wh extends Y {
  constructor() {
    super(...arguments), this.type = "2D-axes", this.renderType = j.SVG, this.children = {}, this.thresholds = [], this.margins = {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }
  render(e = !1) {
    const t = {}, n = Object.keys(B), s = v(this.getOptions(), "axes");
    n.forEach((r) => {
      s[B[r]] && (t[B[r]] = !0);
    }), this.configs.axes = t, n.forEach((r) => {
      const l = B[r];
      if (this.configs.axes[l] && !this.children[l]) {
        const c = {
          position: l,
          axes: this.configs.axes,
          margins: this.margins
        }, d = this.model.axisFlavor === Mi.DEFAULT ? new Ra(this.model, this.services, c) : new Sl(this.model, this.services, c);
        d.setModel(this.model), d.setServices(this.services), d.setParent(this.parent), this.children[l] = d;
      }
    }), Object.keys(this.children).forEach((r) => {
      this.children[r].render(e);
    });
    const a = {};
    Object.keys(this.children).forEach((r) => {
      const l = this.children[r], c = l.configs.position, d = l.getInvisibleAxisRef(), { width: p, height: h } = S.getSVGElementSize(d, { useBBox: !0 });
      let u;
      switch (l.getTitleRef().empty() ? u = 0 : (u = S.getSVGElementSize(l.getTitleRef(), {
        useBBox: !0
      }).height, (c === B.LEFT || c === B.RIGHT) && (u += 5)), c) {
        case B.TOP:
          a.top = h + u;
          break;
        case B.BOTTOM:
          a.bottom = h + u;
          break;
        case B.LEFT:
          a.left = p + u;
          break;
        case B.RIGHT:
          a.right = p + u;
          break;
      }
    }), this.services.events.dispatchEvent(f.Axis.RENDER_COMPLETE), Object.keys(a).some(
      (r) => this.margins[r] !== a[r]
    ) && (this.margins = Object.assign(this.margins, a), this.model.set({ axesMargins: this.margins }, { skipUpdate: !0 }), this.services.events.dispatchEvent(f.ZoomBar.UPDATE), Object.keys(this.children).forEach((r) => {
      const l = this.children[r];
      l.margins = this.margins;
    }), this.render(!0));
  }
}
class Ol extends Y {
  constructor() {
    super(...arguments), this.type = "skeleton";
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e = !0) {
    const t = v(this.getOptions(), "data", "loading");
    t ? this.renderSkeleton(t) : this.removeSkeleton();
  }
  renderSkeleton(e) {
    if (this.configs.skeleton === It.GRID)
      this.renderGridSkeleton(e);
    else if (this.configs.skeleton === It.VERT_OR_HORIZ)
      this.renderVertOrHorizSkeleton(e);
    else if (this.configs.skeleton === It.PIE)
      this.renderPieSkeleton(e);
    else if (this.configs.skeleton === It.DONUT)
      this.renderDonutSkeleton(e);
    else
      throw new Error(`"${this.configs.skeleton}" is not a valid Skeleton type.`);
  }
  renderGridSkeleton(e) {
    this.setScales(), this.drawBackdrop(e), this.drawXGrid(e), this.drawYGrid(e), e && this.setShimmerEffect("shimmer-lines");
  }
  renderVertOrHorizSkeleton(e) {
    const t = this.services.cartesianScales.getOrientation();
    this.setScales(), this.drawBackdrop(e), t === xe.VERTICAL && this.drawYGrid(e), t === xe.HORIZONTAL && this.drawXGrid(e), this.setShimmerEffect("shimmer-lines");
  }
  renderPieSkeleton(e) {
    const t = this.computeOuterRadius();
    this.drawRing(t, 0, e), e && this.setShimmerEffect("shimmer-areas");
  }
  renderDonutSkeleton(e) {
    const t = this.computeOuterRadius(), n = this.computeInnerRadius();
    this.drawRing(t, n, e), e && this.setShimmerEffect("shimmer-areas");
  }
  setScales() {
    const e = this.services.cartesianScales.getMainXScale().range(), t = this.services.cartesianScales.getMainYScale().range();
    this.xScale = qe().domain([0, 1]).range(e), this.yScale = qe().domain([0, 1]).range(t);
  }
  drawBackdrop(e) {
    const t = this.parent, { width: n, height: s } = S.getSVGElementSize(t, {
      useAttrs: !0
    });
    this.backdrop = S.appendOrSelect(t, "svg.chart-skeleton.DAII").attr("width", n).attr("height", s);
    const a = S.appendOrSelect(this.backdrop, "rect.chart-skeleton-backdrop");
    a.attr("width", "100%").attr("height", "100%");
    const [i] = this.xScale.range(), [, r] = this.yScale.range();
    this.backdrop.merge(a).attr("x", i).attr("y", r), a.classed("shimmer-effect-lines", e).classed("empty-state-lines", !e).style(
      "stroke",
      e ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    );
  }
  drawXGrid(e) {
    const t = +this.backdrop.attr("width"), n = v(this.getOptions(), "grid", "x", "numberOfTicks"), s = this.xScale.ticks(n).map((r) => r * t), a = S.appendOrSelect(this.backdrop, "g.x.skeleton"), i = a.selectAll("line").data(s);
    i.enter().append("line").merge(i).attr("x1", (r) => r).attr("x2", (r) => r).attr("y1", 0).attr("y2", "100%"), a.selectAll("line").classed("shimmer-effect-lines", e).classed("empty-state-lines", !e).style(
      "stroke",
      e ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    );
  }
  drawYGrid(e) {
    const t = +this.backdrop.attr("height"), n = this.backdrop.attr("width"), s = v(this.getOptions(), "grid", "y", "numberOfTicks"), a = this.xScale.ticks(s).map((l) => l * t), i = S.appendOrSelect(this.backdrop, "g.y.skeleton"), r = i.selectAll("line").data(a);
    r.enter().append("line").merge(r).attr("x1", 0).attr("x2", n).attr("y1", (l) => l).attr("y2", (l) => l), i.selectAll("line").classed("shimmer-effect-lines", e).classed("empty-state-lines", !e).style(
      "stroke",
      e ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    );
  }
  drawRing(e, t, n = !0) {
    const s = this.parent, { width: a, height: i } = S.getSVGElementSize(s, {
      useAttrs: !0
    }), r = S.appendOrSelect(s, "svg.chart-skeleton").attr("width", a).attr("height", i), l = t === 0 ? "pie" : "donut", c = v(this.getOptions(), l, "alignment");
    S.appendOrSelect(r, "rect.chart-skeleton-area-container").attr("width", a).attr("height", i).attr("fill", "none");
    const d = Lt().innerRadius(t).outerRadius(e).startAngle(0).endAngle(Math.PI * 2), p = e + Math.abs(te.radiusOffset), h = e + (Math.min(a, i) - e * 2) / 2, u = S.appendOrSelect(r, "path").attr("class", "skeleton-area-shape").attr("transform", `translate(${p}, ${h})`).attr("d", d).classed("shimmer-effect-areas", n).classed("empty-state-areas", !n).style(
      "fill",
      n ? `url(#${this.services.domUtils.generateElementIDString("shimmer-areas")})` : null
    );
    let g = e + te.xOffset;
    c === Ce.CENTER ? g = a / 2 : c === Ce.RIGHT && (g = a - e - te.xOffset);
    const m = e + te.yOffset;
    u.attr("transform", `translate(${g}, ${m})`);
  }
  // same logic in pie
  computeOuterRadius() {
    const { width: e, height: t } = S.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    return Math.min(e, t) / 2 + te.radiusOffset;
  }
  // same logic in donut
  computeInnerRadius() {
    return this.computeOuterRadius() * (3 / 4);
  }
  setShimmerEffect(e) {
    const a = "stop-bg-shimmer", i = "stop-shimmer", r = this.parent.select(".chart-skeleton"), { width: l } = S.getSVGElementSize(this.parent, {
      useAttrs: !0
    }), c = 0, d = l, p = S.appendOrSelect(r, "defs").lower(), h = S.appendOrSelect(p, "linearGradient").attr("id", this.services.domUtils.generateElementIDString(e)).attr("class", e).attr("x1", c - 3 * 0.2 * l).attr("x2", d).attr("y1", 0).attr("y2", 0).attr("gradientUnits", "userSpaceOnUse").attr("gradientTransform", "translate(0, 0)"), u = `
			<stop class="${a}" offset="${c}"></stop>
			<stop class="${i}" offset="${c + 0.2}"></stop>
			<stop class="${a}" offset="${c + 2 * 0.2}"></stop>
		`;
    h.html(u), g();
    function g() {
      h.attr("gradientTransform", `translate(${c - 3 * 0.2 * l}, 0)`).transition().duration(2e3).delay(1e3).ease(ii).attr("gradientTransform", `translate(${d + 3 * 0.2 * l}, 0)`).on("end", g);
    }
  }
  removeSkeleton() {
    this.parent.select(".chart-skeleton").remove();
  }
}
class Mh extends Y {
  constructor() {
    super(...arguments), this.type = "boxplot", this.renderType = j.SVG;
  }
  render(e) {
    const t = this.getComponentContainer({ withinChartClip: !0 }), n = this.getOptions(), { groupMapsTo: s } = n.data, a = this.model.getDataGroupNames(), i = this.services.cartesianScales.getMainXScale(), r = this.services.cartesianScales.getMainYScale(), [l, c] = i.range(), [d, p] = r.range(), h = c - l, u = d - p;
    if (h === 0)
      return;
    const { cartesianScales: g } = this.services, m = g.getOrientation(), E = m === xe.VERTICAL, [O, x] = Ue(
      (C) => this.services.cartesianScales.getDomainValue(C),
      (C) => this.services.cartesianScales.getRangeValue(C),
      m
    ), y = Math.floor((E ? h : u) / a.length), w = Math.min(y / 2, 16), A = this.model.getBoxplotData(), L = t.selectAll(".box-group").data(A);
    L.exit().remove();
    const I = L.enter().append("g").attr("class", "box-group"), P = L.merge(I);
    I.append("path").merge(L.select("path.vertical-line.start")).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [z.STROKE],
        originalClassName: "vertical-line start"
      })
    ).attr("stroke-width", Ae.strokeWidth.default).attr("fill", "none").transition().call(
      (C) => this.services.transitions.setupTransition({
        transition: C,
        name: "boxplot-update-verticalstartline",
        animate: e
      })
    ).attr("d", (C) => {
      const V = g.getDomainValue(C[s]), F = V, M = g.getRangeValue(C.whiskers.min), J = g.getRangeValue(C.quartiles.q_25);
      return Ee({ x0: V, x1: F, y0: M, y1: J }, m);
    }), I.append("path").merge(L.select("path.vertical-line.end")).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [z.STROKE],
        originalClassName: "vertical-line end"
      })
    ).attr("stroke-width", Ae.strokeWidth.default).attr("fill", "none").transition().call(
      (C) => this.services.transitions.setupTransition({
        transition: C,
        name: "boxplot-update-verticalendline",
        animate: e
      })
    ).attr("d", (C) => {
      const V = g.getDomainValue(C[s]), F = V, M = g.getRangeValue(C.whiskers.max), J = g.getRangeValue(C.quartiles.q_75);
      return Ee({ x0: V, x1: F, y0: M, y1: J }, m);
    }), I.append("path").merge(L.select("path.box")).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [z.FILL, z.STROKE],
        originalClassName: "box"
      })
    ).attr("fill-opacity", Ae.box.opacity.default).attr("stroke-width", Ae.strokeWidth.default).attr("role", X.GRAPHICS_SYMBOL).attr("aria-roledescription", "box").attr("aria-label", (C) => C[s]).transition().call(
      (C) => this.services.transitions.setupTransition({
        transition: C,
        name: "boxplot-update-quartiles",
        animate: e
      })
    ).attr("d", (C) => {
      const V = g.getDomainValue(C[s]) - w / 2, F = V + w, M = g.getRangeValue(
        Math[E ? "max" : "min"](C.quartiles.q_75, C.quartiles.q_25)
      ), J = M + Math.abs(
        g.getRangeValue(C.quartiles.q_75) - g.getRangeValue(C.quartiles.q_25)
      );
      return Ee({ x0: V, x1: F, y0: M, y1: J }, m);
    }), I.append("path").merge(L.select("path.highlight-area")).attr("class", "highlight-area").attr("opacity", 0).attr("d", (C) => {
      const V = g.getDomainValue(C[s]) - w / 2, F = V + w, M = g.getRangeValue(C.whiskers.min), J = g.getRangeValue(C.whiskers.max);
      return Ee({ x0: V, x1: F, y0: M, y1: J }, m);
    }), I.append("path").merge(L.select("path.whisker.start")).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [z.STROKE],
        originalClassName: "whisker start"
      })
    ).attr("stroke-width", Ae.strokeWidth.thicker).attr("fill", "none").transition().call(
      (C) => this.services.transitions.setupTransition({
        transition: C,
        name: "boxplot-update-startingwhisker",
        animate: e
      })
    ).attr("d", (C) => {
      const V = g.getDomainValue(C[s]) - w / 4, F = V + w / 2, M = g.getRangeValue(C.whiskers.min), J = g.getRangeValue(C.whiskers.min);
      return Ee({ x0: V, x1: F, y0: M, y1: J }, m);
    }), I.append("path").merge(L.select("path.median")).attr("fill", "none").attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [z.STROKE],
        originalClassName: "median"
      })
    ).attr("stroke-width", 2).transition().call(
      (C) => this.services.transitions.setupTransition({
        transition: C,
        name: "boxplot-update-median",
        animate: e
      })
    ).attr("d", (C) => {
      const V = g.getDomainValue(C[s]) - w / 2, F = V + w, M = g.getRangeValue(C.quartiles.q_50);
      return Ee({ x0: V, x1: F, y0: M, y1: M }, m);
    }), I.append("path").merge(L.select("path.whisker.end")).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [z.STROKE],
        originalClassName: "whisker end"
      })
    ).attr("stroke-width", Ae.strokeWidth.thicker).attr("fill", "none").transition().call(
      (C) => this.services.transitions.setupTransition({
        transition: C,
        name: "boxplot-update-endingwhisker",
        animate: e
      })
    ).attr("d", (C) => {
      const V = g.getDomainValue(C[s]) - w / 4, F = V + w / 2, M = g.getRangeValue(C.whiskers.max), J = g.getRangeValue(C.whiskers.max);
      return Ee({ x0: V, x1: F, y0: M, y1: J }, m);
    });
    const W = P.selectAll("circle.outlier").data(
      (C) => C.outliers.map((V) => ({
        min: C.whiskers.min,
        max: C.whiskers.max,
        [s]: C[s],
        value: V
      }))
    );
    W.exit().remove();
    const k = W.enter().append("circle");
    W.merge(k).attr("r", Ae.circle.radius).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [z.FILL, z.STROKE],
        originalClassName: "outlier"
      })
    ).attr("fill-opacity", Ae.circle.opacity.default).attr("cx", O).transition().call(
      (C) => this.services.transitions.setupTransition({
        transition: C,
        name: "boxplot-update-circles",
        animate: e
      })
    ).attr("cy", x), this.addBoxEventListeners(), this.addCircleEventListeners();
  }
  addBoxEventListeners() {
    const e = this, t = this.getOptions(), { groupMapsTo: n } = t.data;
    this.parent.selectAll("path.highlight-area").on("mouseover", function(s, a) {
      const i = T(this);
      T(this.parentNode).select("path.box").classed("hovered", !0).attr("fill-opacity", Ae.box.opacity.hovered), e.services.events.dispatchEvent(f.Tooltip.SHOW, {
        event: s,
        hoveredElement: i,
        items: [
          {
            label: v(t, "locale", "translations", "group") || v(t, "tooltip", "groupLabel") || "Group",
            value: a[n],
            class: e.model.getColorClassName({
              classNameTypes: [z.TOOLTIP]
            })
          },
          {
            label: "Minimum",
            value: a.whiskers.min
          },
          {
            label: "Q1",
            value: a.quartiles.q_25
          },
          {
            label: "Median",
            value: a.quartiles.q_50
          },
          {
            label: "Q3",
            value: a.quartiles.q_75
          },
          {
            label: "Maximum",
            value: a.whiskers.max
          },
          {
            label: "IQR",
            value: a.quartiles.q_75 - a.quartiles.q_25
          }
        ]
      }), e.services.events.dispatchEvent(f.Boxplot.BOX_MOUSEOVER, {
        event: s,
        element: i,
        datum: a
      });
    }).on("mousemove", function(s, a) {
      const i = T(this);
      e.services.events.dispatchEvent(f.Boxplot.BOX_MOUSEMOVE, {
        event: s,
        element: i,
        datum: a
      }), e.services.events.dispatchEvent(f.Tooltip.MOVE, {
        event: s
      });
    }).on("click", function(s, a) {
      e.services.events.dispatchEvent(f.Boxplot.BOX_CLICK, {
        event: s,
        element: T(this),
        datum: a
      });
    }).on("mouseout", function(s, a) {
      const i = T(this);
      T(this.parentNode).select("path.box").classed("hovered", !1).attr("fill-opacity", Ae.box.opacity.default), e.services.events.dispatchEvent(f.Boxplot.BOX_MOUSEOUT, {
        event: s,
        element: i,
        datum: a
      }), e.services.events.dispatchEvent(f.Tooltip.HIDE, {
        hoveredElement: i
      });
    });
  }
  addCircleEventListeners() {
    const e = this, t = this.getOptions(), { groupMapsTo: n } = t.data, s = this.services.cartesianScales.getRangeIdentifier();
    this.parent.selectAll("circle").on("mouseover", function(a, i) {
      const r = T(this);
      r.classed("hovered", !0).attr("fill-opacity", Ae.circle.opacity.hovered).classed("unfilled", !1), e.services.events.dispatchEvent(f.Tooltip.SHOW, {
        event: a,
        hoveredElement: r,
        items: [
          {
            label: v(t, "locale", "translations", "group") || v(t, "tooltip", "groupLabel") || "Group",
            value: i[n],
            class: e.model.getColorClassName({
              classNameTypes: [z.TOOLTIP]
            })
          },
          {
            label: "Outlier",
            value: i[s]
          }
        ]
      }), e.services.events.dispatchEvent(f.Boxplot.OUTLIER_MOUSEOVER, {
        event: a,
        element: r,
        datum: i
      });
    }).on("mousemove", function(a, i) {
      const r = T(this);
      e.services.events.dispatchEvent(f.Boxplot.OUTLIER_MOUSEMOVE, {
        event: a,
        element: r,
        datum: i
      }), e.services.events.dispatchEvent(f.Tooltip.MOVE, {
        event: a
      });
    }).on("click", function(a, i) {
      e.services.events.dispatchEvent(f.Boxplot.OUTLIER_CLICK, {
        event: a,
        element: T(this),
        datum: i
      });
    }).on("mouseout", function(a, i) {
      const r = T(this);
      r.classed("hovered", !1).attr("fill-opacity", Ae.circle.opacity.default), e.services.events.dispatchEvent(f.Boxplot.OUTLIER_MOUSEOUT, {
        event: a,
        element: r,
        datum: i
      }), e.services.events.dispatchEvent(f.Tooltip.HIDE, {
        hoveredElement: r
      });
    });
  }
}
class Ch extends Y {
  constructor() {
    super(...arguments), this.type = "zero-line", this.renderType = j.SVG;
  }
  render(e) {
    const t = this.services.cartesianScales.getRangeAxisPosition({
      groups: this.configs.groups
    }), n = this.services.cartesianScales.getScaleByPosition(t), [s, a] = n.domain(), i = s > 0 && a < 0 || s < 0 && a > 0, r = this.getComponentContainer();
    if (!i) {
      r.selectAll("line.domain").remove();
      return;
    }
    const [l, c] = this.services.cartesianScales.getDomainScale().range();
    let d = +n(0) + 0.5;
    d || (d = n.range()[0]);
    const p = Qa(
      {
        x0: l,
        x1: c,
        y0: d,
        y1: d
      },
      this.services.cartesianScales.getOrientation()
    );
    S.appendOrSelect(r, "line.domain").transition().call(
      (u) => this.services.transitions.setupTransition({
        transition: u,
        name: "zero-line-update",
        animate: e
      })
    ).attr("y1", p.y0).attr("y2", p.y1).attr("x1", p.x0).attr("x2", p.x1);
  }
}
class _h extends Wn {
  constructor() {
    super(...arguments), this.type = "bubble", this.renderType = j.SVG;
  }
  getRadiusScale(e) {
    const t = this.getOptions(), { radiusMapsTo: n } = t.bubble, s = e.data(), a = s.map((c) => c[n]).filter((c) => c), i = S.getHTMLElementSize(this.services.domUtils.getMainContainer()), r = a.length > 0, l = r ? Yt(a) : [1, 1];
    return qe().domain(l).range(r ? t.bubble.radiusRange(i, s) : [4, 4]);
  }
  styleCircles(e, t) {
    const n = this.getOptions(), { radiusMapsTo: s } = n.bubble, a = this.getRadiusScale(e), { groupMapsTo: i } = n.data, { cartesianScales: r } = this.services, l = (h) => r.getDomainValue(h), c = (h) => r.getRangeValue(h), [d, p] = Ue(
      l,
      c,
      r.getOrientation()
    );
    e.raise().classed("dot", !0).attr("role", X.GRAPHICS_SYMBOL).attr("aria-label", (h) => {
      const u = r.getRangeIdentifier(h);
      return h[u];
    }).transition().call(
      (h) => this.services.transitions.setupTransition({
        transition: h,
        name: "bubble-update-enter",
        animate: t
      })
    ).attr("cx", d).attr("cy", p).attr("r", (h) => a(h[s] || 1)).attr(
      "class",
      (h) => this.model.getColorClassName({
        classNameTypes: [z.FILL, z.STROKE],
        dataGroupName: h[i],
        originalClassName: "dot"
      })
    ).style("fill", (h) => {
      const u = this.services.cartesianScales.getDomainIdentifier(h);
      return this.model.getFillColor(h[i], h[u], h);
    }).style("stroke", (h) => {
      const u = this.services.cartesianScales.getDomainIdentifier(h);
      return this.model.getStrokeColor(h[i], h[u], h);
    }).attr("fill-opacity", n.bubble.fillOpacity).attr("opacity", 1);
  }
  getTooltipAdditionalItems(e) {
    const t = v(this.getOptions(), "bubble");
    return [
      {
        label: v(t, "radiusLabel"),
        value: e[v(t, "radiusMapsTo")]
      }
    ];
  }
}
class Ih extends Y {
  constructor() {
    super(...arguments), this.type = "bullet", this.renderType = j.SVG, this.handleLegendOnHover = (e) => {
      const { hoveredElement: t } = e.detail, { groupMapsTo: n } = this.getOptions().data;
      this.parent.selectAll("path.bar").transition("legend-hover-simple-bar").call(
        (s) => this.services.transitions.setupTransition({
          transition: s,
          name: "legend-hover-simple-bar"
        })
      ).attr("opacity", (s) => s[n] !== t.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.bar").transition("legend-mouseout-simple-bar").call(
        (e) => this.services.transitions.setupTransition({
          transition: e,
          name: "legend-mouseout-simple-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const e = this.services.events;
    e.addEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.addEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(e) {
    const t = this.getOptions(), { groupMapsTo: n } = t.data, s = this.getComponentContainer({ withinChartClip: !0 }), a = this.model.getDisplayData(this.configs.groups), i = this.services.cartesianScales.getRangeScale(), r = this.services.cartesianScales.getRangeIdentifier(), [l, c] = i.range(), [, d] = i.domain(), p = () => {
      const m = [];
      a.forEach((x) => {
        x.ranges ? x.ranges.forEach((y, w) => {
          y != null && y < d && m.push({
            datum: x,
            value: y,
            order: w + 1
          });
        }) : m.push({
          datum: x,
          order: 1
        });
      });
      const E = S.appendOrSelect(s, "g.range-boxes").selectAll("path.range-box").data(m, (x) => `${x[n]}-${x.order}`);
      E.exit().attr("opacity", 0).remove(), E.enter().append("path").attr("opacity", 0).merge(E).attr("class", (x) => `range-box order-${x.order}`).transition().call(
        (x) => this.services.transitions.setupTransition({
          transition: x,
          name: "bullet-range-box-update-enter",
          animate: e
        })
      ).attr("d", (x) => {
        let w, A, L, I;
        return x.order === 1 ? (w = this.services.cartesianScales.getDomainValue(x.datum) - 16 / 2, A = w + 16, L = c - 2, I = l + 1) : (w = this.services.cartesianScales.getDomainValue(x.datum) - 16 / 2, A = w + 16, L = this.services.cartesianScales.getRangeValue(x.value), I = c), Ee(
          { x0: w, x1: A, y0: L, y1: I },
          this.services.cartesianScales.getOrientation()
        );
      }).attr("opacity", 1);
    }, h = () => {
      const m = S.appendOrSelect(s, "g.bars").selectAll("path.bar").data(a, (O) => O[n]);
      m.exit().attr("opacity", 0).remove(), m.enter().append("path").attr("opacity", 0).merge(m).classed("bar", !0).transition().call(
        (O) => this.services.transitions.setupTransition({
          transition: O,
          name: "bullet-bar-update-enter",
          animate: e
        })
      ).attr(
        "class",
        (O) => this.model.getColorClassName({
          classNameTypes: [z.FILL],
          dataGroupName: O[n],
          originalClassName: "bar"
        })
      ).style("fill", (O) => {
        const x = this.services.cartesianScales.getDomainIdentifier(O);
        return this.model.getFillColor(O[n], O[x], O);
      }).attr("d", (O) => {
        const y = this.services.cartesianScales.getDomainValue(O) - 4, w = y + 8, A = this.services.cartesianScales.getRangeValue(0) + 1, L = this.services.cartesianScales.getRangeValue(O);
        return Ee(
          { x0: y, x1: w, y0: A, y1: L },
          this.services.cartesianScales.getOrientation()
        );
      }).attr("opacity", 1).attr("role", X.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (O) => O.value);
    }, u = () => {
      const m = S.appendOrSelect(s, "g.markers").selectAll("path.marker").data(
        a.filter((O) => v(O, "marker") !== null),
        (O) => O[n]
      );
      m.exit().attr("opacity", 0).remove(), m.enter().append("path").attr("opacity", 0).merge(m).classed("marker", !0).transition().call(
        (O) => this.services.transitions.setupTransition({
          transition: O,
          name: "bullet-marker-update-enter",
          animate: e
        })
      ).attr("d", (O) => {
        const y = this.services.cartesianScales.getDomainValue(O) - 12, w = y + 24, A = this.services.cartesianScales.getRangeValue(O.marker);
        return Ee(
          { x0: y, x1: w, y0: A, y1: A },
          this.services.cartesianScales.getOrientation()
        );
      }).attr("opacity", 1);
    }, g = () => {
      let m = [];
      a.filter((x) => v(x, "marker") !== null).forEach((x) => {
        const y = x.marker, w = x[r];
        m = m.concat([
          { datum: x, value: y * 0.25, barValue: w },
          { datum: x, value: y * 0.5, barValue: w },
          { datum: x, value: y * 0.75, barValue: w }
        ]);
      });
      const E = S.appendOrSelect(s, "g.quartiles").selectAll("path.quartile").data(m, (x) => x[n]);
      E.exit().attr("opacity", 0).remove(), E.enter().append("path").attr("opacity", 0).merge(E).attr("class", (x) => `quartile ${x.value <= x.barValue ? "over-bar" : ""}`).transition().call(
        (x) => this.services.transitions.setupTransition({
          transition: x,
          name: "bullet-quartile-update-enter",
          animate: e
        })
      ).attr("d", ({ datum: x, value: y }) => {
        let w = 4;
        x.ranges && x.ranges.indexOf(y) !== -1 && (w = 8);
        const A = this.services.cartesianScales.getDomainValue(x) - w / 2, L = A + w, I = this.services.cartesianScales.getRangeValue(y);
        return Ee(
          { x0: A, x1: L, y0: I, y1: I },
          this.services.cartesianScales.getOrientation()
        );
      }).attr("opacity", 1);
    };
    p(), h(), u(), g(), this.addEventListeners();
  }
  addEventListeners() {
    const e = this, t = this.getOptions(), { groupMapsTo: n } = t.data, s = this.services.cartesianScales.getRangeIdentifier(), { code: a, number: i } = v(t, "locale");
    this.parent.selectAll("path.bar").on("mouseover", function(r, l) {
      const c = T(this);
      c.classed("hovered", !0), e.services.events.dispatchEvent(f.Bar.BAR_MOUSEOVER, {
        event: r,
        element: c,
        datum: l
      });
      const d = v(t, "bullet", "performanceAreaTitles"), p = e.model.getMatchingRangeIndexForDatapoint(l);
      e.services.events.dispatchEvent(f.Tooltip.SHOW, {
        event: r,
        hoveredElement: c,
        items: [
          {
            label: v(t, "locale", "translations", "group") || v(t, "tooltip", "groupLabel") || "Group",
            value: l[n],
            class: e.model.getColorClassName({
              classNameTypes: [z.TOOLTIP],
              dataGroupName: l[n]
            })
          },
          {
            label: "Value",
            value: l[s]
          },
          {
            label: "Target",
            value: l.marker
          },
          {
            label: "Percentage",
            value: `${i(Math.floor(l[s] / l.marker * 100), a)}%`
          },
          {
            label: "Performance",
            value: d[p]
          }
        ]
      });
    }).on("mousemove", function(r, l) {
      e.services.events.dispatchEvent(f.Bar.BAR_MOUSEMOVE, {
        event: r,
        element: T(this),
        datum: l
      }), e.services.events.dispatchEvent(f.Tooltip.MOVE, {
        event: r
      });
    }).on("click", function(r, l) {
      e.services.events.dispatchEvent(f.Bar.BAR_CLICK, {
        event: r,
        element: T(this),
        datum: l
      });
    }).on("mouseout", function(r, l) {
      const c = T(this);
      c.classed("hovered", !1), e.services.events.dispatchEvent(f.Bar.BAR_MOUSEOUT, {
        event: r,
        element: c,
        datum: l
      }), e.services.events.dispatchEvent(f.Tooltip.HIDE, {
        hoveredElement: c
      });
    });
  }
  destroy() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const e = this.services.events;
    e.removeEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.removeEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
function Tl(o) {
  return o;
}
function xl(o) {
  if (o == null)
    return Tl;
  var e, t, n = o.scale[0], s = o.scale[1], a = o.translate[0], i = o.translate[1];
  return function(r, l) {
    l || (e = t = 0);
    var c = 2, d = r.length, p = new Array(d);
    for (p[0] = (e += r[0]) * n + a, p[1] = (t += r[1]) * s + i; c < d; )
      p[c] = r[c], ++c;
    return p;
  };
}
function Ll(o, e) {
  for (var t, n = o.length, s = n - e; s < --n; )
    t = o[s], o[s++] = o[n], o[n] = t;
}
function Al(o, e) {
  return typeof e == "string" && (e = o.objects[e]), e.type === "GeometryCollection" ? { type: "FeatureCollection", features: e.geometries.map(function(t) {
    return Xs(o, t);
  }) } : Xs(o, e);
}
function Xs(o, e) {
  var t = e.id, n = e.bbox, s = e.properties == null ? {} : e.properties, a = jn(o, e);
  return t == null && n == null ? { type: "Feature", properties: s, geometry: a } : n == null ? { type: "Feature", id: t, properties: s, geometry: a } : { type: "Feature", id: t, bbox: n, properties: s, geometry: a };
}
function jn(o, e) {
  var t = xl(o.transform), n = o.arcs;
  function s(d, p) {
    p.length && p.pop();
    for (var h = n[d < 0 ? ~d : d], u = 0, g = h.length; u < g; ++u)
      p.push(t(h[u], u));
    d < 0 && Ll(p, g);
  }
  function a(d) {
    return t(d);
  }
  function i(d) {
    for (var p = [], h = 0, u = d.length; h < u; ++h)
      s(d[h], p);
    return p.length < 2 && p.push(p[0]), p;
  }
  function r(d) {
    for (var p = i(d); p.length < 4; )
      p.push(p[0]);
    return p;
  }
  function l(d) {
    return d.map(r);
  }
  function c(d) {
    var p = d.type, h;
    switch (p) {
      case "GeometryCollection":
        return { type: p, geometries: d.geometries.map(c) };
      case "Point":
        h = a(d.coordinates);
        break;
      case "MultiPoint":
        h = d.coordinates.map(a);
        break;
      case "LineString":
        h = i(d.arcs);
        break;
      case "MultiLineString":
        h = d.arcs.map(i);
        break;
      case "Polygon":
        h = l(d.arcs);
        break;
      case "MultiPolygon":
        h = d.arcs.map(l);
        break;
      default:
        return null;
    }
    return { type: p, coordinates: h };
  }
  return c(e);
}
function wl(o, e) {
  var t = {}, n = {}, s = {}, a = [], i = -1;
  e.forEach(function(c, d) {
    var p = o.arcs[c < 0 ? ~c : c], h;
    p.length < 3 && !p[1][0] && !p[1][1] && (h = e[++i], e[i] = c, e[d] = h);
  }), e.forEach(function(c) {
    var d = r(c), p = d[0], h = d[1], u, g;
    if (u = s[p])
      if (delete s[u.end], u.push(c), u.end = h, g = n[h]) {
        delete n[g.start];
        var m = g === u ? u : u.concat(g);
        n[m.start = u.start] = s[m.end = g.end] = m;
      } else
        n[u.start] = s[u.end] = u;
    else if (u = n[h])
      if (delete n[u.start], u.unshift(c), u.start = p, g = s[p]) {
        delete s[g.end];
        var E = g === u ? u : g.concat(u);
        n[E.start = g.start] = s[E.end = u.end] = E;
      } else
        n[u.start] = s[u.end] = u;
    else
      u = [c], n[u.start = p] = s[u.end = h] = u;
  });
  function r(c) {
    var d = o.arcs[c < 0 ? ~c : c], p = d[0], h;
    return o.transform ? (h = [0, 0], d.forEach(function(u) {
      h[0] += u[0], h[1] += u[1];
    })) : h = d[d.length - 1], c < 0 ? [h, p] : [p, h];
  }
  function l(c, d) {
    for (var p in c) {
      var h = c[p];
      delete d[h.start], delete h.start, delete h.end, h.forEach(function(u) {
        t[u < 0 ? ~u : u] = 1;
      }), a.push(h);
    }
  }
  return l(s, n), l(n, s), e.forEach(function(c) {
    t[c < 0 ? ~c : c] || a.push([c]);
  }), a;
}
function Ml(o) {
  for (var e = -1, t = o.length, n, s = o[t - 1], a = 0; ++e < t; )
    n = s, s = o[e], a += n[0] * s[1] - n[1] * s[0];
  return Math.abs(a);
}
function Cl(o) {
  return jn(o, _l.apply(this, arguments));
}
function _l(o, e) {
  var t = {}, n = [], s = [];
  e.forEach(a);
  function a(l) {
    switch (l.type) {
      case "GeometryCollection":
        l.geometries.forEach(a);
        break;
      case "Polygon":
        i(l.arcs);
        break;
      case "MultiPolygon":
        l.arcs.forEach(i);
        break;
    }
  }
  function i(l) {
    l.forEach(function(c) {
      c.forEach(function(d) {
        (t[d = d < 0 ? ~d : d] || (t[d] = [])).push(l);
      });
    }), n.push(l);
  }
  function r(l) {
    return Ml(jn(o, { type: "Polygon", arcs: [l] }).coordinates[0]);
  }
  return n.forEach(function(l) {
    if (!l._) {
      var c = [], d = [l];
      for (l._ = 1, s.push(c); l = d.pop(); )
        c.push(l), l.forEach(function(p) {
          p.forEach(function(h) {
            t[h < 0 ? ~h : h].forEach(function(u) {
              u._ || (u._ = 1, d.push(u));
            });
          });
        });
    }
  }), n.forEach(function(l) {
    delete l._;
  }), {
    type: "MultiPolygon",
    arcs: s.map(function(l) {
      var c = [], d;
      if (l.forEach(function(m) {
        m.forEach(function(E) {
          E.forEach(function(O) {
            t[O < 0 ? ~O : O].length < 2 && c.push(O);
          });
        });
      }), c = wl(o, c), (d = c.length) > 1)
        for (var p = 1, h = r(c[0]), u, g; p < d; ++p)
          (u = r(c[p])) > h && (g = c[0], c[0] = c[p], c[p] = g, h = u);
      return c;
    }).filter(function(l) {
      return l.length > 0;
    })
  };
}
class Rh extends Ia {
  constructor() {
    super(...arguments), this.type = "ruler-binned", this.renderType = j.SVG;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  showRuler(e, [t, n]) {
    const s = this.parent, a = this.model.getOptions(), { cartesianScales: i } = this.services, r = i.getOrientation(), l = i.getRangeScale(), [c, d] = l.range(), p = i.getDomainScale(), h = p.invert(
      r === xe.VERTICAL ? t : n
    ), u = S.appendOrSelect(s, "g.ruler").attr("aria-label", "ruler"), g = S.appendOrSelect(u, "line.ruler-line"), E = s.selectAll("[role=graphics-symbol]").filter((O) => {
      if (parseFloat(ne(O, "data.x0")) <= h && parseFloat(ne(O, "data.x1")) >= h)
        return !0;
    });
    if (E.size() > 0) {
      this.elementsToHighlight && this.elementsToHighlight.size() > 0 && !Oa(this.elementsToHighlight, E) && this.hideRuler(), E.dispatch("mouseover"), this.elementsToHighlight = E;
      const O = T(E.nodes()[0]).datum(), x = parseFloat(ne(O, "data.x0")), y = parseFloat(ne(O, "data.x1")), w = this.model.getActiveDataGroupNames(), A = w.reverse().map((I) => ({
        label: I,
        value: ne(O, `data.${I}`),
        class: this.model.getColorClassName({
          classNameTypes: [z.TOOLTIP],
          dataGroupName: I
        })
      })).filter((I) => I.value !== 0);
      if (A.length > 0) {
        this.services.events.dispatchEvent(f.Tooltip.SHOW, {
          mousePosition: [t, n],
          hoveredElement: g,
          items: [
            {
              label: ne(a, "bins.rangeLabel") || "Range",
              value: `${x} – ${y}`
            },
            ...A,
            ...v(a, "tooltip", "showTotal") === !0 ? [
              {
                label: ne(a, "locale.translations.total") || ne(a, "tooltip.totalLabel") || "Total",
                value: w.reduce(
                  (P, W) => P + parseFloat(ne(O, `data.${W}`)),
                  0
                )
              }
            ] : []
          ]
        }), u.attr("opacity", 1);
        const I = p((x + y) / 2);
        r === "horizontal" ? g.attr("x1", d).attr("x2", c).attr("y1", I).attr("y2", I) : g.attr("y1", d).attr("y2", c).attr("x1", I).attr("x2", I);
      } else
        this.hideRuler();
    } else
      this.hideRuler();
  }
}
class kh extends Ia {
  formatTooltipData(e) {
    return e.reverse();
  }
}
const Dh = (o, e) => {
  const t = o.x, n = o.y, s = e.x, a = e.y, i = $n();
  return i.moveTo(t, n), i.lineTo(s, a), i.toString();
}, Ph = (o, e, t = 0.5) => {
  const n = o.x, s = o.y, a = e.x, i = e.y, r = $n();
  return r.moveTo(n, s), r.lineTo(n + (a - n) * t, s), r.lineTo(n + (a - n) * t, i), r.lineTo(a, i), r.toString();
}, Nh = (o, e, t, n, s, a) => {
  const i = o.x, r = o.y, l = e.x, c = e.y, d = $n();
  return d.moveTo(i, r), d.bezierCurveTo(t, n, s, a, l, c), d.toString();
}, Vh = {
  d: "M7 0v8L0 4z",
  height: 8,
  width: 7.5,
  id: "arrowLeft"
}, Bh = {
  d: "M0 0v8l7-4z",
  height: 8,
  width: 7.5,
  id: "arrowRight"
}, Gh = {
  d: "M5.32 9.513a4.75 4.75 0 100-9.5 4.75 4.75 0 000 9.5z",
  height: 10,
  width: 10,
  id: "circle"
}, Hh = {
  d: "M5.03517654-1e-7l4.99999996 5-4.99999996 5-5-5L2.4517844 2.58339204z",
  height: 10,
  width: 10,
  id: "diamond"
}, $h = {
  d: "M0 .44974747h8v8H0v-3.6830331z",
  height: 9,
  width: 8,
  id: "square"
}, Uh = {
  d: "M0 0h1.5v8H0z",
  height: 8,
  width: 2,
  id: "tee"
};
class Fh extends vl {
  constructor(e, t, n) {
    super(e, t, n), this.type = "color-legend", this.renderType = j.SVG, this.gradient_id = `gradient-id-${Math.floor(Math.random() * 99999999999)}`, this.handleAxisCompleteEvent = () => {
      const s = this.getComponentContainer(), { width: a } = S.getSVGElementSize(s, {
        useAttrs: !0
      }), i = v(this.getOptions(), "data", "loading");
      if (a > he.color.barWidth && !i) {
        const r = v(this.getOptions(), "heatmap", "colorLegend", "title"), { cartesianScales: l } = this.services, d = l.getMainXScale().range();
        if (d[0] > 1 && (s.select("g.legend").attr("transform", `translate(${d[0]}, 0)`), r)) {
          const { width: p } = S.getSVGElementSize(
            s.select("g.legend-title").select("text"),
            { useBBox: !0 }
          ), h = d[0] - p - 9;
          h > 1 ? s.select("g.legend-title").attr("transform", `translate(${h}, 0)`) : (s.select("g.legend").attr("transform", `translate(${d[0]}, 16)`), s.select("g.legend-title").attr("transform", `translate(${d[0]}, 0)`));
        }
      } else
        s.select("g.legend-title").attr("transform", "translate(0, 0)");
    }, this.chartType = n.chartType;
  }
  init() {
    this.chartType === "heatmap" && this.services.events.addEventListener(f.Axis.RENDER_COMPLETE, this.handleAxisCompleteEvent);
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e = !1) {
    const t = this.getOptions(), n = this.getComponentContainer(), { width: s } = S.getSVGElementSize(n, {
      useAttrs: !0
    }), a = v(t, "color", "gradient", "colors"), i = v(t, this.chartType, "colorLegend", "type");
    let r = v(t, "color", "pairing", "option");
    const l = v(t, "heatmap", "colorLegend", "title");
    if (v(this.getOptions(), "data", "loading")) {
      n.html("");
      return;
    }
    const d = !ta(a), p = ei(this.model.getDisplayData()), h = !(s <= he.color.barWidth), u = h ? he.color.barWidth : s, g = S.appendOrSelect(n, "g.legend"), m = S.appendOrSelect(g, "g.legend-axis");
    if (l) {
      const k = S.appendOrSelect(n, "g.legend-title");
      S.appendOrSelect(k, "text").text(l).attr("dy", "0.7em"), g.attr("transform", "translate(0, 16)");
    }
    const E = p[0] < 0 && p[1] > 0 ? "diverge" : "mono";
    (r < 1 && r > 4 && E === "mono" || r < 1 && r > 2 && E === "diverge") && (r = 1);
    let O = [];
    const x = E === "diverge" ? 17 : 11;
    if (d)
      O = a;
    else
      for (let k = 1; k < x + 1; k++)
        O.push(
          i === rn.LINEAR ? `stop-color-${E}-${r}-${k}` : `fill-${E}-${r}-${k}`
        );
    const y = aa(p[0], p[1]), w = ri(y, 3), A = qe().domain(p).range([0, u]), L = Hn(A).tickSize(0).tickValues(w), { code: I, number: P } = v(t, "locale");
    L.tickFormat((k) => P(k, I));
    let W;
    switch (i) {
      case rn.LINEAR:
        this.drawLinear(O, g, u);
        break;
      case rn.QUANTIZE:
        W = this.drawQuantize(
          O,
          E,
          d,
          g,
          u
        ), A.range([W, u]);
        break;
      default:
        throw Error("Entered color legend type is not supported.");
    }
    m.attr("transform", `translate(0,${he.color.axisYTranslation})`).call(L), m.select(".domain").remove(), m.select("g.tick:last-of-type text").style("text-anchor", h ? "middle" : "end"), m.select("g.tick:first-of-type text").style(
      "text-anchor",
      h && this.chartType !== "choropleth" ? "middle" : "start"
    );
  }
  // Renders gradient legend
  drawLinear(e, t, n) {
    const s = 100 / (e.length - 1);
    S.appendOrSelect(t, "linearGradient").attr("id", `${this.gradient_id}-legend`).selectAll("stop").data(e).enter().append("stop").attr("offset", (r, l) => `${l * s}%`).attr("class", (r, l) => e[l]).attr("stop-color", (r) => r), S.appendOrSelect(t, "rect").attr("width", n).attr("height", he.color.barHeight).style("fill", `url(#${this.gradient_id}-legend)`);
  }
  /**
   * Renders quantized legend
   * @returns number (range start)
   */
  drawQuantize(e, t, n, s, a) {
    !n && t === "diverge" && e.splice(e.length / 2, 1);
    const i = Un().domain(e).range([0, a]);
    return S.appendOrSelect(s, "g.quantized-rect").selectAll("rect").data(i.domain()).join("rect").attr("x", (l) => i(l)).attr("y", 0).attr("width", Math.max(0, i.bandwidth() - 1)).attr("height", he.color.barHeight).attr("class", (l) => l).attr("fill", (l) => l), (!n && t) === "mono" ? i.bandwidth() - 1 : 0;
  }
  destroy() {
    this.chartType === "heatmap" && this.services.events.removeEventListener(f.Axis.RENDER_COMPLETE, this.handleAxisCompleteEvent);
  }
}
class zh extends fl {
  constructor() {
    super(...arguments), this.type = "meter-title", this.renderType = j.SVG;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e = !1) {
    const t = v(this.model.getDisplayData(), 0), n = this.getOptions(), s = this.getComponentContainer(), { groupMapsTo: a } = n.data, i = n.locale.translations.meter.title;
    if (v(n, "meter", "proportional"))
      this.displayTotal(), this.displayBreakdownTitle();
    else {
      const d = s.selectAll("text.meter-title").data(i ? [i] : [t[a]]);
      d.enter().append("text").classed("meter-title", !0).merge(d).attr("x", 0).attr("y", "1em").text((p) => p), d.exit().remove(), this.appendPercentage();
    }
    this.displayStatus();
    const l = this.getMaxTitleWidth(), c = S.appendOrSelect(s, "text.meter-title");
    l > 0 && c.node().getComputedTextLength() > l && this.truncateTitle(c, l);
  }
  displayBreakdownTitle() {
    const e = this.getComponentContainer(), t = this.getOptions(), n = this.model.getMaximumDomain(
      this.model.getDisplayData()
    ), s = v(t, "meter", "proportional", "total"), a = v(t, "meter", "proportional", "unit") ? v(t, "meter", "proportional", "unit") : "";
    let i;
    if (n === s)
      i = null;
    else {
      const d = s !== null ? s - n : n, p = v(t, "meter", "proportional", "breakdownFormatter"), { code: h, number: u } = v(t, "locale");
      i = p !== null ? p({
        datasetsTotal: n,
        total: s
      }) : `${u(n, h)} ${a} used (${u(d, h)} ${a} available)`;
    }
    const r = e.selectAll("text.proportional-meter-title").data([i]);
    r.enter().append("text").classed("proportional-meter-title", !0).merge(r).attr("x", 0).attr("y", "1em").text((d) => d), r.exit().remove();
    const l = this.getMaxTitleWidth(), c = S.appendOrSelect(e, "text.proportional-meter-title");
    l > 0 && c.node().getComputedTextLength() > l && this.truncateTitle(c, l);
  }
  // show the total for prop meter
  displayTotal() {
    const e = this.getComponentContainer(), t = this.getOptions(), n = v(t, "meter", "proportional", "total"), s = n ? v(t, "meter", "proportional", "total") : this.model.getMaximumDomain(this.model.getDisplayData()), a = v(t, "meter", "proportional", "unit") ? v(t, "meter", "proportional", "unit") : "", i = v(t, "meter", "proportional", "totalFormatter"), { code: r, number: l } = v(t, "locale"), c = i !== null ? i(s) : `${l(n, r)} ${a} total`, d = S.getHTMLElementSize(this.parent.node()).width, p = e.selectAll("text.proportional-meter-total").data([c]);
    p.enter().append("text").classed("proportional-meter-total", !0).merge(p).attr(
      "x",
      this.model.getStatus() && typeof d != "string" ? d - ge.total.paddingRight : d
    ).attr("y", "1em").attr("text-anchor", "end").text((h) => h), p.exit().remove();
  }
  /**
   * Appends the corresponding status based on the value and the peak.
   */
  displayStatus() {
    const e = this, t = this.getComponentContainer(), n = S.getHTMLElementSize(this.parent.node()).width || 0, s = this.model.getStatus(), a = ge.status.indicatorSize / 2, i = S.appendOrSelect(t, "g.status-indicator").attr("class", s !== null ? `status-indicator status--${s}` : "").attr("transform", `translate(${n - a}, 0)`), r = s ? [s] : [], l = i.selectAll("circle.status").data(r);
    l.enter().append("circle").merge(l).attr("class", "status").attr("r", a).attr("cx", 0).attr("cy", 8);
    const c = i.selectAll("path.innerFill").data(r);
    c.enter().append("path").merge(c).attr("d", e.getStatusIconPathString(s)).attr("transform", `translate(-${a}, 0)`).attr("class", "innerFill"), c.exit().remove(), l.exit().remove();
  }
  /**
   * Appends the associated percentage to the end of the title
   */
  appendPercentage() {
    const e = v(this.model.getDisplayData(), 0, "value"), { code: t, number: n } = v(this.getOptions(), "locale"), s = this.getComponentContainer(), a = S.appendOrSelect(s, "text.meter-title"), i = v(this.getOptions(), "meter", "statusBar", "percentageIndicator", "enabled") === !0 ? [e] : [], r = s.selectAll("text.percent-value").data(i), l = ge.statusBar.paddingRight;
    r.enter().append("text").classed("percent-value", !0).merge(r).text((c) => `${c != null ? n(c, t) : 0}%`).attr("x", +a.attr("x") + a.node().getComputedTextLength() + l).attr("y", a.attr("y")), r.exit().remove();
  }
  /**
   * Uses the parent class truncate logic
   * @param title d3 selection of title element that will be truncated
   * @param titlestring the original string that needs truncation
   * @param maxWidth the max width the title can take
   */
  truncateTitle(e, t) {
    super.truncateTitle(e, t);
    const n = S.appendOrSelect(this.parent, "tspan"), s = ge.statusBar.paddingRight, a = Math.ceil(n.node().getComputedTextLength());
    S.appendOrSelect(this.parent, "text.percent-value").attr(
      "x",
      +e.attr("x") + e.node().getComputedTextLength() + a + s
    );
  }
  // computes the maximum space a title can take
  getMaxTitleWidth() {
    const e = v(this.getOptions(), "meter", "proportional"), t = S.getHTMLElementSize(this.parent.node()).width;
    if (e !== null) {
      const n = S.appendOrSelect(this.parent, "text.proportional-meter-total").node(), s = S.getSVGElementSize(n, {
        useBBox: !0
      }).width;
      return t - s - ge.total.paddingLeft;
    } else {
      const n = S.appendOrSelect(this.parent, "text.percent-value"), s = ge.statusBar.paddingRight, a = n.node().getComputedTextLength(), i = S.appendOrSelect(this.parent, "g.status-indicator").node(), r = S.getSVGElementSize(i, { useBBox: !0 }).width + ge.status.paddingLeft;
      return t - a - s - r;
    }
  }
  /**
   * Get the associated status icon for the data
   * @param status the active status for the meter chart
   */
  getStatusIconPathString(e) {
    switch (e) {
      case on.SUCCESS:
        return "M6.875 11.3125 3.75 8.1875 4.74375 7.25 6.875 9.34375 11.50625 4.75 12.5 5.7375 Z";
      case on.DANGER:
        return "M10.7 11.5 4.5 5.3 5.3 4.5 11.5 10.7 Z";
      case on.WARNING:
        return "M7.9375,11.125 C7.41973305,11.125 7,11.544733 7,12.0625 C7,12.580267 7.41973305,13 7.9375,13 C8.45526695,13 8.875,12.580267 8.875,12.0625 C8.875,11.544733 8.45526695,11.125 7.9375,11.125 M7.3125, 3 8.5625, 3 8.5625, 9.875 7.3125, 9.875, 7.3125, 3 Z";
    }
  }
}
class Xn extends Y {
  // Gets the correct width for bars based on options & configurations
  getBarWidth() {
    const e = this.getOptions();
    if (e.bars.width)
      return e.bars.width;
    const t = this.model.getDisplayData().length, n = this.services.cartesianScales.getMainXScale(), s = S.getSVGElementSize(this.parent, {
      useAttrs: !0
    }).width;
    if (!n.step) {
      const a = v(e, "bars", "spacingFactor");
      return Math.min(e.bars.maxWidth, s * a / t);
    }
    return Math.min(e.bars.maxWidth, n.step() / 2);
  }
  isOutsideZoomedDomain(e, t) {
    if (this.model.getDisplayData().length <= 1)
      return !1;
    const s = this.model.get("zoomDomain");
    if (s !== void 0) {
      const a = this.services.cartesianScales.getDomainScale();
      return e < a(s[0]) || t > a(s[1]);
    }
    return !1;
  }
}
class Wh extends Y {
  constructor() {
    super(...arguments), this.type = "circle-pack", this.renderType = j.SVG, this.handleLegendOnHover = (e) => {
      const { hoveredElement: t } = e.detail;
      this.parent.selectAll("circle.node").transition("legend-hover-circlepack").call(
        (n) => this.services.transitions.setupTransition({
          transition: n,
          name: "legend-hover-circlepack"
        })
      ).attr("opacity", (n) => n.data.dataGroupName === t.datum().name ? 1 : yt.circles.fillOpacity);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("circle.node").transition("legend-mouseout-circlepack").call(
        (e) => this.services.transitions.setupTransition({
          transition: e,
          name: "legend-mouseout-circlepack"
        })
      ).attr("opacity", 1);
    };
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e = !0) {
    const t = this.getComponentContainer({ withinChartClip: !0 }), { width: n, height: s } = S.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    if (n < 1 || s < 1)
      return;
    let a = this.model.getDisplayData();
    const i = this.model.hasParentNode(), r = this.model.getHierarchyLevel(), l = this.getOptions(), c = v(l, "canvasZoom", "enabled");
    i && v(a, 0, "children") && (a = v(a, 0, "children"));
    const d = Fn({ children: a }).sum((m) => m.value).sort((m, E) => E.value - m.value), h = oi().size([n, s]).padding((m) => m.depth >= 1 ? yt.padding.children + 3 : yt.padding.mainGroup + 3)(d).descendants().splice(1).filter((m) => m.depth <= r), u = t.selectAll("circle.node").data(h);
    u.exit().attr("width", 0).attr("height", 0).remove();
    const g = u.enter().append("circle").classed("node", !0);
    g.merge(u).attr("class", (m) => {
      const E = c && r === 3 ? this.getZoomClass(m) : "";
      return this.model.getColorClassName({
        classNameTypes: [z.FILL, z.STROKE],
        dataGroupName: m.data.dataGroupName,
        originalClassName: m.children ? `node ${E}` : `node node-leaf ${E}`
      });
    }).style("fill", (m) => this.model.getFillColor(m.data.dataGroupName, null, m.data)).style("stroke", (m) => this.model.getFillColor(m.data.dataGroupName, null, m.data)).attr("cx", (m) => m.x).attr("cy", (m) => m.y).transition("circlepack-leaf-update-enter").call(
      (m) => this.services.transitions.setupTransition({
        transition: m,
        name: "circlepack-leaf-update-enter"
      })
    ).attr("r", (m) => m.r).attr("opacity", 1).attr("fill-opacity", yt.circles.fillOpacity), c === !0 && this.focal && (this.services.canvasZoom.zoomIn(this.focal, g, _t), this.setBackgroundListeners()), i || this.addLegendListeners(), this.addEventListeners();
  }
  // turn off the highlight class on children circles
  unhighlightChildren(e) {
    const t = e.map((n) => n.data);
    this.parent.selectAll("circle.node").filter((n) => t.some((s) => s === n.data) && n.depth > 1).style("stroke", (n) => this.model.getFillColor(n.data.dataGroupName, null, n.data));
  }
  // highlight the children circles with a stroke
  highlightChildren(e) {
    const t = e.map((n) => n.data);
    this.parent.selectAll("circle.node").filter((n) => t.some((s) => s === n.data) && n.depth > 1).style("stroke", yt.circles.hover.stroke);
  }
  getZoomClass(e) {
    return this.model.getHierarchyLevel() === 3 && this.focal && (e.data === this.focal.data || this.focal.children.some((t) => t.data === e.data)) ? "focal" : "non-focal";
  }
  addLegendListeners() {
    const { events: e } = this.services;
    e.addEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.addEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  removeBackgroundListeners() {
    T(this.services.domUtils.getMainContainer()).on("click", () => null);
  }
  setBackgroundListeners() {
    const e = T(this.services.domUtils.getMainContainer()), t = this, n = this.parent.selectAll("circle.node");
    e.on("click", () => {
      t.focal = null, t.model.updateHierarchyLevel(2), e.classed("zoomed-in", !1), t.services.canvasZoom.zoomOut(n, _t);
    });
  }
  // Zoom icon to be appended to the label in the tooltip
  getZoomIcon() {
    return `
		<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 10 10">
			<polygon points="5.93 3.71 4.45 3.71 4.45 2.23 3.71 2.23 3.71 3.71 2.23 3.71 2.23 4.45 3.71 4.45 3.71 5.93 4.45 5.93 4.45 4.45 5.93 4.45 5.93 3.71"/>
			<path d="M7.2,6.67a4,4,0,0,0,1-2.59A4.08,4.08,0,1,0,4.07,8.15h0a4,4,0,0,0,2.59-1L9.48,10,10,9.48Zm-3.12.77A3.34,3.34,0,1,1,7.41,4.08,3.34,3.34,0,0,1,4.08,7.44Z"/>
		</svg>`;
  }
  // add event listeners for tooltip on the circles
  addEventListeners() {
    const e = this;
    this.parent.selectAll("circle.node").on("mouseover", function(t, n) {
      const s = T(this);
      s.classed("hovered", !0);
      const a = e.model.getHierarchyLevel(), i = a > 2 && !s.classed("focal"), r = v(e.model.getOptions(), "canvasZoom", "enabled");
      let l = !1;
      if (!i) {
        let c = [], d = [], p = null;
        if (n.children) {
          n.depth > 1 && r && (l = !0, s.classed("clickable", !0)), c = n.children.map((g) => {
            if (g !== null)
              return typeof g.data.value == "number" ? {
                label: g.data.name,
                value: g.data.value
              } : {
                label: g.data.name,
                labelIcon: r && a <= 2 ? e.getZoomIcon() : null,
                value: g.value
              };
          });
          const u = e.model.getOptions();
          d = [
            {
              label: ne(u, "locale.translations.total") || ne(u, "tooltip.totalLabel") || "Total",
              value: n.value,
              bold: !0
            }
          ], e.highlightChildren(n.children);
        } else
          p = n.value;
        const h = getComputedStyle(this, null).getPropertyValue("fill");
        e.services.events.dispatchEvent(f.Tooltip.SHOW, {
          event: t,
          hoveredElement: s,
          items: [
            {
              color: h,
              label: n.data.name,
              labelIcon: l && r && a <= 2 ? e.getZoomIcon() : null,
              value: p
            },
            ...c,
            ...d
          ]
        });
      }
      e.services.events.dispatchEvent(f.CirclePack.CIRCLE_MOUSEOVER, {
        event: t,
        element: s,
        datum: n
      });
    }).on("mousemove", function(t, n) {
      const s = T(this);
      e.services.events.dispatchEvent(f.CirclePack.CIRCLE_MOUSEMOVE, {
        event: t,
        element: s,
        datum: n
      }), e.services.events.dispatchEvent(f.Tooltip.MOVE, {
        event: t
      });
    }).on("mouseout", function(t, n) {
      const s = T(this);
      s.classed("hovered", !1), n.children && e.unhighlightChildren(n.children), e.services.events.dispatchEvent(f.CirclePack.CIRCLE_MOUSEOUT, {
        event: t,
        element: s,
        datum: n
      }), e.services.events.dispatchEvent(f.Tooltip.HIDE, {
        hoveredElement: s
      });
    }).on("click", function(t, n) {
      const s = T(this), a = s.classed("non-focal"), i = v(e.model.getOptions(), "canvasZoom", "enabled");
      if (i && e.model.getHierarchyLevel() > 2) {
        const r = e.parent.selectAll("circle.node");
        T(e.services.domUtils.getMainContainer()).classed("zoomed-in", !1), e.focal = null, e.model.updateHierarchyLevel(2), e.services.canvasZoom.zoomOut(r, _t);
      } else if (n.depth === 2 && n.children && !a && i) {
        const r = e.parent.selectAll("circle.node");
        T(e.services.domUtils.getMainContainer()).classed("zoomed-in", !0), e.focal = n, e.model.updateHierarchyLevel(3), e.services.canvasZoom.zoomIn(n, r, _t), t.stopPropagation();
      }
      e.services.events.dispatchEvent(f.CirclePack.CIRCLE_CLICK, {
        event: t,
        element: s,
        datum: n
      });
    });
  }
  destroy() {
    this.parent.selectAll("circle.node").on("mouseover", null).on("mousemove", null).on("mouseout", null).on("click", null);
    const e = this.services.events;
    e.removeEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.removeEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut), this.removeBackgroundListeners();
  }
}
function Il(o, e) {
  const t = ci(this._current, o);
  return (n) => (this._current = t(n), e(this._current));
}
class Rl extends Y {
  constructor() {
    super(...arguments), this.type = "pie", this.renderType = j.SVG, this.isRendering = !1, this.handleLegendOnHover = (e) => {
      const { hoveredElement: t } = e.detail, { groupMapsTo: n } = this.getOptions().data;
      this.parent.selectAll("path.slice").transition("legend-hover-bar").call(
        (s) => this.services.transitions.setupTransition({
          transition: s,
          name: "legend-hover-bar"
        })
      ).attr(
        "opacity",
        (s) => s.data[n] !== t.datum().name ? 0.3 : 1
      );
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.slice").transition("legend-mouseout-bar").call(
        (e) => this.services.transitions.setupTransition({
          transition: e,
          name: "legend-mouseout-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const e = this.services.events;
    e.addEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.addEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  getInnerRadius() {
    return te.innerRadius;
  }
  render(e = !0) {
    const t = this, n = this.getComponentContainer(), s = this.getOptions(), { groupMapsTo: a } = s.data, { valueMapsTo: i } = s.pie;
    this.isRendering = !0;
    const r = this.model.getDisplayData().filter((M) => M[i] > 0), l = this.computeRadius();
    this.arc = Lt().innerRadius(this.getInnerRadius()).outerRadius(l), this.hoverArc = Lt().innerRadius(this.getInnerRadius()).outerRadius(l + te.hoverArc.outerRadiusOffset);
    const d = li().value((M) => M[i]).sort(v(s, "pie", "sortFunction")).padAngle(te.padAngle)(r), h = S.appendOrSelect(n, "g.slices").attr("role", X.GROUP).attr("data-name", "slices").selectAll("path.slice").data(d, (M) => M.data[a]);
    h.exit().attr("opacity", 0).remove(), h.enter().append("path").classed("slice", !0).attr("opacity", 0).merge(h).attr(
      "class",
      (M) => this.model.getColorClassName({
        classNameTypes: [z.FILL],
        dataGroupName: M.data[a],
        originalClassName: "slice"
      })
    ).style("fill", (M) => t.model.getFillColor(M.data[a], null, M.data)).attr("d", this.arc).transition().call(
      (M) => this.services.transitions.setupTransition({
        transition: M,
        name: "pie_slice_enter_update",
        animate: e
      })
    ).attr("opacity", 1).attr("role", X.GRAPHICS_SYMBOL).attr("aria-roledescription", "slice").attr(
      "aria-label",
      (M) => `${M[i]}, ${sn(M.data[i], r, i) + "%"}`
    ).attrTween("d", function(M) {
      return Il.bind(this)(M, t.arc);
    }).on("end", () => {
      t.isRendering = !1;
    });
    const { code: m, number: E } = v(s, "locale"), O = s.pie.labels.enabled, x = O ? d.filter((M) => M.data[i] > 0) : [], w = S.appendOrSelect(n, "g.labels").attr("role", X.GROUP).attr("data-name", "labels").selectAll("text.pie-label").data(x, (M) => M.data[a]);
    w.exit().attr("opacity", 0).remove();
    const A = w.enter().append("text").classed("pie-label", !0), L = [];
    A.merge(w).style("text-anchor", "middle").text((M) => s.pie.labels.formatter ? s.pie.labels.formatter({
      ...M,
      percentageValue: sn(
        M.data[i],
        r,
        i,
        !0
      )
    }) : E(
      sn(M.data[i], r, i),
      m
    ) + "%").datum(function(M) {
      const J = l + 7, me = (M.endAngle - M.startAngle) / 2 + M.startAngle, q = me / Math.PI * 180, H = this.getComputedTextLength();
      return M.textOffsetX = H / 2, M.textOffsetY = q > 90 && q < 270 ? 10 : 0, M.xPosition = (M.textOffsetX + J) * Math.sin(me), M.yPosition = (M.textOffsetY + J) * -Math.cos(me), M;
    }).attr("transform", function(M, J) {
      const me = x.length, q = (M.endAngle - M.startAngle) * (180 / Math.PI);
      if (J >= me - 2 && q < te.callout.minSliceDegree) {
        let H, ae;
        return M.index === me - 1 ? (H = M.xPosition + te.callout.offsetX + te.callout.textMargin + M.textOffsetX, ae = M.yPosition - te.callout.offsetY, M.direction = ln.RIGHT, L.push(M)) : (H = M.xPosition - te.callout.offsetX - M.textOffsetX - te.callout.textMargin, ae = M.yPosition - te.callout.offsetY, M.direction = ln.LEFT, L.push(M)), `translate(${H}, ${ae})`;
      }
      return `translate(${M.xPosition}, ${M.yPosition})`;
    }), this.renderCallouts(L);
    const I = v(s, "donut") ? "donut" : "pie", P = v(s, I, "alignment"), { width: W } = S.getSVGElementSize(this.getParent(), {
      useAttrs: !0
    }), k = O ? te.xOffset : 0, C = O ? te.yOffset : 0;
    let V = l + k;
    P === Ce.CENTER ? V = W / 2 : P === Ce.RIGHT && (V = W - l - te.xOffset);
    let F = l + C;
    L.length > 0 && (F += te.yOffsetCallout), n.attr("x", V + 7).attr("y", F), this.addEventListeners();
  }
  renderCallouts(e) {
    const t = S.appendOrSelect(this.getComponentContainer(), "g.callouts").attr("role", X.GROUP).attr("data-name", "callouts"), n = t.selectAll("g.callout").data(e);
    n.exit().remove();
    const s = n.enter().append("g").classed("callout", !0).attr("role", X.GROUP).attr("aria-roledescription", "label callout");
    s.merge(n).datum(function(r) {
      const { xPosition: l, yPosition: c, direction: d } = r;
      return d === ln.RIGHT ? (r.startPos = {
        x: l,
        y: c + r.textOffsetY
      }, r.endPos = {
        x: l + te.callout.offsetX,
        y: c - te.callout.offsetY + r.textOffsetY
      }, r.intersectPointX = r.endPos.x - te.callout.horizontalLineLength) : (r.startPos = {
        x: l,
        y: c + r.textOffsetY
      }, r.endPos = {
        x: l - te.callout.offsetX,
        y: c - te.callout.offsetY + r.textOffsetY
      }, r.intersectPointX = r.endPos.x + te.callout.horizontalLineLength), r;
    }), s.append("line").classed("vertical-line", !0).merge(t.selectAll("line.vertical-line")).datum(function() {
      return T(this.parentNode).datum();
    }).style("stroke-width", "1px").attr("x1", (r) => r.startPos.x).attr("y1", (r) => r.startPos.y).attr("x2", (r) => r.intersectPointX).attr("y2", (r) => r.endPos.y), s.append("line").classed("horizontal-line", !0).merge(t.selectAll("line.horizontal-line")).datum(function() {
      return T(this.parentNode).datum();
    }).style("stroke-width", "1px").attr("x1", (r) => r.intersectPointX).attr("y1", (r) => r.endPos.y).attr("x2", (r) => r.endPos.x).attr("y2", (r) => r.endPos.y);
  }
  addEventListeners() {
    const e = this;
    this.parent.selectAll("path.slice").on("mouseover", function(t, n) {
      const s = T(this);
      e.isRendering || s.classed("hovered", !0).transition("pie_slice_mouseover").call(
        (r) => e.services.transitions.setupTransition({
          transition: r,
          name: "pie_slice_mouseover"
        })
      ).attr("d", e.hoverArc), e.services.events.dispatchEvent(f.Pie.SLICE_MOUSEOVER, {
        event: t,
        element: T(this),
        datum: n
      });
      const { groupMapsTo: a } = e.getOptions().data, { valueMapsTo: i } = e.getOptions().pie;
      e.services.events.dispatchEvent(f.Tooltip.SHOW, {
        event: t,
        hoveredElement: s,
        items: [
          {
            label: n.data[a],
            value: n.data[i]
          }
        ]
      });
    }).on("mousemove", function(t, n) {
      const s = T(this);
      e.services.events.dispatchEvent(f.Pie.SLICE_MOUSEMOVE, {
        event: t,
        element: s,
        datum: n
      }), e.services.events.dispatchEvent(f.Tooltip.MOVE, {
        event: t
      });
    }).on("click", function(t, n) {
      e.services.events.dispatchEvent(f.Pie.SLICE_CLICK, {
        event: t,
        element: T(this),
        datum: n
      });
    }).on("mouseout", function(t, n) {
      const s = T(this);
      Cr(() => {
        e.isRendering || s.classed("hovered", !1).transition("pie_slice_mouseout").call(
          (a) => e.services.transitions.setupTransition({
            transition: a,
            name: "pie_slice_mouseout"
          })
        ).attr("d", e.arc);
      }, 100), e.services.events.dispatchEvent(f.Pie.SLICE_MOUSEOUT, {
        event: t,
        element: s,
        datum: n
      }), e.services.events.dispatchEvent(f.Tooltip.HIDE, {
        hoveredElement: s
      });
    });
  }
  // Helper functions
  computeRadius() {
    const { width: e, height: t } = S.getSVGElementSize(this.parent, {
      useAttrs: !0
    }), n = this.getOptions(), s = Math.min(e, t) / 2;
    return n.pie.labels.enabled ? s + te.radiusOffset : s;
  }
}
class jh extends Rl {
  constructor() {
    super(...arguments), this.type = "donut", this.renderType = j.SVG;
  }
  render(e = !0) {
    super.render(e);
    const t = this;
    if (this.model.isDataEmpty()) {
      this.getComponentContainer().select("g.center").remove();
      return;
    }
    const n = S.appendOrSelect(this.getComponentContainer(), "g.center"), s = this.getOptions(), a = this.computeRadius(), i = v(s, "donut", "center", "label");
    S.appendOrSelect(n, "text.donut-figure").attr("text-anchor", "middle").style("dominant-baseline", () => i === null || i === "" ? "central" : "initial").style("font-size", () => s.donut.center.numberFontSize(a)).transition().call(
      (r) => this.services.transitions.setupTransition({
        transition: r,
        name: "donut-figure-enter-update",
        animate: e
      })
    ).tween("text", function() {
      return t.centerNumberTween(T(this));
    }), i !== null && i !== "" && S.appendOrSelect(n, "text.donut-title").attr("text-anchor", "middle").style("font-size", () => s.donut.center.titleFontSize(a)).attr("y", s.donut.center.titleYPosition(a)).text(i);
  }
  getInnerRadius() {
    return this.computeRadius() * (3 / 4);
  }
  centerNumberTween(e) {
    const t = this.getOptions();
    let n = v(t, "donut", "center", "number");
    n === null && (n = this.model.getDisplayData().reduce((r, l) => r + l[t.pie.valueMapsTo], 0));
    const s = parseInt(e.text().replace(/[, ]+/g, ""), 10) || 0;
    let a;
    s % 1 === 0 && n % 1 === 0 ? a = di : a = aa;
    const i = a(s, n);
    return (r) => {
      const { numberFormatter: l } = t.donut.center;
      if (l)
        e.text(l(i(r)));
      else {
        const { code: c, number: d } = v(t, "locale");
        e.text(d(Math.floor(i(r)), c));
      }
    };
  }
}
const Zs = "4,10 8,6 12,10", Ys = "12,6 8,10 4,6";
class Xh extends Y {
  constructor() {
    super(...arguments), this.type = "gauge", this.renderType = j.SVG;
  }
  getValue() {
    var n;
    return ((n = this.model.getData().find((s) => s.group === "value")) == null ? void 0 : n.value) ?? null;
  }
  getValueRatio() {
    return Sa(this.getValue(), 0, 100) / 100;
  }
  getDelta() {
    var n;
    return ((n = this.model.getData().find((s) => s.group === "delta")) == null ? void 0 : n.value) ?? null;
  }
  getArcRatio() {
    const e = this.getOptions();
    return v(e, "gauge", "type") === Rt.FULL ? 1 : 0.5;
  }
  getArcSize() {
    return this.getArcRatio() * Math.PI * 2;
  }
  getStartAngle() {
    const e = this.getArcSize();
    return e === 2 * Math.PI ? 0 : -e / 2;
  }
  // use provided arrow direction or default to using the delta
  getArrow(e) {
    const t = this.getOptions();
    switch (v(t, "gauge", "deltaArrow", "direction")) {
      case bs.UP:
        return Zs;
      case bs.DOWN:
        return Ys;
      default:
        return e > 0 ? Zs : Ys;
    }
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e = !0) {
    const t = this.getComponentContainer().attr("width", "100%").attr("height", "100%"), n = this.getOptions(), s = this.getValue(), a = this.getValueRatio(), i = this.getArcSize(), r = this.getStartAngle(), l = a * i, c = r + l, d = r + i, p = this.computeRadius(), h = this.getInnerRadius();
    this.backgroundArc = Lt().innerRadius(h).outerRadius(p).startAngle(c).endAngle(d), this.arc = Lt().innerRadius(h).outerRadius(p).startAngle(r).endAngle(c), S.appendOrSelect(t, "path.arc-background").attr("d", this.backgroundArc);
    const u = t.selectAll("path.arc-foreground").data([s]);
    u.enter().append("path").merge(u).attr(
      "class",
      this.model.getColorClassName({
        classNameTypes: [z.FILL],
        dataGroupName: "value",
        originalClassName: "arc-foreground"
      })
    ).style("fill", () => v(this.getOptions(), "color", "scale", "value")).attr("d", this.arc).attr("role", X.GRAPHICS_SYMBOL).attr("aria-roledescription", "value").attr("aria-label", (x) => x), this.drawValueNumber(), this.drawDelta(), u.exit().remove();
    const m = v(n, "gauge", "alignment"), { width: E } = S.getSVGElementSize(this.getParent(), {
      useAttrs: !0
    });
    let O = p;
    m === Ce.CENTER ? O = E / 2 : m === Ce.RIGHT && (O = E - p), t.attr("x", O).attr("y", p), this.addEventListeners();
  }
  /**
   * draws the value number associated with the Gauge component in the center
   */
  drawValueNumber() {
    const e = this.getComponentContainer(), t = this.getOptions(), n = v(t, "gauge", "type"), s = this.getValue(), a = this.getDelta(), i = this.computeRadius(), r = v(t, "gauge", "valueFontSize"), l = v(t, "gauge", "deltaFontSize"), c = v(t, "gauge", "numberSpacing"), d = v(t, "gauge", "showPercentageSymbol");
    let p = 0;
    n === Rt.FULL && !a ? p = l(i) : n === Rt.SEMI && a && (p = -(l(i) + c));
    const h = S.appendOrSelect(e, "g.gauge-numbers").attr(
      "transform",
      `translate(0, ${p})`
    ), u = r(i), g = S.appendOrSelect(h, "g.gauge-value-number"), { code: m, number: E } = v(t, "locale"), O = v(t, "gauge", "numberFormatter"), x = g.selectAll("text.gauge-value-number").data([s]);
    x.enter().append("text").attr("class", "gauge-value-number").merge(x).style("font-size", `${u}px`).attr("text-anchor", "middle").text((W) => {
      let k;
      return W != null ? k = Number(W.toFixed(2)) % 1 !== 0 ? W.toFixed(2) : W.toFixed() : k = 0, O ? O(k) : E(Number(k), m);
    });
    const { width: y } = S.getSVGElementSize(
      S.appendOrSelect(e, "text.gauge-value-number"),
      { useBBox: !0 }
    ), w = u / 2, A = d ? "%" : "", L = S.appendOrSelect(g, "text.gauge-value-symbol").style("font-size", `${w}px`).attr("x", y / 2).text(A), { width: I, height: P } = S.getSVGElementSize(L, {
      useBBox: !0
    });
    L.attr("y", `-${P / 2}px`), g.attr("transform", `translate(-${I / 2}, 0)`);
  }
  /**
   * adds the delta number for the gauge
   */
  drawDelta() {
    const e = this, t = this.getComponentContainer(), n = this.getOptions(), s = this.getDelta(), { code: a, number: i } = v(n, "locale");
    if (s) {
      const r = this.computeRadius(), l = s ? v(n, "gauge", "deltaFontSize") : () => 0, c = s ? v(n, "gauge", "numberFormatter") : () => null, d = v(n, "gauge", "deltaArrow", "size"), p = v(n, "gauge", "numberSpacing"), h = v(n, "gauge", "showPercentageSymbol"), u = S.appendOrSelect(t, "g.gauge-numbers"), g = S.appendOrSelect(u, "g.gauge-delta").attr(
        "transform",
        `translate(0, ${l(r) + p})`
      ), m = S.appendOrSelect(g, "text.gauge-delta-number"), E = h ? "%" : "";
      m.data(s === null ? [] : [s]), m.enter().append("text").classed("gauge-delta-number", !0).merge(m).attr("text-anchor", "middle").style("font-size", `${l(r)}px`).text((w) => {
        let A;
        return w != null ? A = Number(w.toFixed(2)) % 1 !== 0 ? w.toFixed(2) : w.toFixed() : A = 0, c ? `${c(A)}${E}` : `${i(Number(A), a)}${E}`;
      });
      const { width: O } = S.getSVGElementSize(
        S.appendOrSelect(t, ".gauge-delta-number"),
        { useBBox: !0 }
      ), x = v(n, "gauge", "deltaArrow", "enabled"), y = g.selectAll("svg.gauge-delta-arrow").data(s !== null && x ? [s] : []);
      y.enter().append("svg").merge(y).attr("class", "gauge-delta-arrow").attr("x", -d(r) - O / 2).attr("y", -d(r) / 2 - l(r) * 0.35).attr("width", d(r)).attr("height", d(r)).attr("viewBox", "0 0 16 16").each(function() {
        const w = T(this);
        S.appendOrSelect(w, "rect.gauge-delta-arrow-backdrop").attr("width", "16").attr("height", "16").attr("fill", "none");
        const A = v(n, "gauge", "status");
        S.appendOrSelect(w, "polygon.gauge-delta-arrow").attr("class", A !== null ? `gauge-delta-arrow status--${A}` : "").attr("points", e.getArrow(s));
      }), y.exit().remove(), m.exit().remove();
    } else {
      const r = t.select("g.gauge-delta");
      r.empty() || r.remove();
    }
  }
  getInnerRadius() {
    const e = this.computeRadius(), t = v(this.getOptions(), "gauge", "arcWidth");
    return e - t;
  }
  addEventListeners() {
    const e = this;
    this.parent.selectAll("path.arc-foreground").on("mouseover", function(t, n) {
      e.services.events.dispatchEvent(f.Gauge.ARC_MOUSEOVER, {
        event: t,
        element: T(this),
        datum: n
      });
    }).on("mousemove", function(t, n) {
      const s = T(this);
      e.services.events.dispatchEvent(f.Gauge.ARC_MOUSEMOVE, {
        event: t,
        element: s,
        datum: n
      });
    }).on("click", function(t, n) {
      e.services.events.dispatchEvent(f.Gauge.ARC_CLICK, {
        event: t,
        element: T(this),
        datum: n
      });
    }).on("mouseout", function(t, n) {
      const s = T(this);
      e.services.events.dispatchEvent(f.Gauge.ARC_MOUSEOUT, {
        event: t,
        element: s,
        datum: n
      });
    });
  }
  // Helper functions
  computeRadius() {
    const e = this.getOptions(), t = v(e, "gauge", "type"), { width: n, height: s } = S.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    return t === Rt.SEMI ? Math.min(n / 2, s) : Math.min(n / 2, s / 2);
  }
}
class Zh extends Xn {
  constructor() {
    super(...arguments), this.type = "grouped-bar", this.renderType = j.SVG, this.padding = 5, this.defaultStepFactor = 70, this.handleLegendOnHover = (e) => {
      const { hoveredElement: t } = e.detail, { groupMapsTo: n } = this.getOptions().data;
      this.parent.selectAll("path.bar").transition("legend-hover-bar").call(
        (s) => this.services.transitions.setupTransition({
          transition: s,
          name: "legend-hover-bar"
        })
      ).attr("opacity", (s) => s[n] !== t.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.bar").transition("legend-mouseout-bar").call(
        (e) => this.services.transitions.setupTransition({
          transition: e,
          name: "legend-mouseout-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const e = this.services.events;
    e.addEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.addEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(e) {
    const t = this.model.getDisplayData(this.configs.groups), n = this.getOptions(), { groupMapsTo: s } = n.data;
    this.setGroupScale();
    const a = this.getComponentContainer({ withinChartClip: !0 }), i = ti(
      t.map((h) => {
        const u = this.services.cartesianScales.getDomainIdentifier(h);
        return h[u] && typeof h[u].toString == "function" ? h[u].toString() : h[u];
      })
    ), r = a.selectAll("g.bars").data(i, (h) => h);
    r.exit().attr("opacity", 0).remove();
    const c = r.enter().append("g").classed("bars", !0).attr("role", X.GROUP).attr("data-name", "bars").merge(r);
    c.transition().call(
      (h) => this.services.transitions.setupTransition({
        transition: h,
        name: "bar-group-update-enter",
        animate: e
      })
    ).attr("transform", (h) => {
      const g = this.services.cartesianScales.getDomainValue(h) - this.getGroupWidth() / 2;
      return this.services.cartesianScales.getOrientation() === xe.VERTICAL ? `translate(${g}, 0)` : `translate(0, ${g})`;
    });
    const d = c.selectAll("path.bar").data(
      (h) => this.getDataCorrespondingToLabel(h),
      (h) => h[s]
    );
    d.exit().attr("opacity", 0).remove(), d.enter().append("path").attr("opacity", 0).merge(d).classed("bar", !0).transition().call(
      (h) => this.services.transitions.setupTransition({
        transition: h,
        name: "bar-update-enter",
        animate: e
      })
    ).attr(
      "class",
      (h) => this.model.getColorClassName({
        classNameTypes: [z.FILL],
        dataGroupName: h[s],
        originalClassName: "bar"
      })
    ).style("fill", (h) => {
      const u = this.services.cartesianScales.getDomainIdentifier(h);
      return this.model.getFillColor(h[s], h[u], h);
    }).attr("d", (h) => {
      const u = this.groupScale(h[s]), g = this.getBarWidth(), m = u, E = u + g, O = this.services.cartesianScales.getRangeAxisPosition({ datum: h }), x = this.services.cartesianScales.getDomainLowerBound(O), y = this.services.cartesianScales.getValueThroughAxisPosition(O, x), w = this.services.cartesianScales.getRangeValue(h), A = this.services.cartesianScales.getDomainValue(h) - g / 2, L = A + g;
      if (!this.isOutsideZoomedDomain(A, L))
        return Ee(
          { x0: m, x1: E, y0: y, y1: w },
          this.services.cartesianScales.getOrientation()
        );
    }).attr("opacity", 1).attr("role", X.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (h) => h.value), this.addEventListeners();
  }
  addEventListeners() {
    const e = this;
    this.parent.selectAll("path.bar").on("mouseover", function(t, n) {
      const s = T(this);
      s.classed("hovered", !0), e.services.events.dispatchEvent(f.Bar.BAR_MOUSEOVER, {
        event: t,
        element: s,
        datum: n
      }), e.services.events.dispatchEvent(f.Tooltip.SHOW, {
        event: t,
        hoveredElement: s,
        data: [n]
      });
    }).on("mousemove", function(t, n) {
      const s = T(this);
      e.services.events.dispatchEvent(f.Bar.BAR_MOUSEMOVE, {
        event: t,
        element: s,
        datum: n
      }), e.services.events.dispatchEvent(f.Tooltip.MOVE, {
        event: t
      });
    }).on("click", function(t, n) {
      e.services.events.dispatchEvent(f.Bar.BAR_CLICK, {
        event: t,
        element: T(this),
        datum: n
      });
    }).on("mouseout", function(t, n) {
      const s = T(this);
      s.classed("hovered", !1), e.services.events.dispatchEvent(f.Bar.BAR_MOUSEOUT, {
        event: t,
        element: s,
        datum: n
      }), e.services.events.dispatchEvent(f.Tooltip.HIDE, {
        hoveredElement: s
      });
    });
  }
  destroy() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const e = this.services.events;
    e.removeEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.removeEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  getDataCorrespondingToLabel(e) {
    return this.model.getDisplayData(this.configs.groups).filter((n) => {
      const s = this.services.cartesianScales.getDomainIdentifier(n);
      return n[s].toString() === e;
    });
  }
  getGroupWidth() {
    const e = this.model.getGroupedData(this.configs.groups), t = this.getTotalGroupPadding();
    return this.getBarWidth() * e.length + t;
  }
  getDomainScaleStep() {
    const e = this.services.cartesianScales.getDomainScale(), t = this.model.getGroupedData(this.configs.groups);
    let n = this.defaultStepFactor;
    if (typeof e.step == "function")
      n = e.step();
    else if (t.length > 0) {
      const s = t.find((a) => {
        var i;
        return ((i = a.data) == null ? void 0 : i.length) > 1;
      });
      if (s) {
        const a = this.services.cartesianScales.getDomainIdentifier(s.data[0]);
        n = Math.abs(
          e(s.data[1][a]) - e(s.data[0][a])
        );
      }
    }
    return n;
  }
  getTotalGroupPadding() {
    const e = this.model.getGroupedData(this.configs.groups);
    return e.length === 1 ? 0 : Math.min(5, 5 * (this.getDomainScaleStep() / this.defaultStepFactor)) * (e.length - 1);
  }
  // Gets the correct width for bars based on options & configurations
  getBarWidth() {
    const e = this.getOptions(), t = v(e, "bars", "width"), n = v(e, "bars", "maxWidth");
    if (t !== null && (n === null || t <= n))
      return t;
    const a = this.model.getGroupedData(this.configs.groups).length, i = this.getTotalGroupPadding();
    return Math.min(
      n,
      (this.getDomainScaleStep() - i) / a
    );
  }
  setGroupScale() {
    const e = this.model.getActiveDataGroupNames(this.configs.groups);
    this.groupScale = Un().domain(e).rangeRound([0, this.getGroupWidth()]);
  }
}
class Yh extends Y {
  constructor() {
    super(...arguments), this.type = "heatmap", this.renderType = j.SVG, this.matrix = {}, this.xBandwidth = 0, this.yBandwidth = 0, this.translationUnits = {
      x: 0,
      y: 0
    }, this.handleAxisOnHover = (e) => {
      const { detail: t } = e, { datum: n } = t, s = this.model.getUniqueRanges(), a = this.model.getUniqueDomain(), i = this.services.cartesianScales.getDomainLabel(), r = this.services.cartesianScales.getRangeLabel(), l = this.services.cartesianScales.getMainXScale(), c = this.services.cartesianScales.getMainYScale();
      let d = "", p = null, h = null, u = null;
      this.matrix[n] !== void 0 ? (d = i, s.forEach((g) => {
        if (typeof this.matrix[n][g].value == "number") {
          const m = this.matrix[n][g].value;
          if (p === null) {
            p = m, h = m, u = m;
            return;
          }
          p += m, h = m < h ? m : h, u = m > u ? m : u;
        }
      })) : (d = r, a.forEach((g) => {
        if (typeof this.matrix[g][n].value == "number") {
          const m = this.matrix[g][n].value;
          if (p === null) {
            p = m, h = m, u = m;
            return;
          }
          p += m, h = m < h ? m : h, u = m > u ? m : u;
        }
      })), l(n) !== void 0 ? this.parent.select("g.multi-cell.column-highlight").classed("highlighter-hidden", !1).attr("transform", `translate(${l(n)}, ${En(c.range())})`) : c(n) !== void 0 && this.parent.select("g.multi-cell.row-highlight").classed("highlighter-hidden", !1).attr("transform", `translate(${En(l.range())},${c(n)})`), this.services.events.dispatchEvent(f.Tooltip.SHOW, {
        event: t.event,
        hoveredElement: T(e.detail.element),
        items: [
          {
            label: d,
            value: n,
            bold: !0
          },
          {
            label: "Min",
            value: h !== null ? h : "-"
          },
          {
            label: "Max",
            value: u !== null ? u : "-"
          },
          {
            label: "Average",
            value: p !== null ? p / a.length : "-"
          }
        ]
      });
    }, this.handleAxisMouseOut = (e) => {
      this.parent.selectAll("g.multi-cell").classed("highlighter-hidden", !0), this.services.events.dispatchEvent(f.Tooltip.HIDE, {
        event: e
      });
    };
  }
  init() {
    const e = this.services.events;
    e.addEventListener(f.Axis.LABEL_MOUSEOVER, this.handleAxisOnHover), e.addEventListener(f.Axis.LABEL_MOUSEOUT, this.handleAxisMouseOut), e.addEventListener(f.Axis.LABEL_FOCUS, this.handleAxisOnHover), e.addEventListener(f.Axis.LABEL_BLUR, this.handleAxisMouseOut);
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e = !0) {
    const t = this.getComponentContainer({ withinChartClip: !0 });
    t.lower();
    const { cartesianScales: n } = this.services;
    if (this.matrix = this.model.getMatrix(), t.html(""), v(this.getOptions(), "data", "loading"))
      return;
    const s = n.getMainXScale(), a = n.getMainYScale(), i = n.getDomainIdentifier(), r = n.getRangeIdentifier(), l = this.model.getUniqueDomain(), c = this.model.getUniqueRanges(), d = this.model.getMatrixAsArray(), p = s.range(), h = a.range();
    this.xBandwidth = Math.abs((p[1] - p[0]) / l.length), this.yBandwidth = Math.abs((h[1] - h[0]) / c.length);
    const u = this.services.domUtils.generateElementIDString("heatmap-pattern-stripes");
    t.append("defs").append("pattern").attr("id", u).attr("width", 3).attr("height", 3).attr("patternUnits", "userSpaceOnUse").attr("patternTransform", "rotate(45)").append("rect").classed("pattern-fill", !0).attr("width", 0.5).attr("height", 8);
    const g = t.selectAll().data(d).enter().append("g").attr("class", (m) => `heat-${m.index}`).classed("cell", !0).attr(
      "transform",
      (m) => `translate(${s(m[i])}, ${a(m[r])})`
    ).append("rect").attr(
      "class",
      (m) => this.model.getColorClassName({
        value: m.value,
        originalClassName: `heat-${m.index}`
      })
    ).classed("heat", !0).classed("null-state", (m) => m.index === -1 || m.value === null).attr("width", this.xBandwidth).attr("height", this.yBandwidth).style("fill", (m) => {
      const E = this.services.cartesianScales.getDomainIdentifier(m);
      return m.index === -1 || m.value === null ? `url(#${u})` : this.model.getFillColor(Number(m.value), m[E], m);
    }).attr("aria-label", (m) => m.value);
    this.createOuterBox("g.cell-highlight", this.xBandwidth, this.yBandwidth), this.createOuterBox(
      "g.multi-cell.column-highlight",
      this.xBandwidth,
      Math.abs(h[1] - h[0])
    ), this.createOuterBox(
      "g.multi-cell.row-highlight",
      Math.abs(p[1] - p[0]),
      this.yBandwidth
    ), this.determineDividerStatus() && (g.style("stroke-width", "1px"), this.parent.select("g.cell-highlight").classed("cell-2", !0)), this.addEventListener();
  }
  /**
   * Generates a box using lines to create a hover effect
   * The lines have drop shadow in their respective direction
   * @param parentTag - tag name
   * @param xBandwidth - X length
   * @param yBandwidth - y length
   */
  createOuterBox(e, t, n) {
    const s = S.appendOrSelect(this.parent, e).classed("shadows", !0).classed("highlighter-hidden", !0);
    S.appendOrSelect(s, "line.top").attr("x1", -1).attr("x2", t + 1), S.appendOrSelect(s, "line.left").attr("x1", 0).attr("y1", -1).attr("x2", 0).attr("y2", n + 1), S.appendOrSelect(s, "line.down").attr("x1", -1).attr("x2", t + 1).attr("y1", n).attr("y2", n), S.appendOrSelect(s, "line.right").attr("x1", t).attr("x2", t).attr("y1", -1).attr("y2", n + 1);
  }
  determineDividerStatus() {
    const e = v(this.getOptions(), "heatmap", "divider", "state");
    return e !== cn.OFF && (e === cn.AUTO && ms.minCellDividerDimension <= this.xBandwidth && ms.minCellDividerDimension <= this.yBandwidth || e === cn.ON);
  }
  addEventListener() {
    const e = this, { cartesianScales: t } = this.services, n = this.getOptions(), s = ne(n, "locale.translations.total") || ne(n, "tooltip.totalLabel") || "Total", a = t.getDomainIdentifier(), i = t.getRangeIdentifier(), r = t.getDomainLabel(), l = t.getRangeLabel();
    this.parent.selectAll("g.cell").on("mouseover", function(c, d) {
      const p = T(this), h = p.select("rect.heat");
      if (!h.classed("null-state")) {
        const g = Ot(p.attr("transform"));
        e.parent.select("g.cell-highlight").attr(
          "transform",
          `translate(${g.x + e.translationUnits.x}, ${g.y + e.translationUnits.y})`
        ).classed("highlighter-hidden", !1), e.services.events.dispatchEvent(f.Heatmap.HEATMAP_MOUSEOVER, {
          event: c,
          element: h,
          datum: d
        }), e.services.events.dispatchEvent(f.Tooltip.SHOW, {
          event: c,
          items: [
            {
              label: r,
              value: d[a]
            },
            {
              label: l,
              value: d[i]
            },
            {
              label: s,
              value: d.value,
              color: h.style("fill")
            }
          ]
        });
      }
    }).on("mousemove", function(c, d) {
      e.services.events.dispatchEvent(f.Heatmap.HEATMAP_MOUSEMOVE, {
        event: c,
        element: T(this),
        datum: d
      }), e.services.events.dispatchEvent(f.Tooltip.MOVE, {
        event: c
      });
    }).on("click", function(c, d) {
      e.services.events.dispatchEvent(f.Heatmap.HEATMAP_CLICK, {
        event: c,
        element: T(this),
        datum: d
      });
    }).on("mouseout", function(c, d) {
      const h = T(this).select("rect.heat"), u = h.classed("null-state");
      e.parent.select("g.cell-highlight").classed("highlighter-hidden", !0), u || (e.services.events.dispatchEvent(f.Heatmap.HEATMAP_MOUSEOUT, {
        event: c,
        element: h,
        datum: d
      }), e.services.events.dispatchEvent(f.Tooltip.HIDE, {
        event: c,
        hoveredElement: h
      }));
    });
  }
  // Remove event listeners
  destroy() {
    this.parent.selectAll("rect.heat").on("mouseover", null).on("mousemove", null).on("click", null).on("mouseout", null);
    const e = this.services.events;
    e.removeEventListener(f.Legend.ITEM_HOVER, this.handleAxisOnHover), e.removeEventListener(f.Legend.ITEM_MOUSEOUT, this.handleAxisMouseOut);
  }
}
class qh extends Y {
  constructor() {
    super(...arguments), this.type = "histogram", this.renderType = j.SVG, this.handleLegendOnHover = (e) => {
      const { hoveredElement: t } = e.detail, n = this.getOptions(), { groupMapsTo: s } = n.data;
      this.parent.selectAll("path.bar").transition("legend-hover-bar").call(
        (a) => this.services.transitions.setupTransition({
          transition: a,
          name: "legend-hover-bar"
        })
      ).attr("opacity", (a) => a[s] !== t.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.bar").transition("legend-mouseout-bar").call(
        (e) => this.services.transitions.setupTransition({
          transition: e,
          name: "legend-mouseout-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const e = this.services.events;
    e.addEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.addEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(e) {
    const t = this.getComponentContainer(), n = this.model.getOptions(), { groupIdentifier: s } = n, { groupMapsTo: a } = n.data, i = this.model.getBinnedStackedData(), r = this.services.cartesianScales.getMainXScale(), l = t.selectAll("g.bars").data(i, (d) => ne(d, `0.${a}`));
    l.exit().attr("opacity", 0).remove(), l.enter().append("g").classed("bars", !0).attr("role", X.GROUP);
    const c = t.selectAll("g.bars").selectAll("path.bar").data((d) => d);
    c.exit().remove(), c.enter().append("path").merge(c).classed("bar", !0).attr(s, (d, p) => p).transition().call(
      (d) => this.services.transitions.setupTransition({
        transition: d,
        name: "histogram-bar-update-enter",
        animate: e
      })
    ).attr(
      "class",
      (d) => this.model.getColorClassName({
        classNameTypes: [z.FILL],
        dataGroupName: d[a],
        originalClassName: "bar"
      })
    ).style("fill", (d) => this.model.getFillColor(d[a], null, d)).attr("d", (d) => {
      const p = ne(d, "data");
      if (!p)
        return;
      const h = r(p.x1) - r(p.x0) - 1, u = this.services.cartesianScales.getDomainValue(p.x0), g = u + h, m = this.services.cartesianScales.getRangeValue(d[0]);
      let E = this.services.cartesianScales.getRangeValue(d[1]);
      return Math.abs(E - m) > 0 && Math.abs(E - m) > n.bars.dividerSize && (this.services.cartesianScales.getOrientation() === xe.VERTICAL ? E += 1 : E -= 1), Ee(
        { x0: u, x1: g, y0: m, y1: E },
        this.services.cartesianScales.getOrientation()
      );
    }).attr("opacity", 1).attr("role", X.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (d) => v(d, "data", d[a])), this.addEventListeners();
  }
  addEventListeners() {
    const e = this.model.getOptions(), { groupMapsTo: t } = e.data, { code: n, number: s } = v(e, "locale"), a = this;
    this.parent.selectAll("path.bar").on("mouseover", function(i, r) {
      const l = T(this);
      l.classed("hovered", !0);
      const c = s(parseFloat(ne(r, "data.x0")), n), d = s(parseFloat(ne(r, "data.x1")), n), p = a.services.cartesianScales.getRangeAxisPosition(), h = a.services.cartesianScales.getScaleLabel(p);
      a.services.events.dispatchEvent(f.Tooltip.SHOW, {
        event: i,
        hoveredElement: l,
        items: [
          {
            label: ne(e, "bins.rangeLabel") || "Range",
            value: `${c} – ${d}`
          },
          {
            label: e.tooltip.groupLabel || "Group",
            value: r[t],
            class: a.model.getColorClassName({
              classNameTypes: [z.TOOLTIP],
              dataGroupName: r[t]
            })
          },
          {
            label: h,
            value: ne(r, `data.${r[t]}`)
          }
        ]
      });
    }).on("mousemove", function(i) {
      a.services.events.dispatchEvent(f.Tooltip.MOVE, {
        event: i
      });
    }).on("mouseout", function() {
      T(this).classed("hovered", !1), a.services.events.dispatchEvent(f.Tooltip.HIDE);
    });
  }
  destroy() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const e = this.services.events;
    e.removeEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.removeEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
class Kh extends Wn {
  constructor() {
    super(...arguments), this.type = "lollipop", this.renderType = j.SVG, this.handleScatterOnHover = (e) => {
      const t = e.detail, n = this.getOptions(), { groupMapsTo: s } = n.data;
      this.parent.selectAll("line.line").attr("stroke-width", (a) => a[s] !== t.datum[s] ? He.weight.unselected : He.weight.selected);
    }, this.handleScatterOnMouseOut = () => {
      this.parent.selectAll("line.line").attr("stroke-width", He.weight.unselected);
    }, this.handleLegendOnHover = (e) => {
      const { hoveredElement: t } = e.detail, n = this.getOptions(), { groupMapsTo: s } = n.data;
      this.parent.selectAll("line.line").transition("legend-hover-line").call(
        (a) => this.services.transitions.setupTransition({
          transition: a,
          name: "legend-hover-line"
        })
      ).attr("opacity", (a) => a[s] !== t.datum().name ? He.opacity.unselected : He.opacity.selected);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("line.line").transition("legend-mouseout-line").call(
        (e) => this.services.transitions.setupTransition({
          transition: e,
          name: "legend-mouseout-line"
        })
      ).attr("opacity", He.opacity.selected);
    };
  }
  init() {
    const { events: e } = this.services;
    e.addEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.addEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(e) {
    const t = this.getComponentContainer({ withinChartClip: !0 }), n = this.model.getOptions(), { groupMapsTo: s } = n.data, { cartesianScales: a } = this.services, i = a.getMainXScale(), r = a.getMainYScale(), l = a.getDomainIdentifier(), c = (O) => a.getDomainValue(O), d = (O) => a.getRangeValue(O), p = a.getOrientation(), [h, u] = Ue(
      c,
      d,
      p
    ), g = t.selectAll("line.line").data(
      this.getScatterData(),
      (O) => `${O[s]}-${O[l]}`
    );
    g.exit().attr("opacity", 0).remove();
    const E = g.enter().append("line").attr("opacity", 0).merge(g).classed("line", !0).attr(
      "class",
      (O) => this.model.getColorClassName({
        classNameTypes: [z.STROKE],
        dataGroupName: O[s],
        originalClassName: "line"
      })
    ).transition().call(
      (O) => this.services.transitions.setupTransition({
        transition: O,
        name: "lollipop-line-update-enter",
        animate: e
      })
    ).style("stroke", (O) => this.model.getFillColor(O[s], O[l], O)).attr("opacity", 1);
    p === xe.HORIZONTAL ? E.attr("y1", u).attr("y2", u).attr("x1", i.range()[0]).attr("x2", (O) => h(O) - n.points.radius) : E.attr("x1", h).attr("x2", h).attr("y1", r.range()[0]).attr("y2", (O) => u(O) + n.points.radius), this.addScatterPointEventListeners();
  }
  // listen for when individual datapoints are hovered
  addScatterPointEventListeners() {
    this.services.events.addEventListener(
      f.Scatter.SCATTER_MOUSEOVER,
      this.handleScatterOnHover
    ), this.services.events.addEventListener(
      f.Scatter.SCATTER_MOUSEOUT,
      this.handleScatterOnMouseOut
    );
  }
  destroy() {
    const e = this.services.events;
    e.removeEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.removeEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut), e.removeEventListener(f.Scatter.SCATTER_MOUSEOVER, this.handleScatterOnHover), e.removeEventListener(
      f.Scatter.SCATTER_MOUSEOUT,
      this.handleScatterOnMouseOut
    );
  }
}
class Jh extends Y {
  constructor() {
    super(...arguments), this.type = "meter", this.renderType = j.SVG;
  }
  getStackedBounds(e, t) {
    let n = 0;
    return e.map((a, i) => i !== 0 ? (n += t(a.value), {
      ...a,
      width: Math.abs(t(a.value) - ge.dividerWidth),
      x: n - t(a.value)
    }) : (n = t(a.value), {
      ...a,
      width: Math.abs(t(a.value) - ge.dividerWidth),
      x: 0
    }));
  }
  render(e = !0) {
    const t = this, n = this.getComponentContainer(), s = this.getOptions(), a = v(s, "meter", "proportional"), i = this.model.getDisplayData(), r = this.model.getStatus(), { width: l } = S.getSVGElementSize(n, {
      useAttrs: !0
    }), { groupMapsTo: c } = s.data;
    let d;
    if (v(s, "meter", "proportional") === null)
      d = 100;
    else {
      const y = v(s, "meter", "proportional", "total");
      d = y || this.model.getMaximumDomain(this.model.getDisplayData());
    }
    const p = qe().domain([0, d]).range([0, l]), h = this.getStackedBounds(i, p), u = v(s, "meter", "height");
    S.appendOrSelect(n, "rect.container").attr("x", 0).attr("y", 0).attr("width", l).attr(
      "height",
      u || (a ? ge.height.proportional : ge.height.default)
    ), S.appendOrSelect(n, "line.rangeIndicator").attr("x1", l).attr("x2", l).attr("y1", 0).attr(
      "y2",
      u || (a ? ge.height.proportional : ge.height.default)
    );
    const g = n.selectAll("rect.value").data(h), m = r != null && !t.model.isUserProvidedColorScaleValid() && !a ? `value status--${r}` : "value";
    g.enter().append("rect").classed("value", !0).merge(g).attr("x", (y) => y.x).attr("y", 0).attr("height", () => u || (a ? ge.height.proportional : ge.height.default)).attr(
      "class",
      (y) => this.model.getColorClassName({
        classNameTypes: [z.FILL],
        dataGroupName: y[c],
        originalClassName: m
      })
    ).transition().call(
      (y) => this.services.transitions.setupTransition({
        transition: y,
        name: "meter-bar-update",
        animate: e
      })
    ).attr("width", (y) => y.value > d ? p(d) : Math.max(y.width, 2)).style("fill", (y) => t.model.getFillColor(y[c], null, y)).attr("role", X.GRAPHICS_SYMBOL).attr("aria-roledescription", "value").attr("aria-label", (y) => y.value), g.exit().remove();
    const E = v(s, "meter", "peak");
    let O = E;
    E !== null && (E > d ? O = d : E < i[0].value && (O = i[0].value > d ? d : i[0].value));
    const x = n.selectAll("line.peak").data(O == null ? [] : [O]);
    x.enter().append("line").classed("peak", !0).merge(x).attr("y1", 0).attr("y2", () => u || (a ? ge.height.proportional : ge.height.default)).transition().call(
      (y) => this.services.transitions.setupTransition({
        transition: y,
        name: "peak-line-update",
        animate: e
      })
    ).attr("x1", (y) => p(y)).attr("x2", (y) => p(y)).attr("role", X.GRAPHICS_SYMBOL).attr("aria-roledescription", "peak").attr("aria-label", (y) => y), x.exit().remove(), this.services.domUtils.setSVGMaxHeight(), this.addEventListeners();
  }
  // add event listeners for tooltips on proportional meter bars
  addEventListeners() {
    const e = this.getOptions(), { groupMapsTo: t } = e.data, n = this, s = v(e, "meter", "proportional");
    this.parent.selectAll("rect.value").on("mouseover", function(a, i) {
      const r = T(this);
      n.services.events.dispatchEvent(f.Meter.METER_MOUSEOVER, {
        event: a,
        element: r,
        datum: i
      }), s && (r.classed("hovered", !0), n.services.events.dispatchEvent(f.Tooltip.SHOW, {
        event: a,
        hoveredElement: r,
        items: [
          {
            label: i[t],
            value: i.value
          }
        ]
      }));
    }).on("mousemove", function(a, i) {
      const r = T(this);
      n.services.events.dispatchEvent(f.Meter.METER_MOUSEMOVE, {
        event: a,
        element: r,
        datum: i
      }), s && n.services.events.dispatchEvent(f.Tooltip.MOVE, {
        event: a
      });
    }).on("click", function(a, i) {
      n.services.events.dispatchEvent(f.Meter.METER_CLICK, {
        event: a,
        element: T(this),
        datum: i
      });
    }).on("mouseout", function(a, i) {
      const r = T(this);
      n.services.events.dispatchEvent(f.Meter.METER_MOUSEOUT, {
        event: a,
        element: r,
        datum: i
      }), s && (r.classed("hovered", !1), n.services.events.dispatchEvent(f.Tooltip.HIDE, {
        hoveredElement: r
      }));
    });
  }
  destroy() {
    this.parent.selectAll("rect.value").on("mouseover", null).on("mousemove", null).on("mouseout", null).on("click", null);
  }
}
class Qh extends Y {
  constructor() {
    super(...arguments), this.type = "radar", this.renderType = j.SVG, this.getLabelDimensions = (e) => {
      const t = S.appendOrSelect(this.getComponentContainer(), "g.tmp-tick"), n = S.appendOrSelect(t, "text").text(e), { width: s, height: a } = S.getSVGElementSize(n.node(), { useBBox: !0 });
      return t.remove(), { width: s, height: a };
    }, this.normalizeFlatData = (e) => {
      const t = this.getOptions(), { angle: n, value: s } = v(t, "radar", "axes"), a = v(t, "data", "groupMapsTo"), i = kr(
        this.uniqueKeys.map((r) => this.uniqueGroups.map((l) => ({
          [n]: r,
          [a]: l,
          [s]: null
        })))
      );
      return ut(i, e);
    }, this.normalizeGroupedData = (e) => {
      const t = this.getOptions(), { angle: n, value: s } = v(t, "radar", "axes"), a = v(t, "data", "groupMapsTo");
      return e.map(({ name: i, data: r }) => {
        const l = this.uniqueKeys.map((c) => ({
          [a]: i,
          [n]: c,
          [s]: null
        }));
        return { name: i, data: ut(l, r) };
      });
    }, this.handleLegendOnHover = (e) => {
      const { hoveredElement: t } = e.detail;
      this.parent.selectAll("g.blobs path").transition("legend-hover-blob").call(
        (n) => this.services.transitions.setupTransition({
          transition: n,
          name: "legend-hover-blob"
        })
      ).style("fill-opacity", (n) => n.name !== t.datum().name ? je.opacity.unselected : je.opacity.selected).style("stroke-opacity", (n) => n.name !== t.datum().name ? je.opacity.unselected : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("g.blobs path").transition("legend-mouseout-blob").call(
        (e) => this.services.transitions.setupTransition({
          transition: e,
          name: "legend-mouseout-blob"
        })
      ).style("fill-opacity", je.opacity.selected).style("stroke-opacity", 1);
    };
  }
  init() {
    const { events: e } = this.services;
    e.addEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.addEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(e = !0) {
    const t = this.getComponentContainer(), { width: n, height: s } = S.getSVGElementSize(t, {
      useAttrs: !0
    }), a = this.model.getData(), i = this.model.getGroupedData(), r = this.getOptions(), l = v(r, "data", "groupMapsTo"), c = v(r, "radar", "axes", "value"), { angle: d, value: p } = v(r, "radar", "axes"), { xLabelPadding: h, yLabelPadding: u, yTicksNumber: g, minRange: m, xAxisRectHeight: E } = je;
    this.uniqueKeys = Array.from(new Set(a.map((_) => _[d]))), this.uniqueGroups = Array.from(new Set(a.map((_) => _[l]))), this.fullDataNormalized = this.normalizeFlatData(a), this.groupedDataNormalized = this.normalizeGroupedData(i);
    const x = 2 * (this.getLabelDimensions(this.uniqueKeys[0]).height + u), A = (Math.min(n, s) - x) / 2;
    if (A <= 0)
      return;
    const L = Un().domain(this.fullDataNormalized.map((_) => _[d])).range([0, 2 * Math.PI].map((_) => _ - Math.PI / 2)), I = En(this.fullDataNormalized.map((_) => _[p])), P = qe().domain([
      I >= 0 ? 0 : I,
      fs(this.fullDataNormalized.map((_) => _[p]))
    ]).range([m, A]).nice(g), W = P.ticks(g), k = (_, R, N) => this.model.getFillColor(_, R, N), C = hi().angle((_) => L(_[d]) + Math.PI / 2).radius((_) => P(_[p])).curve(ui), V = this.uniqueKeys.map((_) => {
      const R = this.getLabelDimensions(_).width, N = Li(
        L(_),
        A
      );
      return R + N;
    }), M = {
      x: fs(V) + h,
      y: s / 2
    }, me = S.appendOrSelect(t, "g.y-axes").attr("role", X.GROUP).selectAll("path").data(W, (_) => _), q = (_) => this.uniqueKeys.map((R) => ({ [d]: R, [p]: _ }));
    me.join(
      (_) => _.append("path").attr("opacity", 0).attr("transform", `translate(${M.x}, ${M.y})`).attr("fill", "none").call(
        (R) => R.transition().call(
          (N) => this.services.transitions.setupTransition({
            transition: N,
            name: "radar_y_axes_enter",
            animate: e
          })
        ).attr("opacity", 1).attr("d", (N) => C(q(N)))
      ),
      (_) => _.call(
        (R) => R.transition().call(
          (N) => this.services.transitions.setupTransition({
            transition: N,
            name: "radar_y_axes_update",
            animate: e
          })
        ).attr("opacity", 1).attr("transform", `translate(${M.x}, ${M.y})`).attr("d", (N) => C(q(N)))
      ),
      (_) => _.call(
        (R) => R.transition().call(
          (N) => this.services.transitions.setupTransition({
            transition: N,
            name: "radar_y_axes_exit",
            animate: e
          })
        ).attr("d", (N) => C(q(N))).attr("opacity", 0).remove()
      )
    ), S.appendOrSelect(t, "g.x-axes").attr("role", X.GROUP).selectAll("line").data(this.uniqueKeys, (_) => _).join(
      (_) => _.append("line").attr("opacity", 0).attr("class", (R) => `x-axis-${it(R)}`).attr("stroke-dasharray", "0").attr("x1", (R) => le(L(R), 0, M).x).attr("y1", (R) => le(L(R), 0, M).y).attr("x2", (R) => le(L(R), 0, M).x).attr("y2", (R) => le(L(R), 0, M).y).call(
        (R) => R.transition().call(
          (N) => this.services.transitions.setupTransition({
            transition: N,
            name: "radar_x_axes_enter",
            animate: e
          })
        ).attr("opacity", 1).attr("x1", (N) => le(L(N), P.range()[0], M).x).attr("y1", (N) => le(L(N), P.range()[0], M).y).attr("x2", (N) => le(L(N), P.range()[1], M).x).attr("y2", (N) => le(L(N), P.range()[1], M).y)
      ),
      (_) => _.call(
        (R) => R.transition().call(
          (N) => this.services.transitions.setupTransition({
            transition: N,
            name: "radar_x_axes_update",
            animate: e
          })
        ).attr("opacity", 1).attr("x1", (N) => le(L(N), P.range()[0], M).x).attr("y1", (N) => le(L(N), P.range()[0], M).y).attr("x2", (N) => le(L(N), P.range()[1], M).x).attr("y2", (N) => le(L(N), P.range()[1], M).y)
      ),
      (_) => _.call(
        (R) => R.transition().call(
          (N) => this.services.transitions.setupTransition({
            transition: N,
            name: "radar_x_axes_exit",
            animate: e
          })
        ).attr("opacity", 0).remove()
      )
    ), S.appendOrSelect(t, "g.x-labels").attr("role", X.GROUP).selectAll("text").data(this.uniqueKeys).join(
      (_) => _.append("text").text((R) => R).attr("opacity", 0).attr(
        "x",
        (R) => le(L(R), P.range()[1] + h, M).x
      ).attr(
        "y",
        (R) => le(L(R), P.range()[1] + h, M).y
      ).style("text-anchor", (R) => ys(L(R)).textAnchor).style(
        "dominant-baseline",
        (R) => ys(L(R)).dominantBaseline
      ).call(
        (R) => R.transition().call(
          (N) => this.services.transitions.setupTransition({
            transition: N,
            name: "radar_x_labels_enter",
            animate: e
          })
        ).attr("opacity", 1)
      ),
      (_) => _.call(
        (R) => R.transition().call(
          (N) => this.services.transitions.setupTransition({
            transition: N,
            name: "radar_x_labels_update",
            animate: e
          })
        ).attr("opacity", 1).attr(
          "x",
          (N) => le(L(N), P.range()[1] + h, M).x
        ).attr(
          "y",
          (N) => le(L(N), P.range()[1] + h, M).y
        ).end().finally(() => {
          const N = v(r, "radar", "alignment"), Re = this.getAlignmentXOffset(N, t, this.getParent());
          t.attr("x", Re);
        })
      ),
      (_) => _.call(
        (R) => R.transition().call(
          (N) => this.services.transitions.setupTransition({
            transition: N,
            name: "radar_x_labels_exit",
            animate: e
          })
        ).attr("opacity", 0).remove()
      )
    ), S.appendOrSelect(t, "g.blobs").attr("role", X.GROUP).selectAll("path").data(this.groupedDataNormalized, (_) => _.name).join(
      (_) => _.append("path").attr(
        "class",
        (R) => this.model.getColorClassName({
          classNameTypes: [z.FILL, z.STROKE],
          dataGroupName: R.name,
          originalClassName: "blob"
        })
      ).attr("role", X.GRAPHICS_SYMBOL).attr("aria-label", (R) => R.name).attr("opacity", 0).attr(
        "transform",
        e ? () => `translate(${M.x}, ${M.y}) scale(${1 + Math.random() * 0.35})` : `translate(${M.x}, ${M.y})`
      ).style("fill", (R) => k(R.name, null, R.data)).style("fill-opacity", je.opacity.selected).style("stroke", (R) => k(R.name, null, R.data)).call((R) => {
        const N = R.transition().call(
          (Re) => this.services.transitions.setupTransition({
            transition: Re,
            name: "radar_blobs_enter",
            animate: e
          })
        );
        e && N.delay(() => Math.random() * 30).attr("transform", `translate(${M.x}, ${M.y})`), N.attr("opacity", 1).attr("d", (Re) => C(Re.data));
      }),
      (_) => (_.attr(
        "class",
        (R) => this.model.getColorClassName({
          classNameTypes: [z.FILL, z.STROKE],
          dataGroupName: R.name,
          originalClassName: "blob"
        })
      ).style("fill", (R) => k(R.name, null, R.data)).style("stroke", (R) => k(R.name, null, R.data)), _.call(
        (R) => R.transition().call(
          (N) => this.services.transitions.setupTransition({
            transition: N,
            name: "radar_blobs_update",
            animate: e
          })
        ).attr("opacity", 1).attr("transform", `translate(${M.x}, ${M.y})`).attr("d", (N) => C(N.data))
      ), _),
      (_) => _.call((R) => {
        const N = R.transition().call(
          (Re) => this.services.transitions.setupTransition({
            transition: Re,
            name: "radar_blobs_exit",
            animate: e
          })
        );
        e && N.delay(() => Math.random() * 30).attr(
          "transform",
          () => `translate(${M.x}, ${M.y}) scale(${1 + Math.random() * 0.35})`
        ), N.attr("opacity", 0).remove();
      })
    ), S.appendOrSelect(t, "g.dots").attr("role", X.GROUP).selectAll("circle").data(this.fullDataNormalized.filter((_) => v(_, p) !== null)).join(
      (_) => _.append("circle").attr("role", X.GRAPHICS_SYMBOL).attr("aria-label", (R) => R[c]),
      (_) => _,
      (_) => _.remove()
    ).attr(
      "class",
      (_) => this.model.getColorClassName({
        classNameTypes: [z.FILL],
        dataGroupName: _[l],
        originalClassName: it(_[d])
      })
    ).attr("cx", (_) => le(L(_[d]), P(_[p]), M).x).attr("cy", (_) => le(L(_[d]), P(_[p]), M).y).attr("r", 0).attr("opacity", 0).style("fill", (_) => k(_[l])), S.appendOrSelect(t, "g.x-axes-rect").attr("role", X.GROUP).selectAll("rect").data(this.uniqueKeys).join(
      (_) => _.append("rect"),
      (_) => _,
      (_) => _.remove()
    ).attr("x", M.x).attr("y", M.y - E / 2).attr("width", P.range()[1]).attr("height", E).style("fill", "red").style("fill-opacity", 0).attr("transform", (_) => `rotate(${Ai(L(_))}, ${M.x}, ${M.y})`);
    const { code: se, number: oe } = v(r, "locale");
    S.appendOrSelect(t, "g.y-labels").attr("role", X.GROUP).selectAll("text").data(Yt(W)).join(
      (_) => _.append("text").attr("opacity", 0).text((R) => oe(R, se)).attr(
        "x",
        (R) => le(-Math.PI / 2, P(R), M).x + u
      ).attr("y", (R) => le(-Math.PI / 2, P(R), M).y).style("text-anchor", "start").style("dominant-baseline", "middle").call(
        (R) => R.transition().call(
          (N) => this.services.transitions.setupTransition({
            transition: N,
            name: "radar_y_labels_enter",
            animate: e
          })
        ).attr("opacity", 1)
      ),
      (_) => _.call(
        (R) => R.transition().call(
          (N) => this.services.transitions.setupTransition({
            transition: N,
            name: "radar_y_labels_update",
            animate: e
          })
        ).text((N) => N).attr("opacity", 1).attr(
          "x",
          (N) => le(-Math.PI / 2, P(N), M).x + u
        ).attr("y", (N) => le(-Math.PI / 2, P(N), M).y)
      ),
      (_) => _.call(
        (R) => R.transition().call(
          (N) => this.services.transitions.setupTransition({
            transition: N,
            name: "radar_y_labels_exit",
            animate: e
          })
        ).attr("opacity", 0).remove()
      )
    ), this.addEventListeners();
  }
  getAlignmentXOffset(e, t, n) {
    const s = S.getSVGElementSize(t, {
      useBBox: !0
    }), { width: a } = S.getSVGElementSize(n, {
      useAttrs: !0
    });
    let i = 0;
    return e === Ce.CENTER ? i = Math.floor((a - s.width) / 2) : e === Ce.RIGHT && (i = a - s.width), i;
  }
  destroy() {
    this.parent.selectAll(".x-axes-rect > rect").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const e = this.services.events;
    e.removeEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.removeEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  addEventListeners() {
    const e = this, {
      axes: { angle: t }
    } = v(this.getOptions(), "radar");
    this.parent.selectAll(".x-axes-rect > rect").on("mouseover", function(n, s) {
      const a = T(this);
      e.services.events.dispatchEvent(f.Radar.X_AXIS_MOUSEOVER, {
        event: n,
        element: a,
        datum: s
      });
      const i = e.parent.select(`.x-axes .x-axis-${it(s)}`), r = e.parent.selectAll(`.dots circle.${it(s)}`), l = e.model.getActiveDataGroupNames(), c = e.getOptions(), { groupMapsTo: d } = c.data, p = v(c, "radar", "axes", "value");
      i.classed("hovered", !0).attr("stroke-dasharray", "4 4"), r.classed("hovered", !0).attr(
        "opacity",
        (u) => l.indexOf(u[d]) !== -1 ? 1 : 0
      ).attr("r", je.dotsRadius);
      const h = e.fullDataNormalized.filter(
        (u) => u[t] === s && l.indexOf(u[d]) !== -1
      );
      e.services.events.dispatchEvent(f.Tooltip.SHOW, {
        event: n,
        hoveredElement: a,
        items: h.filter((u) => typeof u[p] == "number").map((u) => ({
          label: u[d],
          value: u[p],
          color: e.model.getFillColor(u[d], null, u),
          class: e.model.getColorClassName({
            classNameTypes: [z.TOOLTIP],
            dataGroupName: u[d]
          })
        }))
      });
    }).on("mousemove", function(n, s) {
      const a = T(this);
      e.services.events.dispatchEvent(f.Radar.X_AXIS_MOUSEMOVE, {
        event: n,
        element: a,
        datum: s
      }), e.services.events.dispatchEvent(f.Tooltip.MOVE, {
        event: n
      });
    }).on("click", function(n, s) {
      e.services.events.dispatchEvent(f.Radar.X_AXIS_CLICK, {
        event: n,
        element: T(this),
        datum: s
      });
    }).on("mouseout", function(n, s) {
      const a = T(this), i = e.parent.select(`.x-axes .x-axis-${it(s)}`), r = e.parent.selectAll(`.dots circle.${it(s)}`);
      i.classed("hovered", !1).attr("stroke-dasharray", "0"), r.classed("hovered", !1).attr("opacity", 0).attr("r", 0), e.services.events.dispatchEvent(f.Radar.X_AXIS_MOUSEOUT, {
        event: n,
        element: a,
        datum: s
      }), e.services.events.dispatchEvent(f.Tooltip.HIDE);
    });
  }
}
class eu extends Xn {
  constructor() {
    super(...arguments), this.type = "simple-bar", this.renderType = j.SVG, this.handleLegendOnHover = (e) => {
      const { hoveredElement: t } = e.detail, { groupMapsTo: n } = this.getOptions().data;
      this.parent.selectAll("path.bar").transition("legend-hover-simple-bar").call(
        (s) => this.services.transitions.setupTransition({
          transition: s,
          name: "legend-hover-simple-bar"
        })
      ).attr("opacity", (s) => s[n] !== t.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.bar").transition("legend-mouseout-simple-bar").call(
        (e) => this.services.transitions.setupTransition({
          transition: e,
          name: "legend-mouseout-simple-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const e = this.services.events;
    e.addEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.addEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(e) {
    const t = this.getOptions(), { groupMapsTo: n } = t.data, s = this.getComponentContainer({ withinChartClip: !0 }), a = this.model.getDisplayData(this.configs.groups), i = this.services.cartesianScales.getOrientation(), r = s.selectAll("path.bar").data(a, (c) => c[n]);
    r.exit().attr("opacity", 0).remove(), r.enter().append("path").attr("opacity", 0).merge(r).classed("bar", !0).attr("width", this.getBarWidth.bind(this)).transition().call(
      (c) => this.services.transitions.setupTransition({
        transition: c,
        name: "bar-update-enter",
        animate: e
      })
    ).attr(
      "class",
      (c) => this.model.getColorClassName({
        classNameTypes: [z.FILL],
        dataGroupName: c[n],
        originalClassName: "bar"
      })
    ).style("fill", (c) => {
      const d = this.services.cartesianScales.getDomainIdentifier(c);
      return this.model.getFillColor(c[n], c[d], c);
    }).attr("d", (c) => {
      const d = this.services.cartesianScales.getRangeIdentifier(), p = this.getBarWidth(), h = c[d], u = this.services.cartesianScales.getDomainValue(c) - p / 2, g = u + p;
      let m, E;
      if (Array.isArray(h) && h.length === 2)
        m = this.services.cartesianScales.getRangeValue(h[0]), E = this.services.cartesianScales.getRangeValue(h[1]);
      else {
        const y = this.services.cartesianScales.getRangeScale().domain()[0];
        m = this.services.cartesianScales.getRangeValue(Math.max(0, y)), E = this.services.cartesianScales.getRangeValue(c);
      }
      const O = Math.abs(E - m);
      if (O !== 0 && O < 2 && (h > 0 && i === xe.VERTICAL || h < 0 && i === xe.HORIZONTAL ? E = m - 2 : E = m + 2), !this.isOutsideZoomedDomain(u, g))
        return Ee({ x0: u, x1: g, y0: m, y1: E }, i);
    }).attr("opacity", 1).attr("role", X.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (c) => c.value), this.addEventListeners();
  }
  addEventListeners() {
    const e = this;
    this.parent.selectAll("path.bar").on("mouseover", function(t, n) {
      const s = T(this);
      s.classed("hovered", !0), e.services.events.dispatchEvent(f.Bar.BAR_MOUSEOVER, {
        event: t,
        element: s,
        datum: n
      }), e.services.events.dispatchEvent(f.Tooltip.SHOW, {
        event: t,
        hoveredElement: s,
        data: [n]
      });
    }).on("mousemove", function(t, n) {
      e.services.events.dispatchEvent(f.Bar.BAR_MOUSEMOVE, {
        event: t,
        element: T(this),
        datum: n
      }), e.services.events.dispatchEvent(f.Tooltip.MOVE, {
        event: t
      });
    }).on("click", function(t, n) {
      e.services.events.dispatchEvent(f.Bar.BAR_CLICK, {
        event: t,
        element: T(this),
        datum: n
      });
    }).on("mouseout", function(t, n) {
      const s = T(this);
      s.classed("hovered", !1), e.services.events.dispatchEvent(f.Bar.BAR_MOUSEOUT, {
        event: t,
        element: s,
        datum: n
      }), e.services.events.dispatchEvent(f.Tooltip.HIDE, {
        hoveredElement: s
      });
    });
  }
  destroy() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const e = this.services.events;
    e.removeEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.removeEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
class tu extends Ol {
  constructor() {
    super(...arguments), this.type = "skeleton-lines";
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e = !0) {
    const t = v(this.getOptions(), "data", "loading"), n = !v(this.getOptions(), "grid", "x", "enabled") && !v(this.getOptions(), "grid", "y", "enabled") && !v(this.getOptions(), "axes", "bottom", "visible") && !v(this.getOptions(), "axes", "left", "visible");
    t && !n ? super.renderGridSkeleton(t) : t && n ? this.renderSparklineSkeleton(t) : this.removeSkeleton();
  }
  renderSparklineSkeleton(e) {
    this.setScales(), this.drawBackdrop(e), this.drawSparkline(e), this.updateBackdropStyle(), e && this.setShimmerEffect("shimmer-lines");
  }
  drawSparkline(e) {
    const t = this.backdrop.attr("width"), n = [100], s = S.appendOrSelect(this.backdrop, "g.y.skeleton"), a = s.selectAll("line").data(n);
    a.enter().append("line").merge(a).attr("x1", 0).attr("x2", t).attr("y1", (i) => i).attr("y2", (i) => i), s.selectAll("line").classed("shimmer-effect-lines", e).classed("empty-state-lines", !e).style(
      "stroke",
      e ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    );
  }
  updateBackdropStyle() {
    const e = this.parent;
    this.backdrop = S.appendOrSelect(e, "svg.chart-skeleton.DAII"), S.appendOrSelect(this.backdrop, "rect.chart-skeleton-backdrop").classed("shimmer-effect-lines", !1).classed("shimmer-effect-sparkline", !0).style("stroke", null);
  }
}
class nu extends Y {
  constructor() {
    super(...arguments), this.type = "area-stacked", this.renderType = j.SVG, this.handleLegendOnHover = (e) => {
      const { hoveredElement: t } = e.detail, n = this.getOptions(), { groupMapsTo: s } = n.data;
      this.parent.selectAll("path.area").transition("legend-hover-area").call(
        (a) => this.services.transitions.setupTransition({
          transition: a,
          name: "legend-hover-area"
        })
      ).attr("opacity", (a) => v(a, 0, s) !== t.datum().name ? $e.opacity.unselected : $e.opacity.selected);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.area").transition("legend-mouseout-area").call(
        (e) => this.services.transitions.setupTransition({
          transition: e,
          name: "legend-mouseout-area"
        })
      ).attr("opacity", $e.opacity.selected);
    };
  }
  init() {
    const e = this.services.events;
    e.addEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.addEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(e = !0) {
    const t = this.getComponentContainer({ withinChartClip: !0 }), n = this, s = this.getOptions(), { groupMapsTo: a } = s.data, i = Object.keys(s.axes).some((g) => s.axes[g].percentage), r = this.model.getStackedData({
      percentage: i,
      groups: this.configs.groups
    }), l = v(r, 0, 0), c = this.services.cartesianScales.getDomainAxisPosition({ datum: l }), d = this.services.cartesianScales.getRangeAxisPosition({ datum: l }), p = this.services.cartesianScales.getScaleByPosition(d), h = t.selectAll("path.area").data(r, (g) => v(g, 0, a));
    this.areaGenerator = Bn().x(
      (g) => this.services.cartesianScales.getValueThroughAxisPosition(
        c,
        g.data.sharedStackKey
      )
    ).y0((g) => p(g[0])).y1((g) => p(g[1])).curve(this.services.curves.getD3Curve()), h.exit().attr("opacity", 0).remove(), h.enter().append("path").attr("opacity", 0).merge(h).data(r, (g) => v(g, 0, a)).attr("class", "area").attr(
      "class",
      (g) => this.model.getColorClassName({
        classNameTypes: [z.FILL],
        dataGroupName: v(g, 0, a),
        originalClassName: "area"
      })
    ).style("fill", (g) => n.model.getFillColor(v(g, 0, a), null, g)).attr("role", X.GRAPHICS_SYMBOL).attr("aria-roledescription", "area").attr("aria-label", (g) => v(g, 0, a)).transition().call(
      (g) => this.services.transitions.setupTransition({
        transition: g,
        name: "area-update-enter",
        animate: e
      })
    ).attr("opacity", $e.opacity.selected).attr("d", this.areaGenerator);
  }
}
class su extends Xn {
  constructor() {
    super(...arguments), this.type = "stacked-bar", this.renderType = j.SVG, this.handleLegendOnHover = (e) => {
      const { hoveredElement: t } = e.detail, { groupMapsTo: n } = this.model.getOptions().data;
      this.parent.selectAll("path.bar").transition("legend-hover-bar").call(
        (s) => this.services.transitions.setupTransition({
          transition: s,
          name: "legend-hover-bar"
        })
      ).attr("opacity", (s) => s[n] !== t.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.bar").transition("legend-mouseout-bar").call(
        (e) => this.services.transitions.setupTransition({
          transition: e,
          name: "legend-mouseout-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const e = this.services.events;
    e.addEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.addEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(e) {
    const t = this.getComponentContainer({ withinChartClip: !0 }), n = this.getOptions(), { groupMapsTo: s } = n.data, a = this.model.getStackedData({
      groups: this.configs.groups,
      divergent: !0
    }), i = this.model.getActiveDataGroupNames(), r = t.selectAll("g.bars").data(a, (c) => v(c, 0, s));
    r.exit().attr("opacity", 0).remove(), r.enter().append("g").classed("bars", !0).attr("role", X.GROUP).attr("data-name", "bars");
    const l = t.selectAll("g.bars").selectAll("path.bar").data(
      (c) => c,
      (c) => c.data.sharedStackKey
    );
    l.exit().remove(), l.enter().append("path").merge(l).classed("bar", !0).transition().call(
      (c) => this.services.transitions.setupTransition({
        transition: c,
        name: "bar-update-enter",
        animate: e
      })
    ).attr(
      "class",
      (c) => this.model.getColorClassName({
        classNameTypes: [z.FILL],
        dataGroupName: c[s],
        originalClassName: "bar"
      })
    ).style(
      "fill",
      (c) => this.model.getFillColor(c[s], c.data.sharedStackKey, c.data)
    ).attr("d", (c) => {
      const d = c.data.sharedStackKey, p = this.getBarWidth(), h = this.services.cartesianScales.getDomainValue(d) - p / 2, u = h + p, g = this.services.cartesianScales.getRangeValue(c[0]);
      let m = this.services.cartesianScales.getRangeValue(c[1]);
      if (!this.isOutsideZoomedDomain(h, u)) {
        if (Math.abs(m - g) > 0 && Math.abs(m - g) > n.bars.dividerSize) {
          const E = c[0] < 0 && c[1] <= 0;
          E && i.length > 1 ? this.services.cartesianScales.getOrientation() === xe.VERTICAL ? m += c[1] === 0 ? 2 : 1 : m -= 1 : E || (this.services.cartesianScales.getOrientation() === xe.VERTICAL ? m += 1 : m -= 1);
        }
        return Ee(
          { x0: h, x1: u, y0: g, y1: m },
          this.services.cartesianScales.getOrientation()
        );
      }
    }).attr("opacity", 1).attr("role", X.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (c) => c[1] - c[0]), this.addEventListeners();
  }
  addEventListeners() {
    const e = this.getOptions(), { groupMapsTo: t } = e.data, n = this;
    this.parent.selectAll("path.bar").on("mouseover", function(s, a) {
      const i = T(this);
      i.classed("hovered", !0), n.services.events.dispatchEvent(f.Bar.BAR_MOUSEOVER, {
        event: s,
        element: i,
        datum: a
      });
      let l = n.model.getDisplayData(n.configs.groups).find((c) => {
        const d = n.services.cartesianScales.getDomainIdentifier(c), p = n.services.cartesianScales.getRangeIdentifier(c);
        return c[p] === a.data[a[t]] && c[d].toString() === a.data.sharedStackKey && c[t] === a[t];
      });
      if (l === void 0) {
        const c = n.services.cartesianScales.getDomainIdentifier(), d = n.services.cartesianScales.getRangeIdentifier();
        l = {
          [c]: a.data.sharedStackKey,
          [d]: a.data[a[t]],
          [t]: a[t]
        };
      }
      n.services.events.dispatchEvent(f.Tooltip.SHOW, {
        event: s,
        hoveredElement: i,
        data: [l]
      });
    }).on("mousemove", function(s, a) {
      const i = T(this);
      n.services.events.dispatchEvent(f.Bar.BAR_MOUSEMOVE, {
        event: s,
        element: i,
        datum: a
      }), n.services.events.dispatchEvent(f.Tooltip.MOVE, {
        event: s
      });
    }).on("click", function(s, a) {
      n.services.events.dispatchEvent(f.Bar.BAR_CLICK, {
        event: s,
        element: T(this),
        datum: a
      });
    }).on("mouseout", function(s, a) {
      const i = T(this);
      i.classed("hovered", !1), n.services.events.dispatchEvent(f.Bar.BAR_MOUSEOUT, {
        event: s,
        element: i,
        datum: a
      }), n.services.events.dispatchEvent(f.Tooltip.HIDE, {
        hoveredElement: i
      });
    });
  }
  getBarWidth() {
    const e = this.getOptions();
    if (v(e, "bars", "width"))
      return e.bars.width;
    const t = this.services.cartesianScales.getMainXScale(), n = S.getSVGElementSize(this.parent, {
      useAttrs: !0
    }).width, s = this.model.getStackKeys().length, a = v(e, "bars", "spacingFactor");
    return t.step ? Math.min(e.bars.maxWidth, t.step() / 2) : Math.min(e.bars.maxWidth, n * a / s);
  }
  destroy() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const e = this.services.events;
    e.removeEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.removeEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
class au extends Wn {
  constructor() {
    super(...arguments), this.type = "scatter-stacked", this.renderType = j.SVG;
  }
  render(e) {
    if (!v(this.getOptions(), "points", "enabled"))
      return;
    const n = this.getComponentContainer({ withinChartClip: !0 }), s = this.getOptions(), { groupMapsTo: a } = s.data, i = Object.keys(s.axes).some((u) => s.axes[u].percentage), r = this.model.getStackedData({
      groups: this.configs.groups,
      percentage: i
    }), l = n.selectAll("g.dots").data(r, (u) => v(u, 0, a));
    l.exit().attr("opacity", 0).remove();
    const d = l.enter().append("g").classed("dots", !0).attr("role", X.GROUP).merge(l).selectAll("circle.dot").data((u) => u);
    d.exit().attr("opacity", 0).remove();
    const h = d.enter().append("circle").classed("dot", !0).attr("opacity", 0).merge(d).datum((u) => {
      const g = u[a], m = this.services.cartesianScales.getDomainIdentifier(u), E = this.services.cartesianScales.getRangeIdentifier(u);
      return {
        [a]: g,
        [m]: u.data.sharedStackKey,
        [E]: u[1]
      };
    });
    this.styleCircles(h, e), this.addEventListeners();
  }
  getTooltipData(e, t) {
    const n = this.getOptions(), { groupMapsTo: s } = n.data, a = Object.keys(n.axes).some((l) => n.axes[l].percentage), i = this.model.getStackedData({
      groups: this.configs.groups,
      percentage: a
    }), r = [];
    return i.forEach((l, c) => {
      l.forEach((d, p) => {
        const h = d[s], u = d.data.sharedStackKey;
        let g = d.data[h];
        const m = d[1], E = this.services.cartesianScales.getDomainIdentifier(d), O = this.services.cartesianScales.getRangeIdentifier(d);
        g != null && e === this.services.cartesianScales.getDomainValue(u) && t === this.services.cartesianScales.getRangeValue(m) && (a && (g = this.model.getStackedData({
          groups: this.configs.groups
        })[c][p].data[h]), g !== null && r.push({
          [s]: h,
          [E]: u,
          [O]: g
        }));
      });
    }), this.model.getDisplayData(this.configs.groups).filter((l) => {
      const c = this.services.cartesianScales.getDomainIdentifier(l), d = this.services.cartesianScales.getRangeIdentifier(l);
      return r.find((p) => p[s] == l[s] && p[c] == l[c] && p[d] == l[d]) !== void 0;
    });
  }
}
const ot = 6;
class iu extends Y {
  constructor() {
    super(...arguments), this.type = "tree", this.renderType = j.SVG;
  }
  getLongestLabel(e) {
    let t = "";
    return e.forEach((n) => {
      const s = n.children ? this.getLongestLabel(n.children) : "";
      (s.length > t.length || n.name.length > t.length) && (t = s.length > n.name.length ? s : n.name);
    }), t;
  }
  getMockLabelWidth(e, t) {
    const n = e.append("text").attr("dy", "0.31em").attr("x", 0).attr("text-anchor", "end").text(t), { width: s } = S.getSVGElementSize(n.node(), {
      useBBox: !0
    });
    return n.remove(), s;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e = !0) {
    const t = this.getComponentContainer();
    t.html("");
    const { width: n, height: s } = S.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    if (n < 1 || s < 1)
      return;
    const a = this.model.getOptions(), i = this.model.getDisplayData(), r = v(a, "tree", "rootTitle") || "Tree", l = this.getMockLabelWidth(t, r), c = this.getLongestLabel(i), d = this.getMockLabelWidth(t, c), p = {
      top: 0,
      right: 0,
      bottom: 0,
      left: l > 0 ? l + ot : 30 - ot
    }, h = Fn({
      name: r,
      children: i
    }), u = 10, g = n / 6, m = (L) => {
      const I = h.descendants().reverse(), P = h.links();
      let W = h, k = h;
      h.eachBefore((H) => {
        H.x < W.x && (W = H), H.x > k.x && (k = H);
      });
      const C = k.x - W.x, V = t.transition().call(
        (H) => this.services.transitions.setupTransition({
          transition: H,
          name: "tree-update-viewbox",
          animate: !0
        })
      ).attr("viewBox", [-p.left, W.x, n, C].join(" ")), F = A.selectAll("g").data(I, (H) => H.id), M = this, J = F.enter().append("g").attr("transform", () => `translate(${L.y0},${L.x0})`).attr(
        "class",
        (H) => H.depth !== 0 && H.children && H.children.length > 0 ? "clickable" : null
      ).on("mouseover", function(H, ae) {
        M.services.events.dispatchEvent(f.Tree.NODE_MOUSEOVER, {
          event: H,
          element: T(this),
          datum: ae
        });
      }).on("click", function(H, ae) {
        ae.depth !== 0 && (ae.children = ae.children ? null : ae._children, m(ae)), M.services.events.dispatchEvent(f.Tree.NODE_CLICK, {
          event: H,
          element: T(this),
          datum: ae
        });
      }).on("mouseout", function(H, ae) {
        M.services.events.dispatchEvent(f.Tree.NODE_MOUSEOUT, {
          event: H,
          element: T(this),
          datum: ae
        });
      });
      J.append("circle").attr("r", 2.5).attr("class", (H) => H._children ? "parent" : "child").attr("stroke-width", 10), J.append("text").attr("dy", "0.31em").attr("x", (H) => H._children ? -ot : ot).attr("text-anchor", (H) => H._children ? "end" : "start").text((H) => H.data.name).clone(!0).attr("class", "text-stroke").lower(), F.merge(J).transition(V).attr("transform", (H) => `translate(${H.y},${H.x})`).attr("fill-opacity", 1).attr("stroke-opacity", 1), F.exit().transition(V).remove().attr("transform", () => `translate(${L.y},${L.x})`).attr("fill-opacity", 0).attr("stroke-opacity", 0);
      const me = w.selectAll("path").data(P, (H) => H.target.id), q = me.enter().append("path").attr("d", () => {
        const H = { x: L.x0, y: L.y0 };
        return y({ source: H, target: H });
      });
      me.merge(q).transition(V).attr("d", y), me.exit().transition(V).remove().attr("d", () => {
        const H = { x: L.x, y: L.y };
        return y({ source: H, target: H });
      }), h.eachBefore((H) => {
        H.x0 = H.x, H.y0 = H.y;
      });
    }, E = h.descendants(), O = E[E.length - 1].depth, x = v(a, "tree", "type") === Ci.DENDROGRAM ? pi().size([
      s,
      n - d - O * ot - l
    ]) : gi().nodeSize([u, g]).size([
      s,
      n - d - O * ot - l
    ]), y = mi().x((L) => L.y).y((L) => L.x);
    h.x0 = g / 2, h.y0 = 0, h.descendants().forEach((L, I) => {
      L.id = I, L._children = L.children;
    }), x(h), t.attr("viewBox", [-p.left, -p.top, n, u]).style("user-select", "none");
    const w = t.append("g").attr("class", "links"), A = t.append("g").attr("class", "nodes");
    m(h);
  }
}
var kl = "#000000", Dl = "#ffffff", Pl = "#fcf4d6", Nl = "#fddc69", Vl = "#f1c21b", Bl = "#d2a106", Gl = "#b28600", Hl = "#8e6a00", $l = "#684e00", Ul = "#483700", Fl = "#302400", zl = "#1c1500", Wl = {
  10: Pl,
  20: Nl,
  30: Vl,
  40: Bl,
  50: Gl,
  60: Hl,
  70: $l,
  80: Ul,
  90: Fl,
  100: zl
}, jl = "#fff2e8", Xl = "#ffd9be", Zl = "#ffb784", Yl = "#ff832b", ql = "#eb6200", Kl = "#ba4e00", Jl = "#8a3800", Ql = "#5e2900", ec = "#3e1a00", tc = "#231000", nc = {
  10: jl,
  20: Xl,
  30: Zl,
  40: Yl,
  50: ql,
  60: Kl,
  70: Jl,
  80: Ql,
  90: ec,
  100: tc
}, sc = "#fff1f1", ac = "#ffd7d9", ic = "#ffb3b8", rc = "#ff8389", oc = "#fa4d56", lc = "#da1e28", cc = "#a2191f", dc = "#750e13", hc = "#520408", uc = "#2d0709", pc = {
  10: sc,
  20: ac,
  30: ic,
  40: rc,
  50: oc,
  60: lc,
  70: cc,
  80: dc,
  90: hc,
  100: uc
}, gc = "#fff0f7", mc = "#ffd6e8", fc = "#ffafd2", vc = "#ff7eb6", yc = "#ee5396", Ec = "#d02670", bc = "#9f1853", Sc = "#740937", Oc = "#510224", Tc = "#2a0a18", xc = {
  10: gc,
  20: mc,
  30: fc,
  40: vc,
  50: yc,
  60: Ec,
  70: bc,
  80: Sc,
  90: Oc,
  100: Tc
}, Lc = "#f6f2ff", Ac = "#e8daff", wc = "#d4bbff", Mc = "#be95ff", Cc = "#a56eff", _c = "#8a3ffc", Ic = "#6929c4", Rc = "#491d8b", kc = "#31135e", Dc = "#1c0f30", Pc = {
  10: Lc,
  20: Ac,
  30: wc,
  40: Mc,
  50: Cc,
  60: _c,
  70: Ic,
  80: Rc,
  90: kc,
  100: Dc
}, Nc = "#edf5ff", Vc = "#d0e2ff", Bc = "#a6c8ff", Gc = "#78a9ff", Hc = "#4589ff", $c = "#0f62fe", Uc = "#0043ce", Fc = "#002d9c", zc = "#001d6c", Wc = "#001141", jc = {
  10: Nc,
  20: Vc,
  30: Bc,
  40: Gc,
  50: Hc,
  60: $c,
  70: Uc,
  80: Fc,
  90: zc,
  100: Wc
}, Xc = "#e5f6ff", Zc = "#bae6ff", Yc = "#82cfff", qc = "#33b1ff", Kc = "#1192e8", Jc = "#0072c3", Qc = "#00539a", ed = "#003a6d", td = "#012749", nd = "#061727", sd = {
  10: Xc,
  20: Zc,
  30: Yc,
  40: qc,
  50: Kc,
  60: Jc,
  70: Qc,
  80: ed,
  90: td,
  100: nd
}, ad = "#d9fbfb", id = "#9ef0f0", rd = "#3ddbd9", od = "#08bdba", ld = "#009d9a", cd = "#007d79", dd = "#005d5d", hd = "#004144", ud = "#022b30", pd = "#081a1c", gd = {
  10: ad,
  20: id,
  30: rd,
  40: od,
  50: ld,
  60: cd,
  70: dd,
  80: hd,
  90: ud,
  100: pd
}, md = "#defbe6", fd = "#a7f0ba", vd = "#6fdc8c", yd = "#42be65", Ed = "#24a148", bd = "#198038", Sd = "#0e6027", Od = "#044317", Td = "#022d0d", xd = "#071908", Ld = {
  10: md,
  20: fd,
  30: vd,
  40: yd,
  50: Ed,
  60: bd,
  70: Sd,
  80: Od,
  90: Td,
  100: xd
}, Ad = "#f2f4f8", wd = "#dde1e6", Md = "#c1c7cd", Cd = "#a2a9b0", _d = "#878d96", Id = "#697077", Rd = "#4d5358", kd = "#343a3f", Dd = "#21272a", Pd = "#121619", Nd = {
  10: Ad,
  20: wd,
  30: Md,
  40: Cd,
  50: _d,
  60: Id,
  70: Rd,
  80: kd,
  90: Dd,
  100: Pd
}, Vd = "#f4f4f4", Bd = "#e0e0e0", Gd = "#c6c6c6", Hd = "#a8a8a8", $d = "#8d8d8d", Ud = "#6f6f6f", Fd = "#525252", zd = "#393939", Wd = "#262626", jd = "#161616", Xd = {
  10: Vd,
  20: Bd,
  30: Gd,
  40: Hd,
  50: $d,
  60: Ud,
  70: Fd,
  80: zd,
  90: Wd,
  100: jd
}, Zd = "#f7f3f2", Yd = "#e5e0df", qd = "#cac5c4", Kd = "#ada8a8", Jd = "#8f8b8b", Qd = "#726e6e", eh = "#565151", th = "#3c3838", nh = "#272525", sh = "#171414", ah = {
  10: Zd,
  20: Yd,
  30: qd,
  40: Kd,
  50: Jd,
  60: Qd,
  70: eh,
  80: th,
  90: nh,
  100: sh
}, qs = {
  black: {
    100: kl
  },
  blue: jc,
  coolGray: Nd,
  cyan: sd,
  gray: Xd,
  green: Ld,
  magenta: xc,
  orange: nc,
  purple: Pc,
  red: pc,
  teal: gd,
  warmGray: ah,
  white: {
    0: Dl
  },
  yellow: Wl
};
const ih = (o) => {
  if (!o)
    return null;
  for (const e of Object.keys(qs)) {
    const t = qs[e];
    for (const n of Object.keys(t))
      if (t[+n] === o)
        return n;
  }
  return null;
}, Ks = function() {
  const o = T(this.parentNode).select("rect.leaf"), e = getComputedStyle(o.node(), null).getPropertyValue(
    "fill"
  ), t = ra(e);
  let n;
  if (t && (n = ih(t ? t.hex() : null)), n == null) {
    const s = ia(t).l;
    n = Math.abs(s * 100 - 100);
  }
  return n > 50 ? "white" : "black";
};
let rh = 0;
class ru extends Y {
  constructor() {
    super(...arguments), this.type = "treemap", this.renderType = j.SVG, this.handleLegendOnHover = (e) => {
      const { hoveredElement: t } = e.detail;
      this.parent.selectAll("g[data-name='leaf']").transition("legend-hover-treemap").call(
        (n) => this.services.transitions.setupTransition({
          transition: n,
          name: "legend-hover-treemap"
        })
      ).attr(
        "opacity",
        (n) => n.parent.data.name === t.datum().name ? 1 : 0.3
      );
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("g[data-name='leaf']").transition("legend-mouseout-treemap").call(
        (e) => this.services.transitions.setupTransition({
          transition: e,
          name: "legend-mouseout-treemap"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const { events: e } = this.services;
    e.addEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.addEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(e = !0) {
    const t = this.getComponentContainer();
    this.model.getData();
    const n = this.model.getDisplayData(), s = this.model.getOptions(), a = v(window, "location"), { width: i, height: r } = S.getSVGElementSize(t, {
      useAttrs: !0
    }), l = Fn({
      name: s.title || "Treemap",
      children: n
    }).sum((m) => m.value).sort((m, E) => E.value - m.value), c = fi().size([i, r]).paddingInner(1).paddingOuter(0).round(!0)(
      l
    ), d = t.selectAll("g[data-name='leaf']").data(c.leaves(), (m) => m.data.name);
    d.exit().attr("opacity", 0).remove();
    const h = d.enter().append("g").attr("data-name", "leaf").attr("data-uid", () => rh++).merge(d);
    h.attr("data-name", "leaf").transition().call(
      (m) => this.services.transitions.setupTransition({
        transition: m,
        name: "treemap-group-update",
        animate: e
      })
    ).attr("transform", (m) => `translate(${m.x0},${m.y0})`);
    const u = h.selectAll("rect.leaf").data((m) => [m]);
    u.exit().attr("width", 0).attr("height", 0).remove(), u.enter().append("rect").classed("leaf", !0).merge(u).attr("width", 0).attr("height", 0).attr("id", function() {
      const m = T(this.parentNode).attr("data-uid");
      return `${s.style.prefix}-leaf-${m}`;
    }).attr("class", (m) => {
      for (; m.depth > 1; )
        m = m.parent;
      return this.model.getColorClassName({
        classNameTypes: [z.FILL],
        dataGroupName: m.data.name,
        originalClassName: "leaf"
      });
    }).transition().call(
      (m) => this.services.transitions.setupTransition({
        transition: m,
        name: "treemap-leaf-update-enter",
        animate: e
      })
    ).attr("width", (m) => m.x1 - m.x0).attr("height", (m) => m.y1 - m.y0).style("fill", (m) => {
      for (; m.depth > 1; )
        m = m.parent;
      return this.model.getFillColor(m.data.name, null, m.data);
    }), h.selectAll("clipPath").data(
      (m) => m.data.showLabel !== !0 ? [] : [1],
      (m) => m
    ).join(
      (m) => m.append("clipPath").attr("id", function() {
        const E = T(this.parentNode).attr("data-uid");
        return `${s.style.prefix}-clip-${E}`;
      }).append("use").attr("xlink:href", function() {
        const E = T(this.parentNode.parentNode).attr("data-uid"), O = `${s.style.prefix}-leaf-${E}`;
        return new URL(`#${O}`, a) + "";
      }),
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      (m) => null,
      (m) => m.remove()
    ), h.selectAll("text").data(
      (m) => {
        if (m.data.showLabel !== !0)
          return [];
        let E = m;
        for (; E.depth > 1; )
          E = E.parent;
        const O = ia(this.model.getFillColor(E.data.name));
        return [
          {
            text: m.data.name,
            color: O.l < 0.5 ? "white" : "black"
          }
        ];
      },
      (m) => m
    ).join(
      (m) => {
        const E = m.append("text").text((O) => O.text).style("fill", Ks).attr("x", 7).attr("y", 18);
        return a && E.attr("clip-path", function() {
          const O = T(this.parentNode).attr("data-uid"), x = `${s.style.prefix}-clip-${O}`;
          return `url(${new URL(`#${x}`, a) + ""})`;
        }), E;
      },
      (m) => m.text((E) => E.text).style("fill", Ks),
      (m) => m.remove()
    ), this.addEventListeners();
  }
  addEventListeners() {
    const e = this;
    this.parent.selectAll("rect.leaf").on("mouseover", function(t, n) {
      const s = T(this);
      let a = getComputedStyle(this, null).getPropertyValue("fill"), i = n;
      for (; i.depth > 1; )
        i = i.parent;
      s.transition("graph_element_mouseover_fill_update").call(
        (r) => e.services.transitions.setupTransition({
          transition: r,
          name: "graph_element_mouseover_fill_update"
        })
      ).style("fill", (r) => {
        const l = e.model.getFillColor(r.parent.data.name, null, r.data);
        return l && (a = l), ra(a).darker(0.7).toString();
      }), e.services.events.dispatchEvent(f.Tooltip.SHOW, {
        event: t,
        hoveredElement: s,
        items: [
          {
            color: a,
            label: i.data.name,
            bold: !0
          },
          {
            label: n.data.name,
            value: n.data.value
          }
        ]
      }), e.services.events.dispatchEvent(f.Treemap.LEAF_MOUSEOVER, {
        event: t,
        element: s,
        datum: n
      });
    }).on("mousemove", function(t, n) {
      const s = T(this);
      e.services.events.dispatchEvent(f.Treemap.LEAF_MOUSEMOVE, {
        event: t,
        element: s,
        datum: n
      }), e.services.events.dispatchEvent(f.Tooltip.MOVE, {
        event: t
      });
    }).on("click", function(t, n) {
      e.services.events.dispatchEvent(f.Treemap.LEAF_CLICK, {
        event: t,
        element: T(this),
        datum: n
      });
    }).on("mouseout", function(t, n) {
      const s = T(this);
      s.classed("hovered", !1);
      let a = n;
      for (; a.depth > 1; )
        a = a.parent;
      s.transition().call(
        (i) => e.services.transitions.setupTransition({
          transition: i,
          name: "graph_element_mouseout_fill_update"
        })
      ).style("fill", (i) => e.model.getFillColor(i.parent.data.name, null, i.data)), e.services.events.dispatchEvent(f.Treemap.LEAF_MOUSEOUT, {
        event: t,
        element: s,
        datum: n
      }), e.services.events.dispatchEvent(f.Tooltip.HIDE, {
        hoveredElement: s
      });
    });
  }
}
class ou extends Y {
  constructor() {
    super(...arguments), this.type = "wordcloud", this.renderType = j.SVG, this.handleLegendOnHover = (e) => {
      const { hoveredElement: t } = e.detail, { groupMapsTo: n } = this.getOptions().data;
      this.parent.selectAll("text.word").transition("legend-hover-wordcloud").call(
        (s) => this.services.transitions.setupTransition({
          transition: s,
          name: "legend-hover-wordcloud"
        })
      ).attr("opacity", (s) => s[n] !== t.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("text.word").transition("legend-mouseout-wordcloud").call(
        (e) => this.services.transitions.setupTransition({
          transition: e,
          name: "legend-mouseout-wordcloud"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const e = this.services.events;
    e.addEventListener(f.Legend.ITEM_HOVER, this.handleLegendOnHover), e.addEventListener(f.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(e = !0) {
    const t = this, n = this.getComponentContainer().attr("width", "100%").attr("height", "100%"), s = this.model.getDisplayData(), a = this.getFontSizeScale(s), i = this.getOptions(), { fontSizeMapsTo: r, wordMapsTo: l } = i.wordCloud, { groupMapsTo: c } = i.data, { width: d, height: p } = S.getSVGElementSize(n, {
      useAttrs: !0
    });
    if (d === 0 || p === 0)
      return;
    const h = Pi().size([d, p]).words(
      s.map(function(g) {
        const m = g[r];
        if (typeof g[r] != "number")
          throw Error(
            "Badly formatted WordCloud data. `value` should only be an integer or float"
          );
        return {
          [c]: g[c],
          text: g[l],
          size: m,
          value: m
        };
      })
    ).padding(5).rotate(0).fontSize((g) => a(g.size)).on("end", u);
    h.start();
    function u(g) {
      const m = S.appendOrSelect(n, "g.words");
      m.attr("transform", `translate(${h.size()[0] / 2}, ${h.size()[1] / 2})`);
      const E = m.selectAll("text").data(g, (x) => `${x[c]}-${x.text}`);
      E.exit().attr("opacity", 0).remove(), E.enter().append("text").attr("opacity", 0).merge(E).style("font-size", (x) => `${x.size}px`).text(function(x) {
        return x.text;
      }).attr(
        "class",
        (x) => t.model.getColorClassName({
          classNameTypes: [z.FILL],
          dataGroupName: x[c],
          originalClassName: `word ${x.size > 32 ? "light" : ""}`
        })
      ).style("fill", (x) => t.model.getFillColor(x[c], x.text, x)).attr("text-anchor", "middle").transition().call(
        (x) => t.services.transitions.setupTransition({
          transition: x,
          name: "wordcloud-text-update-enter",
          animate: e
        })
      ).attr("transform", (x) => `translate(${x.x}, ${x.y})`).attr("opacity", 1);
    }
    this.addEventListeners();
  }
  getFontSizeScale(e) {
    const t = this.getOptions(), { fontSizeMapsTo: n } = t.wordCloud, s = e.map((l) => l[n]).filter((l) => l), a = S.getHTMLElementSize(this.services.domUtils.getMainContainer()), i = s.length > 0, r = i ? Yt(s) : [1, 1];
    return qe().domain(r).range(i ? t.wordCloud.fontSizeRange(a, e) : [4, 4]);
  }
  addEventListeners() {
    const e = this.getOptions(), { groupMapsTo: t } = e.data, n = this, s = bn((a) => {
      const i = n.parent.selectAll("text.word").transition("wordcloud-word-mouse-highlight").call(
        (r) => n.services.transitions.setupTransition({
          transition: r,
          name: "wordcloud-word-mouse-highlight"
        })
      );
      a === null ? i.attr("opacity", 1) : i.attr("opacity", function() {
        return a === this ? 1 : 0.3;
      });
    }, 6);
    this.parent.selectAll("text.word").on("mouseover", function(a, i) {
      const r = this;
      s(r), n.services.events.dispatchEvent(f.WordCloud.WORD_MOUSEOVER, {
        event: a,
        element: T(this),
        datum: i
      }), n.services.events.dispatchEvent(f.Tooltip.SHOW, {
        event: a,
        hoveredElement: r,
        items: [
          {
            label: e.tooltip.wordLabel,
            value: i.text
          },
          {
            label: e.tooltip.valueLabel,
            value: i.value
          },
          {
            label: ne(e, "locale.translations.group") || ne(e, "tooltip.groupLabel") || "Group",
            value: i[t],
            class: n.model.getColorClassName({
              classNameTypes: [z.TOOLTIP],
              dataGroupName: i[t]
            })
          }
        ]
      });
    }).on("mousemove", function(a, i) {
      const r = T(this);
      n.services.events.dispatchEvent(f.WordCloud.WORD_MOUSEMOVE, {
        element: r,
        datum: i
      }), n.services.events.dispatchEvent(f.Tooltip.MOVE, {
        event: a
      });
    }).on("click", function(a, i) {
      n.services.events.dispatchEvent(f.WordCloud.WORD_CLICK, {
        event: a,
        element: T(this),
        datum: i
      });
    }).on("mouseout", function(a, i) {
      const r = T(this);
      s(null), n.services.events.dispatchEvent(f.WordCloud.WORD_MOUSEOUT, {
        event: a,
        element: r,
        datum: i
      }), n.services.events.dispatchEvent(f.Tooltip.HIDE, {
        hoveredElement: r
      });
    });
  }
}
class oh extends Y {
  constructor() {
    super(...arguments), this.type = "geo", this.renderType = j.SVG;
  }
  render() {
    const e = this.getComponentContainer({ withinChartClip: !0 }), { width: t, height: n } = S.getSVGElementSize(e, {
      useAttrs: !0
    });
    if (t < 1 || n < 1)
      return;
    const s = this.getProjection(), a = v(this.getOptions(), "geoData"), i = this.model.getCombinedData(), r = {}, l = {};
    Object.keys(i).forEach((O) => {
      typeof i[O].value == "number" ? r[O] = i[O] : l[O] = i[O];
    });
    const c = Cl(a, Object.values(l)), d = Al(a, {
      // We need to specify that we are converting geometry collections
      type: "GeometryCollection",
      geometries: Object.values(r)
    }), p = s.fitSize([t, n], d), h = vi().projection(p);
    S.appendOrSelect(e, "g.geo").selectAll("path").data(d.features).join("path").attr("d", h);
    const g = this.services.domUtils.generateElementIDString("geo-pattern-stripes"), m = S.appendOrSelect(e, "defs");
    S.appendOrSelect(m, "pattern").attr("id", g).attr("width", 5).attr("height", 10).attr("patternUnits", "userSpaceOnUse").attr("patternTransform", "rotate(45)").append("path").classed("pattern-fill", !0).attr(
      "d",
      Gn()([
        [0, 0],
        [0, 10]
      ])
    );
    const E = S.appendOrSelect(e, "g.missing-data");
    S.appendOrSelect(E, "path").datum(c).attr("d", h).style("fill", `url(#${g})`);
  }
  /**
   * @info
   * Depending on projection, we may need to provide additional configuration
   * e.g. sizing
   *
   * In such case, function can be refactored so that
   * projection should return an object with the configuraiton & function
   */
  getProjection() {
    let e = null;
    switch (v(this.getOptions(), "thematic", "projection")) {
      case Ze.geoEqualEarth:
        e = xi();
        break;
      case Ze.geoAlbers:
        e = Ti();
        break;
      case Ze.geoConicEqualArea:
        e = Oi();
        break;
      case Ze.geoConicEquidistant:
        e = Si();
        break;
      case Ze.geoEquirectangular:
        e = bi();
        break;
      case Ze.geoMercator:
        e = Ei();
        break;
      case Ze.geoNaturalEarth1:
        e = yi();
        break;
      default:
        throw new Error("Projection is not supported.");
    }
    return e;
  }
}
class lu extends oh {
  constructor() {
    super(...arguments), this.type = "choropleth";
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(e = !0) {
    super.render();
    const t = this.model.getCombinedData();
    this.getComponentContainer({ withinChartClip: !0 }).select("g.geo").selectAll("path").classed("border", !0).attr("class", (a) => this.model.getColorClassName({
      value: t[a.properties.NAME].value,
      originalClassName: "border"
    })), this.addCountryAreaEventListener();
  }
  addCountryAreaEventListener() {
    const e = this, t = this.model.getCombinedData();
    this.parent.selectAll("path.border").on("mouseover", function(n, s) {
      const a = T(this);
      e.services.events.dispatchEvent(kt.CHOROPLETH_MOUSEOVER, {
        event: n,
        element: a,
        datum: t[s.properties.NAME]
      }), e.services.events.dispatchEvent(dn.SHOW, {
        event: n,
        hoveredElement: a,
        items: [
          {
            label: s.properties.NAME,
            value: t[s.properties.NAME].value
          }
        ]
      });
    }).on("mousemove", function(n, s) {
      e.services.events.dispatchEvent(kt.CHOROPLETH_MOUSEMOVE, {
        event: n,
        element: T(this),
        datum: t[s.properties.NAME]
      }), e.services.events.dispatchEvent(dn.MOVE, {
        event: n
      });
    }).on("click", function(n, s) {
      e.services.events.dispatchEvent(kt.CHOROPLETH_CLICK, {
        event: n,
        element: T(this),
        datum: t[s.properties.NAME]
      });
    }).on("mouseout", function(n, s) {
      const a = T(this);
      e.services.events.dispatchEvent(kt.CHOROPLETH_MOUSEOUT, {
        event: n,
        element: a,
        datum: t[s.properties.NAME]
      }), e.services.events.dispatchEvent(dn.HIDE, {
        event: n,
        hoveredElement: a
      });
    });
  }
}
export {
  tu as $,
  Ra as A,
  Rh as B,
  yl as C,
  Ih as D,
  lu as E,
  Wh as F,
  xh as G,
  Sl as H,
  jh as I,
  Xh as J,
  Zh as K,
  vl as L,
  zh as M,
  Yh as N,
  qh as O,
  Ah as P,
  Kh as Q,
  Ia as R,
  kh as S,
  ks as T,
  Jh as U,
  Rl as V,
  Qh as W,
  Wn as X,
  eu as Y,
  Ch as Z,
  Ol as _,
  Ws as a,
  nu as a0,
  su as a1,
  au as a2,
  iu as a3,
  ru as a4,
  ou as a5,
  Ds as a6,
  fh as a7,
  Y as a8,
  Lr as a9,
  wh as b,
  Eh as c,
  Vh as d,
  Bh as e,
  Nh as f,
  Ph as g,
  Dh as h,
  Gh as i,
  Hh as j,
  Oh as k,
  yh as l,
  Fh as m,
  oh as n,
  Sh as o,
  vh as p,
  bh as q,
  fl as r,
  $h as s,
  Uh as t,
  El as u,
  Th as v,
  Lh as w,
  Xn as x,
  Mh as y,
  _h as z
};
//# sourceMappingURL=choropleth-DdBUe80H.mjs.map
