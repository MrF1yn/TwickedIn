import { o as w, p as z, q as j, m as u, s as O, t as G, u as U, v as M, f as N, w as F, x as _, y as V, z as b, g as L, A as C } from "./color-scale-utils-CiW9fERh.mjs";
import { bin as K, stack as S, stackOffsetDiverging as H, scaleOrdinal as R, quantile as E, ascending as Z, min as P, max as k, extent as Q, scaleLinear as W, scaleQuantize as X } from "d3";
import { S as f, _ as B, d as $, e as A, s as Y } from "./enums-DwsxZqjR.mjs";
import { b as J } from "./_baseEach-Ch85zB0O.mjs";
function tt(d, t, e, s) {
  for (var a = -1, n = d == null ? 0 : d.length; ++a < n; ) {
    var o = d[a];
    t(s, o, e(o), d);
  }
  return s;
}
function et(d, t, e, s) {
  return J(d, function(a, n, o) {
    t(s, a, e(a), o);
  }), s;
}
function st(d, t) {
  return function(e, s) {
    var a = z(e) ? tt : et, n = t ? t() : {};
    return a(e, d, w(s), n);
  };
}
function at(d) {
  for (var t = -1, e = d == null ? 0 : d.length, s = {}; ++t < e; ) {
    var a = d[t];
    s[a[0]] = a[1];
  }
  return s;
}
var ot = Object.prototype, nt = ot.hasOwnProperty, rt = st(function(d, t, e) {
  nt.call(d, e) ? d[e].push(t) : j(d, e, [t]);
});
function it(d) {
  const t = d.trim();
  return ["=", "+", "-", "@", "	", "\r"].includes(t.charAt(0)) ? `Â ${t}` : /[,\"\n]/.test(t) ? `"${t}"` : t;
}
class D {
  constructor(t) {
    this.state = {
      options: {}
    }, this.colorScale = {}, this.colorClassNames = {}, this.services = t;
  }
  formatTable({ headers: t, cells: e }) {
    const s = this.getOptions(), {
      code: a,
      date: n,
      number: o
    } = u(s, "locale"), i = u(s, "tabularRepModal", "tableHeadingFormatter"), r = u(s, "tabularRepModal", "tableCellFormatter"), { cartesianScales: c } = this.services, l = c == null ? void 0 : c.getDomainAxisScaleType();
    let p;
    return l === f.TIME && (p = (g) => n(g, a, { month: "short", day: "numeric", year: "numeric" })), [
      typeof i == "function" ? i(t) : t,
      ...typeof r == "function" ? r(e) : e.map((g) => {
        p && (g[1] = p(g[1]));
        for (let m in g) {
          let y = g[m];
          typeof y == "number" && (g[m] = o(y, a));
        }
        return g;
      })
    ];
  }
  getAllDataFromDomain(t) {
    if (!this.getData())
      return null;
    const e = this.getOptions();
    let s = this.getData();
    const a = this.getDataGroups(), { groupMapsTo: n } = u(e, "data"), o = u(e, "axes");
    return t && (s = s.filter((i) => t.includes(i[n]))), o && Object.keys(o).forEach((i) => {
      const r = o[i].mapsTo, c = o[i].scaleType;
      if ((c === f.LINEAR || c === f.LOG) && (s = s.map((l) => ({
        ...l,
        [r]: l[r] === null ? l[r] : Number(l[r])
      }))), r && o[i].domain)
        if (c === f.LABELS)
          s = s.filter(
            (l) => o[i].domain.includes(l[r])
          );
        else {
          const [l, p] = o[i].domain;
          s = s.filter(
            (h) => !(r in h) || h[r] >= l && h[r] <= p
          );
        }
    }), s.filter((i) => a.find((r) => r.name === i[n]));
  }
  /**
   * Charts that have group configs passed into them, only want to retrieve the display data relevant to that chart
   * @param groups the included datasets for the particular chart
   */
  getDisplayData(t) {
    if (!this.get("data"))
      return null;
    const { ACTIVE: e } = O.items.status, s = this.getDataGroups(t), { groupMapsTo: a } = this.getOptions().data;
    return this.getAllDataFromDomain(t).filter((o) => s.find(
      (i) => i.name === o[a] && i.status === e
    ));
  }
  getData() {
    return this.get("data");
  }
  isDataEmpty() {
    return !this.getData().length;
  }
  /**
   *
   * @param newData The new raw data to be set
   */
  setData(t) {
    const e = this.sanitize(G(t)), s = this.generateDataGroups(e);
    return this.set({
      data: e,
      dataGroups: s
    }), e;
  }
  getDataGroups(t) {
    return u(this.getOptions(), "data", "loading") ? [] : t ? this.get("dataGroups").filter((s) => t.includes(s.name)) : this.get("dataGroups");
  }
  getActiveDataGroups(t) {
    const { ACTIVE: e } = O.items.status;
    return this.getDataGroups(t).filter((s) => s.status === e);
  }
  getDataGroupNames(t) {
    return this.getDataGroups(t).map((s) => s.name);
  }
  getActiveDataGroupNames(t) {
    return this.getActiveDataGroups(t).map((s) => s.name);
  }
  aggregateBinDataByGroup(t) {
    return rt(t, "group");
  }
  getBinConfigurations() {
    const t = this.getDisplayData(), e = this.getOptions(), s = this.services.cartesianScales.getMainXAxisPosition(), a = this.services.cartesianScales.getDomainIdentifier(), n = e.axes[s], { groupMapsTo: o } = e.data, { bins: i = U.defaultBins } = n, r = Array.isArray(i), c = K().value((g) => g[a]).thresholds(i)(t);
    if (r)
      c[c.length - 1].x1 = i[i.length - 1];
    else {
      const g = c[0].x1 - c[0].x0;
      c[c.length - 1].x1 = +c[c.length - 1].x0 + g;
    }
    const l = r ? [i[0], i[i.length - 1]] : [c[0].x0, c[c.length - 1].x1], p = Array.from(new Set(t.map((g) => g[o]))), h = [];
    return c.forEach((g) => {
      const m = `${g.x0}-${g.x1}`, y = this.aggregateBinDataByGroup(g);
      p.forEach((x) => {
        h.push({
          group: x,
          key: m,
          value: y[x] || 0,
          bin: g.x0
        });
      });
    }), {
      bins: c,
      binsDomain: l
    };
  }
  getBinnedStackedData() {
    const t = this.getOptions(), { groupMapsTo: e } = t.data, s = this.getActiveDataGroupNames(), { bins: a } = this.getBinConfigurations(), n = this.getDataValuesGroupedByKeys({
      bins: a
    });
    return S().keys(s)(n).map((o, i) => Object.keys(o).filter((r) => !isNaN(r)).map((r) => {
      const c = o[r];
      return c[e] = s[i], c;
    }));
  }
  getGroupedData(t) {
    const e = this.getDisplayData(t), s = {}, { groupMapsTo: a } = this.getOptions().data;
    return e.map((n) => {
      const o = n[a];
      s[o] !== null && s[o] !== void 0 ? s[o].push(n) : s[o] = [n];
    }), Object.keys(s).map((n) => ({
      name: n,
      data: s[n]
    }));
  }
  getStackKeys({ bins: t = null, groups: e = null } = { bins: null, groups: null }) {
    const s = this.getOptions(), a = this.getDisplayData(e);
    let n;
    t ? n = t.map((r) => `${r.x0}:${r.x1}`) : n = M(
      a.map((r) => {
        const c = this.services.cartesianScales.getDomainIdentifier(r);
        return r[c] instanceof Date ? N(r[c]) : r[c] && typeof r[c].toString == "function" ? r[c].toString() : r[c];
      })
    );
    const o = this.services.cartesianScales.domainAxisPosition, i = s.axes[o].scaleType;
    return i === f.TIME ? n.sort((r, c) => {
      const l = new Date(r), p = new Date(c);
      return l - p;
    }) : (i === f.LOG || i === f.LINEAR) && n.sort((r, c) => r - c), n;
  }
  getDataValuesGroupedByKeys({ bins: t = null, groups: e = null }) {
    const s = this.getOptions(), { groupMapsTo: a } = s.data, n = this.getDisplayData(e), o = this.getDataGroupNames(), i = this.getStackKeys({ bins: t, groups: e });
    return t ? i.map((r) => {
      const [c, l] = r.split(":"), p = { x0: c, x1: l }, h = t.find((g) => g.x0.toString() === c.toString());
      return o.forEach((g) => {
        p[g] = h.filter(
          (m) => m[a] === g
        ).length;
      }), p;
    }) : i.map((r) => {
      const c = { sharedStackKey: r };
      return o.forEach((l) => {
        const p = n.find((g) => {
          const m = this.services.cartesianScales.getDomainIdentifier(g);
          return g[a] === l && Object.prototype.hasOwnProperty.call(g, m) && (g[m] instanceof Date ? N(g[m]) === r : g[m].toString() === r);
        }), h = this.services.cartesianScales.getRangeIdentifier(c);
        c[l] = p ? p[h] : null;
      }), c;
    });
  }
  getStackedData({ percentage: t = !1, groups: e = null, divergent: s = !1 }) {
    const a = this.getOptions(), { groupMapsTo: n } = a.data, o = this.getActiveDataGroupNames(e), i = this.getDataValuesGroupedByKeys({
      groups: e
    });
    if (t) {
      const c = at(i.map((l) => [l.sharedStackKey, 0]));
      i.forEach((l) => {
        o.forEach((p) => {
          c[l.sharedStackKey] += l[p];
        });
      }), i.forEach((l) => {
        o.forEach((p) => {
          const h = c[l.sharedStackKey];
          c[l.sharedStackKey] ? l[p] = l[p] / h * 100 : l[p] = 0;
        });
      });
    }
    return (s ? S().offset(H) : S()).keys(o)(i).map((c, l) => Object.keys(c).filter((p) => !isNaN(p)).map((p) => {
      const h = c[p];
      return h[n] = o[l], h;
    }));
  }
  /**
   * @return {Object} The chart's options
   */
  getOptions() {
    return this.state.options;
  }
  set(t, e) {
    this.state = Object.assign({}, this.state, t);
    const s = Object.assign(
      { skipUpdate: !1, animate: !0 },
      // default configs
      e
    );
    s.skipUpdate || this.update(s.animate);
  }
  get(t) {
    return t ? this.state[t] : this.state;
  }
  /**
   *
   * @param newOptions New options to be set
   */
  setOptions(t) {
    const e = this.getOptions();
    F(e, t), this.set({
      options: _(e, t)
    });
  }
  /**
   *
   * Updates miscellanous information within the model
   * such as the color scales, or the legend data labels
   */
  update(t = !0) {
    this.getDisplayData() && (this.updateAllDataGroups(), this.setCustomColorScale(), this.setColorClassNames(), this.services.events.dispatchEvent(B.Model.UPDATE, { animate: t }));
  }
  /*
   * Data labels
   */
  toggleDataLabel(t) {
    const { ACTIVE: e, DISABLED: s } = O.items.status, a = this.getDataGroups(), n = a.some((l) => l.status === s), o = a.filter((l) => l.status === e);
    if (n)
      if (o.length === 1 && o[0].name === t)
        a.forEach((l, p) => {
          a[p].status = e;
        });
      else {
        const l = a.findIndex((p) => p.name === t);
        a[l].status = a[l].status === s ? e : s;
      }
    else
      a.forEach((l, p) => {
        a[p].status = l.name === t ? e : s;
      });
    const i = a.filter((l) => l.status === e), r = this.getOptions();
    a.some((l) => l.status === s) ? r.data.selectedGroups = i.map((l) => l.name) : r.data.selectedGroups = [], this.services.events.dispatchEvent(B.Legend.ITEMS_UPDATE, {
      dataGroups: a
    }), this.set({
      dataGroups: a
    });
  }
  /**
   * Should the data point be filled?
   * @param group
   * @param key
   * @param data
   * @param defaultFilled the default for this chart
   */
  getIsFilled(t, e, s, a) {
    const n = this.getOptions();
    return n.getIsFilled ? n.getIsFilled(t, e, s, a) : a;
  }
  getFillColor(t, e, s) {
    const a = this.getOptions(), n = u(this.colorScale, t);
    return a.getFillColor ? a.getFillColor(t, e, s, n) : n;
  }
  getStrokeColor(t, e, s) {
    const a = this.getOptions(), n = u(this.colorScale, t);
    return a.getStrokeColor ? a.getStrokeColor(t, e, s, n) : n;
  }
  isUserProvidedColorScaleValid() {
    const t = u(this.getOptions(), "color", "scale"), e = this.getDataGroups();
    return t == null || Object.keys(t).length == 0 ? !1 : e.some(
      (s) => Object.keys(t).includes(s.name)
    );
  }
  getColorClassName(t) {
    const e = this.colorClassNames(t.dataGroupName);
    let s = t.originalClassName;
    return t.classNameTypes.forEach(
      (a) => s = t.originalClassName ? `${s} ${a}-${e}` : `${a}-${e}`
    ), s || "";
  }
  /**
   * For charts that might hold an associated status for their dataset
   */
  getStatus() {
    return null;
  }
  getAllDataGroupsNames() {
    return this.allDataGroups;
  }
  /**
   * Converts data provided in the older format to tabular
   *
   */
  transformToTabularData(t) {
    console.warn(
      "We've updated the charting data format to be tabular by default. The current format you're using is deprecated and will be removed in v1.0, read more here https://charts.carbondesignsystem.com/?path=/story/docs-tutorials--tabular-data-format"
    );
    const e = [], { datasets: s, labels: a } = t;
    return s.forEach((n) => {
      n.data.forEach((o, i) => {
        let r;
        const c = u(n, "label");
        if (c === null) {
          const p = u(a, i);
          p ? r = p : r = "Ungrouped";
        } else
          r = c;
        const l = {
          group: r,
          key: a[i]
        };
        isNaN(o) ? (l.value = o.value, l.date = o.date) : l.value = o, e.push(l);
      });
    }), e;
  }
  getTabularDataArray() {
    return [];
  }
  exportToCSV() {
    const e = this.getTabularDataArray().map(
      (o) => o.map((i) => `"${(i === "&ndash;" ? "â" : i).split(/[,;'"`]/).map((l) => it(l)).join("")}"`)
    ).map((o) => o.join(",")).join(`
`), s = this.getOptions();
    let a = "myChart";
    const n = u(s, "fileDownload", "fileName");
    typeof n == "function" ? a = n("csv") : typeof n == "string" && (a = n), this.services.files.downloadCSV(e, `${a}.csv`);
  }
  getTabularData(t) {
    return Array.isArray(t) ? t : this.transformToTabularData(t);
  }
  sanitize(t) {
    return t = this.getTabularData(t), t;
  }
  /*
   * Data groups
   */
  updateAllDataGroups() {
    this.allDataGroups ? this.getDataGroupNames().forEach((t) => {
      this.allDataGroups.indexOf(t) === -1 && this.allDataGroups.push(t);
    }) : this.allDataGroups = this.getDataGroupNames();
  }
  generateDataGroups(t) {
    const { groupMapsTo: e } = this.getOptions().data, { ACTIVE: s, DISABLED: a } = O.items.status, n = this.getOptions(), o = M(t.map((r) => r[e]));
    n.data.selectedGroups.length && (n.data.selectedGroups.every(
      (c) => o.includes(c)
    ) || (n.data.selectedGroups = []));
    const i = (r) => !n.data.selectedGroups.length || n.data.selectedGroups.includes(r) ? s : a;
    return o.map((r) => ({
      name: r,
      status: i(r)
    }));
  }
  /*
   * Fill scales
   */
  setCustomColorScale() {
    if (!this.isUserProvidedColorScaleValid())
      return;
    const t = this.getOptions(), e = u(t, "color", "scale");
    Object.keys(e).forEach((a) => {
      this.allDataGroups.includes(a) || console.warn(`"${a}" does not exist in data groups.`);
    }), this.allDataGroups.filter((a) => e[a]).forEach(
      (a) => this.colorScale[a] = e[a]
    );
  }
  /*
   * Color palette
   */
  setColorClassNames() {
    const t = u(this.getOptions(), "color", "pairing");
    let e = u(t, "numberOfVariants");
    (!e || e < this.allDataGroups.length) && (e = this.allDataGroups.length);
    let s = u(t, "option");
    const a = V.pairingOptions, n = e > 5 ? 14 : e, o = `${n}-color`;
    s = s <= a[o] ? s : 1;
    const i = this.allDataGroups.map(
      (r, c) => `${n}-${s}-${c % 14 + 1}`
    );
    this.colorClassNames = R().range(i).domain(this.allDataGroups);
  }
}
class T extends D {
  // can't be protected as it's used by two-dimensional-axes.ts
  constructor(t) {
    super(t), this.axisFlavor = $.DEFAULT;
  }
  // get the scales information
  // needed for getTabularArray()
  assignRangeAndDomains() {
    const { cartesianScales: t } = this.services, e = this.getOptions(), s = t.isDualAxes(), a = {
      primaryDomain: t.domainAxisPosition,
      primaryRange: t.rangeAxisPosition,
      secondaryDomain: null,
      secondaryRange: null
    };
    return s && (a.secondaryDomain = t.secondaryDomainAxisPosition, a.secondaryRange = t.secondaryRangeAxisPosition), Object.keys(a).forEach(
      (n) => {
        const o = a[n];
        t.scales[o] ? a[n] = {
          position: o,
          label: t.getScaleLabel(o),
          identifier: u(e, "axes", o, "mapsTo")
        } : a[n] = null;
      }
    ), a;
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), e = this.getOptions(), { groupMapsTo: s } = e.data, { primaryDomain: a, primaryRange: n, secondaryDomain: o, secondaryRange: i } = this.assignRangeAndDomains(), { number: r, code: c } = u(this.getOptions(), "locale"), l = [
      "Group",
      a.label,
      n.label,
      ...o ? [o.label] : [],
      ...i ? [i.label] : []
    ], p = t.map((h) => [
      h[s],
      h[a.identifier] === null ? "&ndash;" : h[a.identifier],
      h[n.identifier] === null || isNaN(h[n.identifier]) ? "&ndash;" : r(h[n.identifier], c),
      ...o ? [
        h[o.identifier] === null ? "&ndash;" : h[o.identifier]
      ] : [],
      ...i ? [
        h[i.identifier] === null || isNaN(h[i.identifier]) ? "&ndash;" : h[i.identifier]
      ] : []
    ]);
    return super.formatTable({ headers: l, cells: p });
  }
  setData(t) {
    let e;
    if (t && (e = super.setData(t), u(this.getOptions(), "zoomBar", A.TOP, "enabled"))) {
      const s = u(
        this.getOptions(),
        "zoomBar",
        A.TOP,
        "data"
      );
      this.setZoomBarData(s);
    }
    return e;
  }
  /**
   * @param zoomBarData any special zoom bar data to use instead of the model data
   */
  setZoomBarData(t) {
    const e = t ? this.sanitize(G(t)) : this.getDisplayData();
    let s = e;
    const { cartesianScales: a } = this.services;
    if (e && a.domainAxisPosition && a.rangeAxisPosition) {
      const n = a.getDomainIdentifier(), o = a.getRangeIdentifier();
      let i = e.map((r) => r[n].getTime());
      i = M(i).sort(), s = i.map((r) => {
        let c = 0;
        const l = {};
        return e.forEach((p) => {
          p[n].getTime() === r && (c += p[o]);
        }), l[n] = new Date(r), l[o] = c, l;
      });
    }
    this.set({ zoomBarData: s });
  }
  getZoomBarData() {
    return this.get("zoomBarData");
  }
  sanitizeDateValues(t) {
    const e = this.getOptions();
    if (!e.axes)
      return t;
    const s = [];
    return Object.keys(A).forEach((a) => {
      const n = A[a], o = e.axes[n];
      if (o && o.scaleType === f.TIME) {
        const i = o.mapsTo;
        (i !== null || i !== void 0) && s.push(i);
      }
    }), s.length > 0 && t.forEach((a) => {
      s.forEach((n) => {
        u(a, n, "getTime") === null && (a[n] = new Date(a[n]));
      });
    }), t;
  }
  sanitize(t) {
    return t = super.sanitize(t), t = this.sanitizeDateValues(t), t;
  }
}
class ht extends T {
  constructor(t) {
    super(t);
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), { number: e, code: s } = u(this.getOptions(), "locale");
    t.sort((o, i) => o.source.localeCompare(i.source));
    const a = ["Source", "Target", "Value"], n = [
      ...t.map((o) => [
        o.source,
        o.target,
        o.value === null ? "&ndash;" : e(o.value, s)
      ])
    ];
    return super.formatTable({ headers: a, cells: n });
  }
}
class gt extends T {
  constructor(t) {
    super(t);
  }
  getBoxQuartiles(t) {
    return {
      q_25: E(t, 0.25),
      q_50: E(t, 0.5),
      q_75: E(t, 0.75)
    };
  }
  getBoxplotData() {
    const t = this.getOptions(), { groupMapsTo: e } = t.data, s = this.getGroupedData(), a = [];
    for (const { name: n, data: o } of s) {
      const i = this.services.cartesianScales.getRangeIdentifier(), r = o.map((v) => v[i]).sort(Z), c = {
        [e]: n,
        counts: r,
        quartiles: this.getBoxQuartiles(r),
        outliers: null,
        whiskers: null
      }, l = c.quartiles.q_25, p = c.quartiles.q_75, h = (p - l) * 1.5, g = l - h, m = p + h, y = [], x = [];
      for (const v of r)
        v < g || v > m ? y.push(v) : x.push(v);
      c.outliers = y;
      const q = P(x), I = k(x);
      c.whiskers = {
        min: q || P([c.quartiles.q_25, c.quartiles.q_50, c.quartiles.q_75]),
        max: I || k([c.quartiles.q_25, c.quartiles.q_50, c.quartiles.q_75])
      }, a.push(c);
    }
    return a;
  }
  getTabularDataArray() {
    const t = this.getOptions(), { groupMapsTo: e } = t.data, s = this.getBoxplotData(), { number: a, code: n } = u(t, "locale"), o = ["Group", "Minimum", "Q1", "Median", "Q3", "Maximum", "IQR", "Outlier(s)"], i = [
      ...s.map((r) => {
        let c = u(r, "outliers");
        return (c === null || c.length === 0) && (c = ["&ndash;"]), [
          r[e],
          u(r, "whiskers", "min") !== null ? a(u(r, "whiskers", "min"), n) : "&ndash;",
          u(r, "quartiles", "q_25") !== null ? a(u(r, "quartiles", "q_25"), n) : "&ndash;",
          u(r, "quartiles", "q_50") !== null ? a(u(r, "quartiles", "q_50"), n) : "&ndash;",
          u(r, "quartiles", "q_75") !== null ? a(u(r, "quartiles", "q_75"), n) : "&ndash;",
          u(r, "whiskers", "max") !== null ? a(u(r, "whiskers", "max"), n) : "&ndash;",
          u(r, "quartiles", "q_75") !== null && u(r, "quartiles", "q_25") !== null ? (a(
            u(r, "quartiles", "q_75") - u(r, "quartiles", "q_25")
          ), n) : "&ndash;",
          c.map((l) => a(l, n)).join(",")
        ];
      })
    ];
    return super.formatTable({ headers: o, cells: i });
  }
  setColorClassNames() {
    const e = u(this.getOptions(), "color", "pairing");
    let s = u(e, "option");
    const a = V.pairingOptions;
    s = s <= a["1-color"] ? s : 1;
    const n = this.allDataGroups.map(() => `1-${s}-1`);
    this.colorClassNames = R().range(n).domain(this.allDataGroups);
  }
}
class dt extends T {
  constructor(t) {
    super(t);
  }
  /**
   * Determines the index of the performance area titles to use
   * @param datum
   * @returns number
   */
  getMatchingRangeIndexForDatapoint(t) {
    let e;
    for (let s = t.ranges.length - 1; s > 0; s--) {
      const a = t.ranges[s];
      if (t.value >= a)
        return e = s, e;
    }
    return 0;
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), e = this.getOptions(), { groupMapsTo: s } = e.data, a = this.services.cartesianScales.getRangeIdentifier(), { number: n, code: o } = u(e, "locale"), i = u(e, "bullet", "performanceAreaTitles"), r = ["Title", "Group", "Value", "Target", "Percentage", "Performance"], c = [
      ...t.map((l) => [
        l.title,
        l[s],
        l.value === null ? "&ndash;" : n(l.value, o),
        u(l, "marker") === null ? "&ndash;" : n(l.marker, o),
        u(l, "marker") === null ? "&ndash;" : `${n(Math.floor(l[a] / l.marker * 100), o)}%`,
        i[this.getMatchingRangeIndexForDatapoint(l)]
      ])
    ];
    return super.formatTable({ headers: r, cells: c });
  }
}
class mt extends D {
  constructor(t) {
    super(t), this._colorScale = void 0, this._matrix = {};
  }
  /**
   * @override
   * @param value
   * @returns string
   */
  getFillColor(t) {
    return this._colorScale(t);
  }
  /**
   * Helper function that will generate a dictionary
   */
  getCombinedData() {
    if (b(this._matrix)) {
      const t = this.getOptions(), e = this.getDisplayData();
      !b(e) && !b(t.geoData.objects.countries) && (t.geoData.objects.countries.geometries.forEach((s) => {
        this._matrix[s.properties.NAME] = s;
      }), e.forEach((s) => {
        this._matrix[s.name] ? this._matrix[s.name].value = s.value || null : console.warn(`Data point ${s} is missing geographical data.`);
      }));
    }
    return this._matrix;
  }
  /**
   * Generate tabular data from display data
   * @returns Array<Object>
   */
  getTabularDataArray() {
    const t = this.getDisplayData(), { number: e, code: s } = u(this.getOptions(), "locale"), a = ["Country ID", "Country Name", "Value"], n = [
      ...t.map((o) => [
        o.id === null ? "&ndash;" : o.id,
        o.name,
        o.value === null ? "&ndash;" : e(o.value, s)
      ])
    ];
    return super.formatTable({ headers: a, cells: n });
  }
  // Uses quantize scale to return class names
  getColorClassName(t) {
    return `${t.originalClassName} ${this._colorScale(t.value)}`;
  }
  setColorClassNames() {
    const t = u(this.getOptions(), "color");
    this._colorScale = L(this.getDisplayData(), t);
  }
}
class ft extends D {
  constructor(t) {
    super(t), this.parentNode = !1, this.set({ depth: 2 }, { skipUpdate: !0 });
  }
  setData(t) {
    super.setData(t), this.setDataGroups(), t.length === 1 && (this.parentNode = !0), this.setZoom();
  }
  setOptions(t) {
    const e = this.getOptions(), s = _({}, t, this.getZoomOptions(t));
    F(e, s);
    const a = this.getHierarchyLevel(), n = u(e, "circlePack", "hierarchyLevel");
    this.set({
      options: _(e, s),
      depth: n && n < 4 ? n : a
    });
  }
  getZoomOptions(t) {
    if (!this.getDisplayData())
      return {};
    const e = this.getDisplayData(), s = t || this.getOptions(), a = e.length === 1 && u(e, 0, "children") ? u(e, 0, "children") : e;
    let n = this.getHierarchyLevel();
    return a.some((o) => {
      if (o.children && o.children.some((i) => i.children))
        return n = 3, !1;
    }), u(s, "canvasZoom", "enabled") === !0 && n > 2 ? {
      legend: {
        additionalItems: [
          {
            type: Y.ZOOM,
            name: "Click to zoom"
          }
        ]
      }
    } : null;
  }
  setZoom(t) {
    this.setOptions(this.getZoomOptions(t));
  }
  // update the hierarchy level
  updateHierarchyLevel(t) {
    this.set({ depth: t });
  }
  getHierarchyLevel() {
    return this.get("depth");
  }
  hasParentNode() {
    return this.parentNode;
  }
  // set the datagroup name on the items that are it's children
  setDataGroups() {
    const t = this.getData(), e = this.getOptions(), { groupMapsTo: s } = e.data, a = t.map((n) => {
      const o = n[s];
      return this.setChildrenDataGroup(n, o);
    });
    this.set(
      {
        data: a
      },
      { skipUpdate: !0 }
    );
  }
  // sets name recursively down the node tree
  setChildrenDataGroup(t, e) {
    return t.children ? {
      ...t,
      dataGroupName: e,
      children: t.children.map((s) => this.setChildrenDataGroup(s, e))
    } : { ...t, dataGroupName: e };
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), { number: e, code: s } = u(this.getOptions(), "locale"), a = ["Child", "Parent", "Value"], n = [];
    return t.forEach((o) => {
      let i = o.value ? o.value : 0;
      o.children && (i += this.getChildrenDatums(o.children, o.name, n, 0)), n.push(["&ndash;", o.name, e(i, s)]);
    }), super.formatTable({ headers: a, cells: n });
  }
  /**
   * Recursively determine the relationship between all the nested elements in the child
   * @param children: Object
   * @param parent: String
   * @param result: Array<Object>
   * @param totalSum: number
   * @returns: number
   */
  getChildrenDatums(t, e, s = [], a = 0) {
    const n = e, { number: o, code: i } = u(this.getOptions(), "locale");
    return t.forEach((r) => {
      const c = r.name;
      let l = 0;
      if (r.children)
        r.children.length > 0 && (typeof r.value == "number" && (a += r.value), l += this.getChildrenDatums(r.children, c, s, l), s.push([c, n, o(l, i)]), a += l);
      else {
        let p = 0;
        typeof r.value == "number" && (p = r.value, a += r.value), s.push([r.name, n, o(p, i)]);
      }
    }), a;
  }
}
class Dt extends D {
  constructor(t) {
    super(t);
  }
  getTabularData(t) {
    const e = super.getTabularData(t);
    return t !== e && e.forEach((s) => {
      s.key && s.key !== s.group && (s.group = s.key);
    }), e;
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), e = this.getOptions(), { groupMapsTo: s } = e.data, { valueMapsTo: a } = e.pie, { number: n, code: o } = u(e, "locale"), i = ["Group", "Value"], r = [
      ...t.map((c) => [
        c[s],
        c[a] === null ? "&ndash;" : n(c[a], o)
      ])
    ];
    return super.formatTable({ headers: i, cells: r });
  }
  sanitize(t) {
    return this.getTabularData(t).sort((s, a) => a.value - s.value);
  }
}
class yt extends D {
  constructor(t) {
    super(t);
  }
  getDataGroups() {
    return super.getDataGroups().filter((t) => t.name !== "delta");
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), e = this.getOptions(), { groupMapsTo: s } = e.data, { number: a, code: n } = u(this.getOptions(), "locale"), o = ["Group", "Value"], i = [
      ...t.map((r) => [
        r[s],
        r.value === null ? "&ndash;" : a(r.value, n)
      ])
    ];
    return super.formatTable({ headers: o, cells: i });
  }
}
class bt extends T {
  constructor(t) {
    super(t), this.axisFlavor = $.HOVERABLE, this._colorScale = void 0, this._domains = [], this._ranges = [], this._matrix = {};
    const e = u(this.getOptions(), "axes");
    if (u(e, "left", "scaleType") && u(e, "left", "scaleType") !== f.LABELS || u(e, "right", "scaleType") && u(e, "right", "scaleType") !== f.LABELS || u(e, "top", "scaleType") && u(e, "top", "scaleType") !== f.LABELS || u(e, "bottom", "scaleType") && u(e, "bottom", "scaleType") !== f.LABELS)
      throw Error("Heatmap only supports label scaletypes.");
  }
  /**
   * Get min and maximum value of the display data
   * @returns Array consisting of smallest and largest values in  data
   */
  getValueDomain() {
    const t = Q(this.getDisplayData(), (s) => s.value), e = W().domain(t).nice().domain();
    if (e[0] > 0)
      e[0] = 0;
    else if (e[0] === 0 && e[1] === 0)
      return [0, 1];
    return e[0] < 0 && e[1] > 0 && (Math.abs(e[0]) > e[1] ? e[1] = Math.abs(e[0]) : e[0] = -e[1]), e;
  }
  /**
   * @override
   * @param value
   * @returns string
   */
  getFillColor(t) {
    return this._colorScale(t);
  }
  /**
   * Generate a list of all unique domains
   * @returns String[]
   */
  getUniqueDomain() {
    if (b(this._domains)) {
      const t = this.getDisplayData(), { cartesianScales: e } = this.services, s = e.getDomainIdentifier(), a = e.getMainXAxisPosition(), n = e.getCustomDomainValuesByposition(a);
      if (n)
        return n;
      this._domains = Array.from(
        new Set(
          t.map((o) => o[s])
        )
      );
    }
    return this._domains;
  }
  /**
   * Generates a list of all unique ranges
   * @returns String[]
   */
  getUniqueRanges() {
    if (b(this._ranges)) {
      const t = this.getDisplayData(), { cartesianScales: e } = this.services, s = e.getRangeIdentifier(), a = e.getMainYAxisPosition(), n = e.getCustomDomainValuesByposition(a);
      if (n)
        return n;
      this._ranges = Array.from(
        new Set(
          t.map((o) => o[s])
        )
      );
    }
    return this._ranges;
  }
  /**
   * Generates a matrix (If doesn't exist) and returns it
   * @returns Object
   */
  getMatrix() {
    if (b(this._matrix)) {
      const t = this.getUniqueDomain(), e = this.getUniqueRanges(), s = this.services.cartesianScales.getDomainIdentifier(), a = this.services.cartesianScales.getRangeIdentifier(), n = {};
      e.forEach((o) => {
        n[o] = {
          value: null,
          index: -1
        };
      }), t.forEach((o) => {
        this._matrix[o] = G(n);
      }), this.getDisplayData().forEach((o, i) => {
        this._matrix[o[s]][o[a]] = {
          value: o.value,
          index: i
        };
      });
    }
    return this._matrix;
  }
  /**
   *
   * @param newData The new raw data to be set
   */
  setData(t) {
    const e = this.sanitize(G(t)), s = this.generateDataGroups(e);
    return this.set({
      data: e,
      dataGroups: s
    }), this._domains = [], this._ranges = [], this._matrix = {}, e;
  }
  /**
   * Converts Object matrix into a single array
   * @returns object[]
   */
  getMatrixAsArray() {
    b(this._matrix) && this.getMatrix();
    const t = this.getUniqueDomain(), e = this.getUniqueRanges(), s = this.services.cartesianScales.getDomainIdentifier(), a = this.services.cartesianScales.getRangeIdentifier(), n = [];
    return t.forEach((o) => {
      e.forEach((i) => {
        const r = {
          value: this._matrix[o][i].value,
          index: this._matrix[o][i].index
        };
        r[s] = o, r[a] = i, n.push(r);
      });
    }), n;
  }
  /**
   * Generate tabular data from display data
   * @returns Array<Object>
   */
  getTabularDataArray() {
    const t = this.getDisplayData(), { primaryDomain: e, primaryRange: s } = this.assignRangeAndDomains(), { number: a, code: n } = u(this.getOptions(), "locale"), o = [e.label, s.label, "Value"], i = [
      ...t.map((r) => [
        r[e.identifier] === null ? "&ndash;" : r[e.identifier],
        r[s.identifier] === null ? "&ndash;" : r[s.identifier],
        r.value === null ? "&ndash;" : a(r.value, n)
      ])
    ];
    return super.formatTable({ headers: o, cells: i });
  }
  // Uses quantize scale to return class names
  getColorClassName(t) {
    return `${t.originalClassName} ${this._colorScale(t.value)}`;
  }
  setColorClassNames() {
    const t = this.getOptions(), e = u(t, "color", "gradient", "colors"), s = !b(e);
    let a = u(t, "color", "pairing", "option");
    const n = this.getValueDomain(), o = n[0] < 0 && n[1] > 0 ? "diverge" : "mono";
    (a < 1 && a > 4 && o === "mono" || a < 1 && a > 2 && o === "diverge") && (a = 1);
    const i = s ? e : [];
    if (!s) {
      const c = o === "diverge" ? 17 : 11;
      for (let l = 1; l < c + 1; l++)
        i.push(`fill-${o}-${a}-${l}`);
    }
    this._colorScale = X().domain(n).range(i);
    const r = u(this.getOptions(), "color");
    this._colorScale = L(this.getDisplayData(), r);
  }
}
class vt extends T {
  getTabularDataArray() {
    const t = this.getOptions(), { groupMapsTo: e } = t.data, { number: s, code: a } = u(this.getOptions(), "locale"), n = this.getBinnedStackedData(), o = [
      C(t, "bins.rangeLabel") || "Range",
      ...n.map((r) => C(r, `0.${e}`))
    ], i = [
      ...C(n, 0).map((r, c) => [
        `${s(Number(C(r, "data.x0")), a)} â ${s(
          Number(C(r, "data.x1")),
          a
        )}`,
        ...n.map(
          (l) => s(C(l[c], `data.${C(l[c], e)}`), a)
        )
      ])
    ];
    return super.formatTable({ headers: o, cells: i });
  }
}
class Ct extends D {
  constructor(t) {
    super(t);
  }
  getMaximumDomain(t) {
    return t.reduce((s, a) => s + a.value, 0);
  }
  /**
   * Use a provided color for the bar or default to carbon color if no status provided.
   * Defaults to carbon color otherwise.
   * @param group dataset group label
   */
  getFillColor(t) {
    const e = this.getOptions(), s = u(e, "color", "scale"), a = this.getStatus();
    return s || !a ? super.getFillColor(t) : null;
  }
  /**
   * Get the associated status for the data by checking the ranges
   */
  getStatus() {
    const t = this.getOptions(), e = u(this.getDisplayData()), s = (e == null ? void 0 : e.reduce((o, i) => o + i.value, 0)) ?? 0, a = u(t, "meter", "proportional") ? s : s > 100 ? 100 : s, n = u(t, "meter", "status", "ranges");
    if (n) {
      const o = n.filter(
        (i) => i.range[0] <= a && a <= i.range[1]
      );
      if (o.length > 0)
        return o[0].status;
    }
    return null;
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), e = this.getOptions(), { groupMapsTo: s } = e.data, a = this.getStatus(), n = u(e, "meter", "proportional"), { number: o, code: i } = u(this.getOptions(), "locale");
    let r = [], c = [], l;
    if (n === null) {
      l = 100;
      const p = t[0];
      r = ["Group", "Value", ...a ? ["Status"] : []], c = [
        [
          p[s],
          p.value === null ? "&ndash;" : o(p.value, i),
          ...a ? [a] : []
        ]
      ];
    } else {
      const p = u(n, "total");
      l = p || this.getMaximumDomain(t), r = ["Group", "Value", "Percentage of total"], c = [
        ...t.map((h) => {
          let g;
          h.value !== null && h.value !== void 0 ? g = Number(h.value) : g = 0;
          let m = Number((h.value / l * 100).toFixed(2));
          return [
            h[s],
            h.value === null ? "&ndash;" : o(g, i),
            o(m, i) + " %"
          ];
        })
      ];
    }
    return super.formatTable({ headers: r, cells: c });
  }
}
class xt extends T {
  constructor(t) {
    super(t);
  }
  getTabularDataArray() {
    const t = this.getOptions(), e = this.getGroupedData(), { angle: s, value: a } = u(t, "radar", "axes"), { number: n, code: o } = u(t, "locale"), i = u(e, "0", "data").map((l) => l[s]), r = ["Group", ...i], c = [
      ...e.map((l) => [
        l.name,
        ...i.map(
          (p, h) => u(l, "data", h, a) !== null ? n(u(l, "data", h, a), o) : "&ndash;"
        )
      ])
    ];
    return super.formatTable({ headers: r, cells: c });
  }
}
class Tt extends D {
  constructor(t) {
    super(t);
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), e = ["Child", "Parent"], s = [];
    return t.forEach((a) => {
      this.getChildrenDatums(a, s), s.push([a.name, "&ndash;"]);
    }), super.formatTable({ headers: e, cells: s });
  }
  /**
   * Determine the child parent relationship in nested data
   * @param datum: Object
   * @param result: Array<Object>
   */
  getChildrenDatums(t, e = []) {
    t.children && t.children.length > 0 && t.children.forEach((s) => {
      this.getChildrenDatums(s, e), e.push([s.name, t.name]);
    });
  }
}
class Ot extends D {
  constructor(t) {
    super(t);
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), { number: e, code: s } = u(this.getOptions(), "locale"), a = ["Child", "Group", "Value"], n = [];
    return t.forEach((o) => {
      Array.isArray(o.children) ? o.children.forEach((i) => {
        n.push([
          i.name,
          o.name,
          i.value === null ? "&ndash;" : e(i.value, s)
        ]);
      }) : u(o.name) !== null && u(o.value) && n.push(["â", o.name, e(o.value, s)]);
    }), super.formatTable({ headers: a, cells: n });
  }
}
class At extends D {
  constructor(t) {
    super(t);
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), e = this.getOptions(), { fontSizeMapsTo: s, wordMapsTo: a } = e.wordCloud, { groupMapsTo: n } = e.data, { code: o, number: i } = u(e, "locale"), r = [e.tooltip.wordLabel, "Group", e.tooltip.valueLabel], c = [
      ...t.map((l) => [
        l[a],
        l[n],
        i(l[s], o)
      ])
    ];
    return super.formatTable({ headers: r, cells: c });
  }
}
export {
  ht as A,
  gt as B,
  D as C,
  yt as G,
  bt as H,
  Ct as M,
  Dt as P,
  xt as R,
  Tt as T,
  At as W,
  dt as a,
  vt as b,
  T as c,
  mt as d,
  ft as e,
  Ot as f
};
//# sourceMappingURL=wordcloud-DQKXuKDM.mjs.map
