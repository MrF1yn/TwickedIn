import { select as se, max as ie, extent as $, scaleTime as oe, scaleLog as ae, scaleBand as re, scaleLinear as ce, curveLinear as le, curveLinearClosed as ue, curveBasis as me, curveBasisClosed as de, curveBasisOpen as he, curveBundle as ge, curveCardinal as fe, curveCardinalClosed as pe, curveCardinalOpen as xe, curveCatmullRom as De, curveCatmullRomClosed as ye, curveCatmullRomOpen as Ae, curveMonotoneX as Oe, curveMonotoneY as ve, curveNatural as Te, curveStep as Me, curveStepAfter as Pe, curveStepBefore as Se } from "d3";
import { S as y, D as Re } from "./angle-utils-GQFx3vKM.mjs";
import { _ as S, e as l, i as L, S as d } from "./enums-DwsxZqjR.mjs";
import { _ as Be, $ as Le, a0 as Ee, a1 as Ie, a2 as K, a3 as be, a4 as Ce, a5 as Ze, a6 as we, a7 as Fe, a8 as _e, a9 as Ne, K as V, m as c, X as H, aa as g, ab as R, ac as Ve, ad as W, ae as q, H as Y, v as He, Z as Ye } from "./color-scale-utils-CiW9fERh.mjs";
function j(s) {
  var e = s == null ? 0 : s.length;
  return e ? Be(s, 1) : [];
}
function Xe(s) {
  return Le(Ee(s, void 0, j), s + "");
}
function ze(s, e, t) {
  var n = -1, i = s.length;
  e < 0 && (e = -e > i ? 0 : i + e), t = t > i ? i : t, t < 0 && (t += i), i = e > t ? 0 : t - e >>> 0, e >>>= 0;
  for (var o = Array(i); ++n < i; )
    o[n] = s[n + e];
  return o;
}
function Ge(s, e) {
  return e.length < 2 ? s : Ie(s, ze(e, 0, -1));
}
function ke(s, e) {
  return e = K(e, s), s = Ge(s, e), s == null || delete s[be(Ce(e))];
}
function Ue(s) {
  return Ze(s) ? void 0 : s;
}
var $e = 1, Ke = 2, We = 4, qe = Xe(function(s, e) {
  var t = {};
  if (s == null)
    return t;
  var n = !1;
  e = we(e, function(o) {
    return o = K(o, s), n || (n = o.length > 1), o;
  }), Fe(s, _e(s), t), n && (t = Ne(t, $e | Ke | We, Ue));
  for (var i = e.length; i--; )
    ke(t, e[i]);
  return t;
});
class pt extends y {
  /**
   * focal:  object to zoom into
   * canvasElements: all the elements to translate and zoom on the chart area
   * zoomSettings: object containing duration, easing and zoomlevel for the zoom behaviours
   *  */
  zoomIn(e, t, n) {
    let i, o, a;
    const r = n || V;
    e && (i = e.x, o = e.y, a = 2);
    const { width: u, height: h } = Re.getSVGElementSize(this.services.domUtils.getHolder(), {
      useClientDimensions: !0
    });
    t.transition().duration(r.duration).ease(r.ease).attr(
      "transform",
      `translate(${u / 2}, ${h / 2}) scale(${a}) translate(${-i},${-o})`
    ), this.services.events.dispatchEvent(S.CanvasZoom.CANVAS_ZOOM_IN, {
      element: se(e)
    });
  }
  zoomOut(e, t) {
    const n = t || V;
    e.transition().duration(n.duration).ease(n.ease).attr("transform", ""), this.services.events.dispatchEvent(S.CanvasZoom.CANVAS_ZOOM_OUT);
  }
}
class xt extends y {
  init() {
    this.documentFragment = document.createDocumentFragment();
  }
  addEventListener(e, t) {
    this.documentFragment.addEventListener(e, t);
  }
  removeEventListener(e, t) {
    this.documentFragment.removeEventListener(e, t);
  }
  dispatchEvent(e, t) {
    let n;
    t ? n = new CustomEvent(e, {
      detail: t
    }) : (n = document.createEvent("Event"), n.initEvent(e, !1, !0)), this.documentFragment.dispatchEvent(n);
  }
}
class Dt extends y {
  constructor(e, t) {
    super(e, t);
  }
  downloadCSV(e, t) {
    const n = document.createElement("a"), i = "text/csv;encoding:utf-8";
    if (navigator.msSaveBlob)
      navigator.msSaveBlob(
        new Blob([e], {
          type: i
        }),
        t
      );
    else if (URL && "download" in n) {
      const o = URL.createObjectURL(
        new Blob([e], {
          type: i
        })
      );
      n.href = o, n.setAttribute("download", t), document.body.appendChild(n), n.click(), document.body.removeChild(n), URL.revokeObjectURL(o);
    } else
      location.href = `data:application/octet-stream,${encodeURIComponent(e)}`;
  }
  downloadImage(e, t) {
    const n = document.createElement("a");
    n.download = t, n.href = e, document.body.appendChild(n), n.click(), document.body.removeChild(n);
  }
}
class yt extends y {
  constructor() {
    super(...arguments), this.pendingTransitions = {};
  }
  init() {
    var e;
    (e = this.services.events) == null || e.addEventListener(S.Model.UPDATE, () => {
      this.pendingTransitions = {};
    });
  }
  setupTransition({ transition: e, name: t, animate: n }) {
    return this.pendingTransitions[e._id] = e, e.on("end interrupt cancel", () => {
      delete this.pendingTransitions[e._id];
    }), this.model.getOptions().animations === !1 || n === !1 ? e.duration(0) : e.duration(
      c(H, t, "duration") || H.default.duration
    );
  }
  getPendingTransitions() {
    return this.pendingTransitions;
  }
}
function v(s, e) {
  const t = g(s), n = g(e), i = t.getTime() - n.getTime();
  return i < 0 ? -1 : i > 0 ? 1 : i;
}
function je(s, e) {
  const t = g(s), n = g(e);
  return t.getFullYear() - n.getFullYear();
}
function Je(s, e) {
  const t = g(s), n = g(e), i = v(t, n), o = Math.abs(je(t, n));
  t.setFullYear(1584), n.setFullYear(1584);
  const a = v(t, n) === -i, r = i * (o - +a);
  return r === 0 ? 0 : r;
}
function b(s, e) {
  const t = g(s);
  if (isNaN(e))
    return R(s, NaN);
  if (!e)
    return t;
  const n = t.getDate(), i = R(s, t.getTime());
  i.setMonth(t.getMonth() + e + 1, 0);
  const o = i.getDate();
  return n >= o ? i : (t.setFullYear(
    i.getFullYear(),
    i.getMonth(),
    n
  ), t);
}
function J(s, e) {
  return b(s, e * 12);
}
function Qe(s, e) {
  return J(s, -e);
}
function et(s, e) {
  const t = g(s), n = g(e), i = t.getFullYear() - n.getFullYear(), o = t.getMonth() - n.getMonth();
  return i * 12 + o;
}
function tt(s) {
  const e = g(s);
  return e.setHours(23, 59, 59, 999), e;
}
function nt(s) {
  const e = g(s), t = e.getMonth();
  return e.setFullYear(e.getFullYear(), t + 1, 0), e.setHours(23, 59, 59, 999), e;
}
function st(s) {
  const e = g(s);
  return +tt(e) == +nt(e);
}
function it(s, e) {
  const t = g(s), n = g(e), i = v(t, n), o = Math.abs(
    et(t, n)
  );
  let a;
  if (o < 1)
    a = 0;
  else {
    t.getMonth() === 1 && t.getDate() > 27 && t.setDate(30), t.setMonth(t.getMonth() - i * o);
    let r = v(t, n) === -i;
    st(g(s)) && o === 1 && v(s, n) === 1 && (r = !1), a = i * (o - Number(r));
  }
  return a === 0 ? 0 : a;
}
function ot(s, e) {
  return b(s, -e);
}
function at(s, e) {
  const t = g(s), n = g(e), i = X(t, n), o = Math.abs(Ve(t, n));
  t.setDate(t.getDate() - i * o);
  const a = +(X(t, n) === -i), r = i * (o - a);
  return r === 0 ? 0 : r;
}
function X(s, e) {
  const t = s.getFullYear() - e.getFullYear() || s.getMonth() - e.getMonth() || s.getDate() - e.getDate() || s.getHours() - e.getHours() || s.getMinutes() - e.getMinutes() || s.getSeconds() - e.getSeconds() || s.getMilliseconds() - e.getMilliseconds();
  return t < 0 ? -1 : t > 0 ? 1 : t;
}
function Q(s, e) {
  const t = g(s);
  return isNaN(e) ? R(s, NaN) : (e && t.setDate(t.getDate() + e), t);
}
function rt(s, e) {
  return Q(s, -e);
}
function C(s) {
  return (e) => {
    const n = (s ? Math[s] : Math.trunc)(e);
    return n === 0 ? 0 : n;
  };
}
function Z(s, e) {
  return +g(s) - +g(e);
}
function ct(s, e, t) {
  const n = Z(s, e) / W;
  return C(t == null ? void 0 : t.roundingMethod)(n);
}
function w(s, e) {
  const t = +g(s);
  return R(s, t + e);
}
function ee(s, e) {
  return w(s, e * W);
}
function lt(s, e) {
  return ee(s, -e);
}
function z(s, e, t) {
  const n = Z(s, e) / q;
  return C(t == null ? void 0 : t.roundingMethod)(n);
}
function E(s, e) {
  return w(s, e * q);
}
function G(s, e) {
  return E(s, -e);
}
function k(s, e, t) {
  const n = Z(s, e) / 1e3;
  return C(t == null ? void 0 : t.roundingMethod)(n);
}
function I(s, e) {
  return w(s, e * 1e3);
}
function U(s, e) {
  return I(s, -e);
}
class At extends y {
  constructor() {
    super(...arguments), this.scaleTypes = {
      top: null,
      right: null,
      bottom: null,
      left: null
    }, this.scales = {
      // null or function
      top: null,
      right: null,
      bottom: null,
      left: null
    };
  }
  getDomainAxisPosition({ datum: e = null } = {}) {
    if (this.dualAxes && e) {
      const t = this.model.getOptions(), { groupMapsTo: n } = t.data, i = c(t, "axes", this.secondaryDomainAxisPosition), o = e[n];
      if (i != null && i.correspondingDatasets && i.correspondingDatasets.includes(o))
        return this.secondaryDomainAxisPosition;
    }
    return this.domainAxisPosition;
  }
  getRangeAxisPosition({ datum: e = null, groups: t = null } = {}) {
    if (this.dualAxes) {
      const n = this.model.getOptions(), { groupMapsTo: i } = n.data, o = c(n, "axes", this.secondaryRangeAxisPosition);
      let a;
      if (e !== null ? a = e[i] : t && t.length > 0 && (a = t[0]), o != null && o.correspondingDatasets && o.correspondingDatasets.includes(a))
        return this.secondaryRangeAxisPosition;
    }
    return this.rangeAxisPosition;
  }
  getAxisOptions(e) {
    return c(this.model.getOptions(), "axes", e);
  }
  getDomainAxisOptions() {
    const e = this.getDomainAxisPosition();
    return this.getAxisOptions(e);
  }
  getRangeAxisOptions() {
    const e = this.getRangeAxisPosition();
    return this.getAxisOptions(e);
  }
  getScaleLabel(e) {
    const n = this.getAxisOptions(e).title;
    return n || (e === l.BOTTOM || e === l.TOP ? "x-value" : "y-value");
  }
  getDomainLabel() {
    return this.getScaleLabel(this.getDomainAxisPosition());
  }
  getRangeLabel() {
    return this.getScaleLabel(this.getRangeAxisPosition());
  }
  update() {
    this.determineAxisDuality(), this.findDomainAndRangeAxes(), this.determineOrientation(), Object.keys(l).map(
      (t) => l[t]
    ).forEach((t) => {
      this.scales[t] = this.createScale(t);
    });
  }
  findDomainAndRangeAxes() {
    const e = this.findVerticalAxesPositions(), t = this.findHorizontalAxesPositions(), n = this.findDomainAndRangeAxesPositions(
      e,
      t
    );
    this.domainAxisPosition = n.primaryDomainAxisPosition, this.rangeAxisPosition = n.primaryRangeAxisPosition, this.isDualAxes() && (this.secondaryDomainAxisPosition = n.secondaryDomainAxisPosition, this.secondaryRangeAxisPosition = n.secondaryRangeAxisPosition);
  }
  determineOrientation() {
    (this.rangeAxisPosition === l.LEFT || this.rangeAxisPosition === l.RIGHT) && (this.domainAxisPosition === l.BOTTOM || this.domainAxisPosition === l.TOP) ? this.orientation = L.VERTICAL : this.orientation = L.HORIZONTAL;
  }
  isDualAxes() {
    return this.dualAxes;
  }
  // if any of the axes objects have correspondingDatasets [] asserted we flag the chart as dual axes
  // it does not count as dual axes if it just has another axis turned on but is not actually using it to map a dataset
  determineAxisDuality() {
    var n, i, o, a;
    const e = this.model.getOptions(), t = c(e, "axes");
    ((n = t[l.LEFT]) != null && n.correspondingDatasets && t[l.RIGHT] || (i = t[l.RIGHT]) != null && i.correspondingDatasets && t[l.LEFT] || (o = t[l.TOP]) != null && o.correspondingDatasets && t[l.BOTTOM] || (a = t[l.BOTTOM]) != null && a.correspondingDatasets && t[l.TOP]) && (this.dualAxes = !0);
  }
  getCustomDomainValuesByposition(e) {
    const t = c(this.model.getOptions(), "axes", e, "domain");
    if (t && !Array.isArray(t))
      throw new Error(`Domain in ${e} axis is not a valid array`);
    if (Array.isArray(t) && (this.scaleTypes[e] === d.LINEAR || this.scaleTypes[e] === d.TIME) && t.length !== 2)
      throw new Error(
        `There can only be 2 elements in domain for scale type: ${this.scaleTypes[e]}`
      );
    return t;
  }
  getOrientation() {
    return this.orientation;
  }
  getScaleByPosition(e) {
    return this.scales[e];
  }
  getScaleTypeByPosition(e) {
    return this.scaleTypes[e];
  }
  getDomainAxisScaleType() {
    const e = this.getDomainAxisPosition();
    return this.getScaleTypeByPosition(e);
  }
  getRangeAxisScaleType() {
    const e = this.getRangeAxisPosition();
    return this.getScaleTypeByPosition(e);
  }
  getDomainScale() {
    return this.scales[this.domainAxisPosition];
  }
  getRangeScale() {
    return this.scales[this.rangeAxisPosition];
  }
  // Find the main x-axis out of the 2 x-axis on the chart (when 2D axis is used)
  getMainXAxisPosition() {
    const e = [l.BOTTOM, l.TOP];
    return [this.domainAxisPosition, this.rangeAxisPosition].find(
      (t) => e.indexOf(t) > -1
    );
  }
  // Find the main y-axis out of the 2 y-axis on the chart (when 2D axis is used)
  getMainYAxisPosition() {
    const e = [l.LEFT, l.RIGHT];
    return [this.domainAxisPosition, this.rangeAxisPosition].find(
      (t) => e.indexOf(t) > -1
    );
  }
  getMainXScale() {
    return this.scales[this.getMainXAxisPosition()];
  }
  getMainYScale() {
    return this.scales[this.getMainYAxisPosition()];
  }
  getValueFromScale(e, t, n, i) {
    const o = this.model.getOptions(), r = c(o, "axes")[n], { mapsTo: u } = r, h = c(i, u) !== null ? i[u] : i;
    let p;
    switch (t) {
      case d.LABELS:
        p = e(h) + e.step() / 2;
        break;
      case d.TIME:
        p = e(new Date(h));
        break;
      default:
        p = e(h);
    }
    return p;
  }
  getBoundedScaledValues(e) {
    const { bounds: t } = this.model.getOptions(), n = this.getRangeAxisPosition({ datum: e }), i = this.scales[n], o = this.model.getOptions(), r = c(o, "axes")[n], { mapsTo: u } = r, h = e[u] !== void 0 ? e[u] : e;
    return [
      i(
        c(e, t.upperBoundMapsTo) !== null ? e[t.upperBoundMapsTo] : h
      ),
      i(
        c(e, t.lowerBoundMapsTo) !== null ? e[t.lowerBoundMapsTo] : h
      )
    ];
  }
  getValueThroughAxisPosition(e, t) {
    const n = this.scaleTypes[e], i = this.scales[e];
    return this.getValueFromScale(i, n, e, t);
  }
  getDomainValue(e) {
    const t = this.getDomainAxisPosition({ datum: e });
    return this.getValueThroughAxisPosition(t, e);
  }
  getRangeValue(e) {
    const t = this.getRangeAxisPosition({ datum: e });
    return this.getValueThroughAxisPosition(t, e);
  }
  getMainXScaleType() {
    return this.getScaleTypeByPosition(this.getMainXAxisPosition());
  }
  getMainYScaleType() {
    return this.getScaleTypeByPosition(this.getMainYAxisPosition());
  }
  getDomainIdentifier(e) {
    const t = this.model.getOptions();
    return c(t, "axes", this.getDomainAxisPosition({ datum: e }), "mapsTo");
  }
  getRangeIdentifier(e) {
    const t = this.model.getOptions();
    return c(t, "axes", this.getRangeAxisPosition({ datum: e }), "mapsTo");
  }
  extendsDomain(e, t) {
    const n = this.model.getOptions(), i = c(n, "axes", e);
    if (i.scaleType === d.TIME) {
      const o = c(n, "timeScale", "addSpaceOnEdges");
      return ut(t, o);
    } else
      return mt(t, Y.paddingRatio, i.scaleType);
  }
  findVerticalAxesPositions() {
    const e = this.model.getOptions(), t = c(e, "axes"), n = this.isDualAxes();
    return c(t, l.LEFT) === null && c(t, l.RIGHT) !== null || c(t, l.RIGHT, "main") === !0 || n && c(t, l.LEFT, "correspondingDatasets") ? {
      primary: l.RIGHT,
      secondary: l.LEFT
    } : { primary: l.LEFT, secondary: l.RIGHT };
  }
  findHorizontalAxesPositions() {
    const e = this.model.getOptions(), t = c(e, "axes"), n = this.isDualAxes();
    return c(t, l.BOTTOM) === null && c(t, l.TOP) !== null || c(t, l.TOP, "main") === !0 || n && c(t, l.BOTTOM, "correspondingDatasets") ? {
      primary: l.TOP,
      secondary: l.BOTTOM
    } : { primary: l.BOTTOM, secondary: l.TOP };
  }
  findDomainAndRangeAxesPositions(e, t) {
    const n = this.model.getOptions(), i = c(n, "axes", e.primary), o = c(n, "axes", t.primary), a = i.scaleType || d.LINEAR, r = o.scaleType || d.LINEAR, u = {
      primaryDomainAxisPosition: null,
      secondaryDomainAxisPosition: null,
      primaryRangeAxisPosition: null,
      secondaryRangeAxisPosition: null
    };
    return u.primaryDomainAxisPosition = t.primary, u.primaryRangeAxisPosition = e.primary, u.secondaryDomainAxisPosition = t.secondary, u.secondaryRangeAxisPosition = e.secondary, (!(r === d.LABELS || r === d.TIME) && a === d.LABELS || a === d.TIME) && (u.primaryDomainAxisPosition = e.primary, u.primaryRangeAxisPosition = t.primary, u.secondaryDomainAxisPosition = e.secondary, u.secondaryRangeAxisPosition = t.secondary), u;
  }
  getScaleDomain(e) {
    const t = this.model.getOptions(), n = c(t, "axes", e), i = c(t, "bounds"), { includeZero: o } = n, a = c(n, "scaleType") || d.LINEAR;
    if (this.model.isDataEmpty())
      return [];
    if (n.binned) {
      const { bins: m } = this.model.getBinConfigurations();
      return [0, ie(m, (f) => f.length)];
    } else if (n.limitDomainToBins) {
      const { bins: m } = this.model.getBinConfigurations(), f = this.model.getStackKeys({ bins: m });
      return [f[0].split(":")[0], f[f.length - 1].split(":")[1]];
    }
    const r = this.model.getDisplayData(), { extendLinearDomainBy: u, mapsTo: h, percentage: p, thresholds: D } = n, { reference: A, compareTo: T } = Y.ratio;
    if (n.domain)
      return a === d.LABELS ? n.domain : (a === d.TIME && (n.domain = n.domain.map(
        (m) => m.getTime === void 0 ? new Date(m) : m
      )), this.extendsDomain(e, n.domain));
    if (p)
      return [0, 100];
    if (n && a === d.LABELS)
      return He(r.map((m) => m[h]));
    let M, x;
    const B = this.model.getDataGroupNames();
    if (a === d.LABELS_RATIO)
      return r.map((m) => `${m[A]}/${m[T]}`);
    if (a === d.TIME)
      x = r.map((m) => +new Date(m[h]));
    else if (i && t.axes)
      x = [], r.forEach((m) => {
        x.push(m[h]), m[i.upperBoundMapsTo] && x.push(m[i.upperBoundMapsTo]), m[i.lowerBoundMapsTo] && x.push(m[i.lowerBoundMapsTo]);
      });
    else if (n.stacked === !0 && B && e === this.getRangeAxisPosition()) {
      const { groupMapsTo: m } = t.data, f = this.model.getDataValuesGroupedByKeys({
        groups: B
      }), te = r.filter(
        (O) => !B.includes(O[m])
      ), F = [];
      f.forEach((O) => {
        const { ...ne } = O;
        let _ = 0, N = 0;
        Object.values(qe(ne, "sharedStackKey")).forEach((P) => {
          isNaN(P) || (P < 0 ? N += P : _ += P);
        }), F.push([N, _]);
      }), x = [
        ...j(F),
        ...te.map((O) => O[h])
      ];
    } else
      x = [], r.forEach((m) => {
        const f = m[h];
        Array.isArray(f) && f.length === 2 ? (x.push(f[0]), x.push(f[1])) : (u && x.push(Math.max(m[h], m[u])), x.push(f));
      });
    return a !== d.TIME && a !== d.LOG && o && x.push(0), D && D.length > 0 && D.forEach((m) => {
      const f = c(m, "value");
      f !== null && x.push(f);
    }), M = $(x), M = this.extendsDomain(e, M), M;
  }
  createScale(e) {
    const t = this.model.getOptions(), n = c(t, "axes", e);
    if (!n)
      return null;
    const i = c(n, "scaleType") || d.LINEAR;
    this.scaleTypes[e] = i;
    let o;
    return i === d.TIME ? o = oe() : i === d.LOG ? o = ae().base(n.base || 10) : i === d.LABELS || i === d.LABELS_RATIO ? o = re() : o = ce(), o.domain(this.getScaleDomain(e)), o;
  }
  getDomainLowerBound(e) {
    let t, n = 0;
    return this.getOrientation() === L.VERTICAL ? t = this.getMainYScale().domain() : t = this.getMainXScale().domain(), c(this.model.getOptions(), "axes", e, "includeZero") === !1 && t[0] > 0 && t[1] > 0 && (n = t[0]), n;
  }
  getHighestDomainThreshold() {
    const e = c(this.model.getOptions(), "axes"), t = this.getDomainAxisPosition(), { thresholds: n } = e[t];
    if (!Array.isArray(n) || Array.isArray(n) && !n.length)
      return null;
    const i = this.getDomainScale(), o = n.sort((r, u) => u.value - r.value)[0];
    return this.getScaleTypeByPosition(t) === d.TIME && (typeof o.value == "string" || o.value.getTime === void 0) && (o.value = new Date(o.value)), {
      threshold: o,
      scaleValue: i(o.value)
    };
  }
  getHighestRangeThreshold() {
    const e = c(this.model.getOptions(), "axes"), t = this.getRangeAxisPosition(), { thresholds: n } = e[t];
    if (!Array.isArray(n) || Array.isArray(n) && !n.length)
      return null;
    const i = this.getRangeScale(), o = n.sort((a, r) => r.value - a.value)[0];
    return {
      threshold: o,
      scaleValue: i(o.value)
    };
  }
}
function ut(s, e) {
  const t = new Date(s[0]), n = new Date(s[1]);
  return Je(n, t) > 1 ? [Qe(t, e), J(n, e)] : it(n, t) > 1 ? [ot(t, e), b(n, e)] : at(n, t) > 1 ? [rt(t, e), Q(n, e)] : ct(n, t) > 1 ? [lt(t, e), ee(n, e)] : z(n, t) > 30 ? [
    G(t, e * 30),
    E(n, e * 30)
  ] : z(n, t) > 1 ? [G(t, e), E(n, e)] : k(n, t) > 15 ? [
    U(t, e * 15),
    I(n, e * 15)
  ] : k(n, t) > 1 ? [U(t, e), I(n, e)] : [t, n];
}
function mt([s, e], t, n) {
  const o = (e - s) * t, a = e <= 0 && e + o > 0 ? 0 : e + o;
  let r = s >= 0 && s - o < 0 ? 0 : s - o;
  if (n === d.LOG && r <= 0) {
    if (s <= 0)
      throw Error("Data must have values greater than 0 if log scale type is used.");
    r = s;
  }
  return [r, a];
}
class Ot extends y {
  constructor() {
    super(...arguments), this.curveTypes = {
      curveLinear: le,
      curveLinearClosed: ue,
      curveBasis: me,
      curveBasisClosed: de,
      curveBasisOpen: he,
      curveBundle: ge,
      curveCardinal: fe,
      curveCardinalClosed: pe,
      curveCardinalOpen: xe,
      curveCatmullRom: De,
      curveCatmullRomClosed: ye,
      curveCatmullRomOpen: Ae,
      curveMonotoneX: Oe,
      curveMonotoneY: ve,
      curveNatural: Te,
      curveStep: Me,
      curveStepAfter: Pe,
      curveStepBefore: Se
    };
  }
  getD3Curve() {
    let e = "curveLinear";
    const t = this.model.getOptions().curve;
    if (t && (typeof t == "string" ? e = t : e = t.name), this.curveTypes[e]) {
      let n = this.curveTypes[e];
      return t && Object.keys(t).forEach((i) => {
        n[i] && (n = n[i](t[i]));
      }), n;
    }
    return console.warn(`The curve type '${e}' is invalid, using 'curveLinear' instead`), this.curveTypes.curveLinear;
  }
}
class vt extends y {
  isZoomBarEnabled() {
    if (!this.services.cartesianScales || !c(this.model.getOptions(), "zoomBar", "top", "enabled"))
      return !1;
    this.services.cartesianScales.findDomainAndRangeAxes();
    const e = this.services.cartesianScales.getMainXAxisPosition(), t = c(
      this.model.getOptions(),
      "axes",
      e,
      "scaleType"
    );
    return e === l.BOTTOM && t === d.TIME;
  }
  // get display data for zoom bar
  // basically it's sum of value grouped by time
  getZoomBarData() {
    const e = this.model.getZoomBarData();
    return e && e.length > 1 ? e : this.model.getDisplayData();
  }
  getDefaultZoomBarDomain(e) {
    if (!this.services.zoom)
      throw new Error("Services zoom not defined");
    const t = e || this.services.zoom.getZoomBarData(), { cartesianScales: n } = this.services;
    if (!n)
      throw new Error("Services cartesianScales undefined");
    const i = n.getMainXAxisPosition(), o = n.getDomainIdentifier(), a = c(this.model.getOptions(), "axes", i, "domain");
    if (Array.isArray(a) && a.length === 2)
      return a;
    if (!i)
      throw new Error("Not defined: mainXAxisPosition");
    return n.extendsDomain(
      i,
      $(t, (r) => r[o])
    );
  }
  handleDomainChange(e, t = { dispatchEvent: !0 }) {
    var n;
    this.model.set({ zoomDomain: e }, { animate: !1 }), t.dispatchEvent && ((n = this.services.events) == null || n.dispatchEvent(S.ZoomDomain.CHANGE, {
      newDomain: e
    }));
  }
  getZoomRatio() {
    return c(this.model.getOptions(), "zoomBar", "zoomRatio");
  }
  // filter out data not inside zoom domain
  // to get better range value for axis label
  filterDataForRangeAxis(e, t) {
    var a;
    const n = this.model.get("zoomDomain"), i = Object.assign(
      { stacked: !1 },
      // default configs
      t
    ), o = c(this.model.getOptions(), "zoomBar", "updateRangeAxis");
    if (this.isZoomBarEnabled() && o && n) {
      const r = i.stacked ? "sharedStackKey" : (a = this.services.cartesianScales) == null ? void 0 : a.getDomainIdentifier(), u = e.filter(
        (h) => new Date(h[r]) >= n[0] && new Date(h[r]) <= n[1]
      );
      if (u.length > 0)
        return u;
    }
    return e;
  }
  zoomIn(e = this.getZoomRatio()) {
    var T;
    const t = this.model.get("zoomDomain"), n = Ye.handleWidth, i = (T = this.services.cartesianScales) == null ? void 0 : T.getMainXScale().copy();
    i.domain(this.getDefaultZoomBarDomain());
    const o = i(t[0]), a = i(t[1]);
    if (a - o < n + 1)
      return;
    const r = i.range(), u = a - o, h = Math.min((r[1] - r[0]) / 2 * (e / 2), u / 2);
    let p = o + h, D = a - h;
    p >= D && (p = o + u / 2 - n / 2, D = a - u / 2 + n / 2);
    const A = [i.invert(p), i.invert(D)];
    (t[0].valueOf() !== A[0].valueOf() || t[1].valueOf() !== A[1].valueOf()) && this.handleDomainChange(A);
  }
  zoomOut(e = this.getZoomRatio()) {
    const t = this.model.get("zoomDomain");
    if (!this.services.cartesianScales)
      throw new Error("Services cartesianScales undefined");
    const n = this.services.cartesianScales.getMainXScale().copy();
    n.domain(this.getDefaultZoomBarDomain());
    const i = n(t[0]), o = n(t[1]), a = n.range(), r = (a[1] - a[0]) / 2 * (e / 2), u = Math.max(i - r, a[0]), h = Math.min(o + r, a[1]), p = [n.invert(u), n.invert(h)];
    (t[0].valueOf() !== p[0].valueOf() || t[1].valueOf() !== p[1].valueOf()) && this.handleDomainChange(p);
  }
  resetZoomDomain() {
    const e = this.model.get("zoomDomain"), t = this.getDefaultZoomBarDomain();
    (e[0].valueOf() !== t[0].valueOf() || e[1].valueOf() !== t[1].valueOf()) && this.handleDomainChange(t);
  }
  // check if current zoom domain is already the min zoom domain
  // when toolbar is rendered, we don't render chart yet
  // don't depend on scale range
  isMinZoomDomain() {
    const e = this.model.get("zoomDomain"), t = this.getDefaultZoomBarDomain();
    if (!e || !t)
      return !1;
    const n = e[1].valueOf() - e[0].valueOf(), i = t[1].valueOf() - t[0].valueOf(), o = c(this.model.getOptions(), "zoomBar", "minZoomRatio");
    return n / i < o;
  }
  // check if current zoom domain is already the max zoom domain
  isMaxZoomDomain() {
    const e = this.model.get("zoomDomain"), t = this.getDefaultZoomBarDomain();
    return !!(e && t && e[0].valueOf() === t[0].valueOf() && e[1].valueOf() === t[1].valueOf());
  }
  isEmptyState() {
    return this.getZoomBarData().length === 0;
  }
  isZoomBarLoading(e) {
    return c(this.model.getOptions(), "zoomBar", e, "loading");
  }
  isZoomBarLocked(e) {
    return c(this.model.getOptions(), "zoomBar", e, "locked");
  }
}
export {
  pt as C,
  xt as E,
  Dt as F,
  yt as T,
  vt as Z,
  Ot as a,
  At as b,
  ze as c,
  j as f
};
//# sourceMappingURL=zoom-DyHfBf_y.mjs.map
